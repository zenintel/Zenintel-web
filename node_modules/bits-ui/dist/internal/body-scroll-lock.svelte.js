import { SvelteMap } from "svelte/reactivity";
import { afterSleep, afterTick, box, onDestroyEffect, } from "svelte-toolbelt";
import { isBrowser, isIOS } from "./is.js";
import { addEventListener } from "./events.js";
import { useId } from "./use-id.js";
import { watch } from "runed";
import { SharedState } from "./shared-state.svelte.js";
const bodyLockStackCount = new SharedState(() => {
    const map = new SvelteMap();
    const locked = $derived.by(() => {
        for (const value of map.values()) {
            if (value)
                return true;
        }
        return false;
    });
    let initialBodyStyle = $state(null);
    let stopTouchMoveListener = null;
    function resetBodyStyle() {
        if (!isBrowser)
            return;
        document.body.setAttribute("style", initialBodyStyle ?? "");
        document.body.style.removeProperty("--scrollbar-width");
        isIOS && stopTouchMoveListener?.();
    }
    watch(() => locked, () => {
        if (!locked)
            return;
        initialBodyStyle = document.body.getAttribute("style");
        const bodyStyle = getComputedStyle(document.body);
        // TODO: account for RTL direction, etc.
        const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        const paddingRight = Number.parseInt(bodyStyle.paddingRight ?? "0", 10);
        const config = {
            padding: paddingRight + verticalScrollbarWidth,
            margin: Number.parseInt(bodyStyle.marginRight ?? "0", 10),
        };
        if (verticalScrollbarWidth > 0) {
            document.body.style.paddingRight = `${config.padding}px`;
            document.body.style.marginRight = `${config.margin}px`;
            document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
            document.body.style.overflow = "hidden";
        }
        if (isIOS) {
            stopTouchMoveListener = addEventListener(document, "touchmove", (e) => {
                if (e.target !== document.documentElement)
                    return;
                if (e.touches.length > 1)
                    return;
                e.preventDefault();
            }, { passive: false });
        }
        afterTick(() => {
            document.body.style.pointerEvents = "none";
            document.body.style.overflow = "hidden";
        });
    });
    onDestroyEffect(() => {
        return () => {
            stopTouchMoveListener?.();
        };
    });
    return {
        get map() {
            return map;
        },
        resetBodyStyle,
    };
});
export class BodyScrollLock {
    #id = useId();
    #initialState;
    #restoreScrollDelay = () => null;
    #countState;
    locked;
    constructor(initialState, restoreScrollDelay = () => null) {
        this.#initialState = initialState;
        this.#restoreScrollDelay = restoreScrollDelay;
        this.#countState = bodyLockStackCount.get();
        if (!this.#countState)
            return;
        this.#countState.map.set(this.#id, this.#initialState ?? false);
        this.locked = box.with(() => this.#countState.map.get(this.#id) ?? false, (v) => this.#countState.map.set(this.#id, v));
        onDestroyEffect(() => {
            this.#countState.map.delete(this.#id);
            // if any locks are still active, we don't reset the body style
            if (isAnyLocked(this.#countState.map))
                return;
            const restoreScrollDelay = this.#restoreScrollDelay();
            // if no locks are active (meaning this was the last lock), we reset the body style
            if (restoreScrollDelay === null) {
                requestAnimationFrame(() => this.#countState.resetBodyStyle());
            }
            else {
                afterSleep(restoreScrollDelay, () => this.#countState.resetBodyStyle());
            }
        });
    }
}
function isAnyLocked(map) {
    for (const [_, value] of map) {
        if (value)
            return true;
    }
    return false;
}

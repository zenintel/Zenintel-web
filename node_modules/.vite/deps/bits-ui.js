import "./chunk-UO423V5A.js";
import "./chunk-RIXFT5AQ.js";
import {
  SvelteMap
} from "./chunk-Y7VYVVY4.js";
import "./chunk-ATE6SF6R.js";
import {
  createSubscriber
} from "./chunk-OZ5CZVGQ.js";
import "./chunk-7RQDXF5S.js";
import {
  esm_default
} from "./chunk-ISMEUBKR.js";
import {
  $11d87f3f76e88657$export$b4a036af3fc0b032,
  $14e0f24ef4ac5c92$export$2061056d06d7cdf7,
  $14e0f24ef4ac5c92$export$629b0a497aa65267,
  $14e0f24ef4ac5c92$export$a18c89cbd24170ff,
  $14e0f24ef4ac5c92$export$a2258d9c4118825c,
  $14e0f24ef4ac5c92$export$a5a3b454ada2268e,
  $14e0f24ef4ac5c92$export$aa8b41735afcabd2,
  $14e0f24ef4ac5c92$export$ea39ec197993aef0,
  $35ea8db9cb2ccb90$export$680ea196effce5f,
  $35ea8db9cb2ccb90$export$99faa760c7908e4f,
  $35ea8db9cb2ccb90$export$ca871e8dbb80966f,
  $35ea8db9cb2ccb90$export$d3b7288e7994edea,
  $fae977aafc393c5c$export$588937bcd60ade55,
  $fae977aafc393c5c$export$6b862160d295c8e,
  $fae977aafc393c5c$export$fd7893f06e92a6a4,
  $fb18d541ea1ad717$export$ad991b66133851cf
} from "./chunk-HH4IKM3L.js";
import {
  focusable,
  isFocusable,
  isTabbable,
  tabbable
} from "./chunk-33AJ44NO.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-ZHHKMDQI.js";
import {
  add_locations,
  append_styles,
  assign,
  attribute_effect,
  bind_this,
  bind_value,
  check_target,
  cleanup_styles,
  component,
  createAttachmentKey,
  create_ownership_validator,
  each,
  element,
  hmr,
  if_block,
  init,
  key_block,
  legacy_api,
  log_if_contains_state,
  onMount,
  prop,
  remove_input_defaults,
  rest_props,
  set_attribute,
  set_selected,
  set_style,
  snippet,
  spread_props,
  validate_binding,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_snippet_args,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-6OHW7WBZ.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  mount,
  props_id,
  set_text,
  text,
  unmount
} from "./chunk-CZHGNK34.js";
import {
  FILENAME,
  HMR,
  child,
  derived_safe_equal,
  effect_root,
  first_child,
  get,
  getAllContexts,
  getContext,
  hasContext,
  next,
  noop,
  on,
  pop,
  proxy,
  push,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  tick,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-2465XKXW.js";
import "./chunk-NXGWPDOQ.js";
import {
  true_default
} from "./chunk-HNWPC2PS.js";
import "./chunk-RVAV4ZRS.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-KWPVD4H7.js";

// node_modules/bits-ui/dist/bits/accordion/exports.js
var exports_exports = {};
__export(exports_exports, {
  Content: () => accordion_content_default,
  Header: () => accordion_header_default,
  Item: () => accordion_item_default,
  Root: () => accordion_default,
  Trigger: () => accordion_trigger_default
});

// node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    var _a;
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        (_a = handler.current) == null ? void 0 : _a.call(this, e);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p2) => upperFirst(p2)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  esm_default(css, iterator);
  return styleObj;
}

// node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/svelte-toolbelt/dist/utils/event-list.js
var EVENT_LIST = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
];
var EVENT_LIST_SET = new Set(EVENT_LIST);

// node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  return EVENT_LIST_SET.has(key);
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    if (!props)
      continue;
    for (const key of Object.keys(props)) {
      const a2 = result[key];
      const b = props[key];
      const aIsFunction = typeof a2 === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a2;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a2, b);
      } else if (key === "class") {
        const aIsClassValue = isClassValue(a2);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key] = clsx(a2, b);
        } else if (aIsClassValue) {
          result[key] = clsx(a2);
        } else if (bIsClassValue) {
          result[key] = clsx(b);
        }
      } else if (key === "style") {
        const aIsObject = typeof a2 === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a2 === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a2, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a2, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a2);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a2);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a2;
        } else if (bIsObject) {
          result[key] = b;
        } else if (aIsString) {
          result[key] = a2;
        } else if (bIsString) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a2;
      }
    }
    for (const key of Object.getOwnPropertySymbols(props)) {
      const a2 = result[key];
      const b = props[key];
      result[key] = b !== void 0 ? b : a2;
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2 == null ? void 0 : activeElement2.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var _document, _subscribe;
var ActiveElement = class {
  constructor(options = {}) {
    __privateAdd(this, _document);
    __privateAdd(this, _subscribe);
    const {
      window: window2 = defaultWindow,
      document: document2 = window2 == null ? void 0 : window2.document
    } = options;
    if (strict_equals(window2, void 0)) return;
    __privateSet(this, _document, document2);
    __privateSet(this, _subscribe, createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    }));
  }
  get current() {
    var _a;
    (_a = __privateGet(this, _subscribe)) == null ? void 0 : _a.call(this);
    if (!__privateGet(this, _document)) return null;
    return getActiveElement(__privateGet(this, _document));
  }
};
_document = new WeakMap();
_subscribe = new WeakMap();
var activeElement = new ActiveElement();

// node_modules/runed/dist/internal/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value, defaultValue) {
  if (isFunction2(value)) {
    const getter = value;
    const gotten = getter();
    if (strict_equals(gotten, void 0)) return defaultValue;
    return gotten;
  }
  if (strict_equals(value, void 0)) return defaultValue;
  return value;
}

// node_modules/runed/dist/utilities/context/context.js
var _name, _key;
var Context = class {
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    __privateAdd(this, _name);
    __privateAdd(this, _key);
    __privateSet(this, _name, name);
    __privateSet(this, _key, Symbol(name));
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return __privateGet(this, _key);
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(__privateGet(this, _key));
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(__privateGet(this, _key));
    if (context === void 0) {
      throw new Error(`Context "${__privateGet(this, _name)}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(__privateGet(this, _key));
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(__privateGet(this, _key), context);
  }
};
_name = new WeakMap();
_key = new WeakMap();

// node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait) {
  let context = tag(state(null), "context");
  const wait$ = tag(user_derived(() => extract(wait, 250)), "wait$");
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(
        context,
        {
          timeout: null,
          runner: null,
          promise,
          resolve,
          reject
        },
        true
      );
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve(await callback.apply(this, args));
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, get(wait$));
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    var _a, _b;
    if (!get(context) || !get(context).timeout) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    await ((_b = (_a = get(context)).runner) == null ? void 0 : _b.call(_a));
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      var _a;
      return !!((_a = get(context)) == null ? void 0 : _a.timeout);
    }
  });
  return debounced;
}

// node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction2(value)) {
    return value();
  }
  return value;
}

// node_modules/runed/dist/utilities/element-size/element-size.svelte.js
var _size, _observed, _options, _node, _window, _width, _height, _subscribe2;
var ElementSize = class {
  constructor(node, options = { box: "border-box" }) {
    // no need to use `$state` here since we are using createSubscriber
    __privateAdd(this, _size, { width: 0, height: 0 });
    __privateAdd(this, _observed, false);
    __privateAdd(this, _options);
    __privateAdd(this, _node);
    __privateAdd(this, _window);
    __privateAdd(this, _width, tag(
      user_derived(() => {
        var _a;
        (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
        return this.getSize().width;
      }),
      "ElementSize.#width"
    ));
    __privateAdd(this, _height, tag(
      user_derived(() => {
        var _a;
        (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
        return this.getSize().height;
      }),
      "ElementSize.#height"
    ));
    __privateAdd(this, _subscribe2, tag(
      user_derived(() => {
        const node$ = get2(__privateGet(this, _node));
        if (!node$) return;
        return createSubscriber((update) => {
          if (!__privateGet(this, _window)) return;
          const observer = new (__privateGet(this, _window)).ResizeObserver((entries) => {
            __privateSet(this, _observed, true);
            for (const entry of entries) {
              const boxSize = strict_equals(__privateGet(this, _options).box, "content-box") ? entry.contentBoxSize : entry.borderBoxSize;
              const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
              __privateGet(this, _size).width = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.inlineSize), 0);
              __privateGet(this, _size).height = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.blockSize), 0);
            }
            update();
          });
          observer.observe(node$);
          return () => {
            __privateSet(this, _observed, false);
            observer.disconnect();
          };
        });
      }),
      "ElementSize.#subscribe"
    ));
    __privateSet(this, _window, options.window ?? defaultWindow);
    __privateSet(this, _options, options);
    __privateSet(this, _node, node);
    __privateSet(this, _size, { width: 0, height: 0 });
  }
  calculateSize() {
    const element2 = get2(__privateGet(this, _node));
    if (!element2 || !__privateGet(this, _window)) {
      return;
    }
    const offsetWidth = element2.offsetWidth;
    const offsetHeight = element2.offsetHeight;
    if (strict_equals(__privateGet(this, _options).box, "border-box")) {
      return { width: offsetWidth, height: offsetHeight };
    }
    const style = __privateGet(this, _window).getComputedStyle(element2);
    const paddingWidth = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingHeight = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderWidth = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderHeight = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const contentWidth = offsetWidth - paddingWidth - borderWidth;
    const contentHeight = offsetHeight - paddingHeight - borderHeight;
    return { width: contentWidth, height: contentHeight };
  }
  getSize() {
    return __privateGet(this, _observed) ? __privateGet(this, _size) : this.calculateSize() ?? __privateGet(this, _size);
  }
  get current() {
    var _a;
    (_a = get(__privateGet(this, _subscribe2))) == null ? void 0 : _a();
    return this.getSize();
  }
  get width() {
    return get(__privateGet(this, _width));
  }
  get height() {
    return get(__privateGet(this, _height));
  }
};
_size = new WeakMap();
_observed = new WeakMap();
_options = new WeakMap();
_node = new WeakMap();
_window = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_subscribe2 = new WeakMap();

// node_modules/runed/dist/utilities/is-mounted/is-mounted.svelte.js
var _isMounted;
var IsMounted = class {
  constructor() {
    __privateAdd(this, _isMounted, tag(state(false), "IsMounted.#isMounted"));
    user_effect(() => {
      untrack(() => set(__privateGet(this, _isMounted), true));
      return () => {
        set(__privateGet(this, _isMounted), false);
      };
    });
  }
  get current() {
    return get(__privateGet(this, _isMounted));
  }
};
_isMounted = new WeakMap();

// node_modules/runed/dist/utilities/previous/previous.svelte.js
var _previous;
var Previous = class {
  constructor(getter, initialValue) {
    __privateAdd(this, _previous, tag(state(void 0), "Previous.#previous"));
    if (strict_equals(initialValue, void 0, false)) set(__privateGet(this, _previous), initialValue, true);
    watch(() => getter(), (_, v) => {
      set(__privateGet(this, _previous), v, true);
    });
  }
  get current() {
    return get(__privateGet(this, _previous));
  }
};
_previous = new WeakMap();

// node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = await fn(...args);
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup(() => controller.abort());
      const result = await fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup,
        signal: controller.signal
      });
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues == null ? void 0 : previousValues[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js
function onDestroyEffect(fn) {
  user_effect(() => {
    return () => {
      fn();
    };
  });
}

// node_modules/svelte-toolbelt/dist/utils/after-sleep.js
function afterSleep(ms, cb) {
  return setTimeout(cb, ms);
}

// node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/svelte-toolbelt/dist/utils/on-mount-effect.svelte.js
function onMountEffect(fn) {
  user_effect(() => {
    const cleanup = untrack(() => fn());
    return cleanup;
  });
}

// node_modules/svelte-toolbelt/dist/utils/dom.js
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
function isHTMLElement(node) {
  return isObject(node) && node.nodeType === ELEMENT_NODE && typeof node.nodeName === "string";
}
function isDocument(node) {
  return isObject(node) && node.nodeType === DOCUMENT_NODE;
}
function isWindow(node) {
  var _a;
  return isObject(node) && ((_a = node.constructor) == null ? void 0 : _a.name) === "VisualViewport";
}
function isNode(node) {
  return isObject(node) && node.nodeType !== void 0;
}
function isShadowRoot(node) {
  return isNode(node) && node.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in node;
}
function contains(parent, child2) {
  var _a;
  if (!parent || !child2)
    return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child2))
    return false;
  const rootNode = (_a = child2.getRootNode) == null ? void 0 : _a.call(child2);
  if (parent === child2)
    return true;
  if (parent.contains(child2))
    return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next3 = child2;
    while (next3) {
      if (parent === next3)
        return true;
      next3 = next3.parentNode || next3.host;
    }
  }
  return false;
}
function getDocument(node) {
  if (isDocument(node))
    return node;
  if (isWindow(node))
    return node.document;
  return (node == null ? void 0 : node.ownerDocument) ?? document;
}
function getWindow(node) {
  var _a;
  if (isShadowRoot(node))
    return getWindow(node.host);
  if (isDocument(node))
    return node.defaultView ?? window;
  if (isHTMLElement(node))
    return ((_a = node.ownerDocument) == null ? void 0 : _a.defaultView) ?? window;
  return window;
}
function getActiveElement2(rootNode) {
  let activeElement2 = rootNode.activeElement;
  while (activeElement2 == null ? void 0 : activeElement2.shadowRoot) {
    const el = activeElement2.shadowRoot.activeElement;
    if (el === activeElement2)
      break;
    else
      activeElement2 = el;
  }
  return activeElement2;
}

// node_modules/svelte-toolbelt/dist/utils/dom-context.svelte.js
var _root;
var DOMContext = class {
  constructor(element2) {
    __publicField(this, "element");
    __privateAdd(this, _root, tag(
      user_derived(() => {
        if (!this.element.current) return document;
        const rootNode = this.element.current.getRootNode() ?? document;
        return rootNode;
      }),
      "DOMContext.root"
    ));
    __publicField(this, "getDocument", () => {
      return getDocument(this.root);
    });
    __publicField(this, "getWindow", () => {
      return this.getDocument().defaultView ?? window;
    });
    __publicField(this, "getActiveElement", () => {
      return getActiveElement2(this.root);
    });
    __publicField(this, "isActiveElement", (node) => {
      return strict_equals(node, this.getActiveElement());
    });
    __publicField(this, "querySelector", (selector) => {
      if (!this.root) return null;
      return this.root.querySelector(selector);
    });
    __publicField(this, "querySelectorAll", (selector) => {
      if (!this.root) return [];
      return this.root.querySelectorAll(selector);
    });
    __publicField(this, "setTimeout", (callback, delay) => {
      return this.getWindow().setTimeout(callback, delay);
    });
    __publicField(this, "clearTimeout", (timeoutId) => {
      return this.getWindow().clearTimeout(timeoutId);
    });
    if (strict_equals(typeof element2, "function")) {
      this.element = box.with(element2);
    } else {
      this.element = element2;
    }
  }
  get root() {
    return get(__privateGet(this, _root));
  }
  set root(value) {
    set(__privateGet(this, _root), value);
  }
  getElementById(id) {
    return this.root.getElementById(id);
  }
};
_root = new WeakMap();

// node_modules/svelte-toolbelt/dist/utils/attach-ref.js
function attachRef(ref, onChange) {
  return {
    [createAttachmentKey()]: (node) => {
      if (box.isBox(ref)) {
        ref.current = node;
        untrack(() => onChange == null ? void 0 : onChange(node));
        return () => {
          if ("isConnected" in node && node.isConnected)
            return;
          ref.current = null;
          onChange == null ? void 0 : onChange(null);
        };
      }
      ref(node);
      untrack(() => onChange == null ? void 0 : onChange(node));
      return () => {
        if ("isConnected" in node && node.isConnected)
          return;
        ref(null);
        onChange == null ? void 0 : onChange(null);
      };
    }
  };
}

// node_modules/bits-ui/dist/internal/attrs.js
function getDataOpenClosed(condition) {
  return condition ? "open" : "closed";
}
function getDataChecked(condition) {
  return condition ? "checked" : "unchecked";
}
function getAriaDisabled(condition) {
  return condition ? "true" : "false";
}
function getAriaReadonly(condition) {
  return condition ? "true" : "false";
}
function getAriaExpanded(condition) {
  return condition ? "true" : "false";
}
function getDataDisabled(condition) {
  return condition ? "" : void 0;
}
function getAriaRequired(condition) {
  return condition ? "true" : "false";
}
function getAriaSelected(condition) {
  return condition ? "true" : "false";
}
function getAriaChecked(checked, indeterminate) {
  if (indeterminate) {
    return "mixed";
  }
  return checked ? "true" : "false";
}
function getAriaOrientation(orientation) {
  return orientation;
}
function getAriaHidden(condition) {
  return condition ? "true" : void 0;
}
function getAriaInvalid(condition) {
  return condition ? "true" : void 0;
}
function getDataOrientation(orientation) {
  return orientation;
}
function getDataInvalid(condition) {
  return condition ? "" : void 0;
}
function getDataRequired(condition) {
  return condition ? "" : void 0;
}
function getDataReadonly(condition) {
  return condition ? "" : void 0;
}
function getDataSelected(condition) {
  return condition ? "" : void 0;
}
function getDataUnavailable(condition) {
  return condition ? "" : void 0;
}
function getHidden(condition) {
  return condition ? true : void 0;
}
function getDisabled(condition) {
  return condition ? true : void 0;
}
function getAriaPressed(condition) {
  return condition ? "true" : "false";
}
function getRequired(condition) {
  return condition ? true : void 0;
}
var _variant, _prefix;
var BitsAttrs = class {
  constructor(config) {
    __privateAdd(this, _variant);
    __privateAdd(this, _prefix);
    __publicField(this, "attrs");
    __privateSet(this, _variant, config.getVariant ? config.getVariant() : null);
    __privateSet(this, _prefix, __privateGet(this, _variant) ? `data-${__privateGet(this, _variant)}-` : `data-${config.component}-`);
    this.getAttr = this.getAttr.bind(this);
    this.selector = this.selector.bind(this);
    this.attrs = Object.fromEntries(config.parts.map((part) => [part, this.getAttr(part)]));
  }
  getAttr(part, variantOverride) {
    if (variantOverride)
      return `data-${variantOverride}-${part}`;
    return `${__privateGet(this, _prefix)}${part}`;
  }
  selector(part, variantOverride) {
    return `[${this.getAttr(part, variantOverride)}]`;
  }
};
_variant = new WeakMap();
_prefix = new WeakMap();
function createBitsAttrs(config) {
  const bitsAttrs = new BitsAttrs(config);
  return {
    ...bitsAttrs.attrs,
    selector: bitsAttrs.selector,
    getAttr: bitsAttrs.getAttr
  };
}

// node_modules/bits-ui/dist/internal/kbd-constants.js
var kbd_constants_exports = {};
__export(kbd_constants_exports, {
  A: () => A,
  ALT: () => ALT,
  ARROW_DOWN: () => ARROW_DOWN,
  ARROW_LEFT: () => ARROW_LEFT,
  ARROW_RIGHT: () => ARROW_RIGHT,
  ARROW_UP: () => ARROW_UP,
  ASTERISK: () => ASTERISK,
  BACKSPACE: () => BACKSPACE,
  CAPS_LOCK: () => CAPS_LOCK,
  CONTROL: () => CONTROL,
  CTRL: () => CTRL,
  DELETE: () => DELETE,
  END: () => END,
  ENTER: () => ENTER,
  ESCAPE: () => ESCAPE,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F2: () => F2,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  HOME: () => HOME,
  META: () => META,
  P: () => P,
  PAGE_DOWN: () => PAGE_DOWN,
  PAGE_UP: () => PAGE_UP,
  SHIFT: () => SHIFT,
  SPACE: () => SPACE,
  TAB: () => TAB,
  a: () => a,
  h: () => h,
  j: () => j,
  k: () => k,
  l: () => l,
  n: () => n,
  p: () => p
});
var ALT = "Alt";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var BACKSPACE = "Backspace";
var CAPS_LOCK = "CapsLock";
var CONTROL = "Control";
var DELETE = "Delete";
var END = "End";
var ENTER = "Enter";
var ESCAPE = "Escape";
var F1 = "F1";
var F10 = "F10";
var F11 = "F11";
var F12 = "F12";
var F2 = "F2";
var F3 = "F3";
var F4 = "F4";
var F5 = "F5";
var F6 = "F6";
var F7 = "F7";
var F8 = "F8";
var F9 = "F9";
var HOME = "Home";
var META = "Meta";
var PAGE_DOWN = "PageDown";
var PAGE_UP = "PageUp";
var SHIFT = "Shift";
var SPACE = " ";
var TAB = "Tab";
var CTRL = "Control";
var ASTERISK = "*";
var a = "a";
var P = "P";
var A = "A";
var p = "p";
var n = "n";
var j = "j";
var k = "k";
var h = "h";
var l = "l";

// node_modules/bits-ui/dist/internal/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// node_modules/bits-ui/dist/internal/get-directional-keys.js
var FIRST_KEYS = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd_constants_exports.SPACE, kbd_constants_exports.ENTER];
function getNextKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT,
    vertical: kbd_constants_exports.ARROW_DOWN
  }[orientation];
}
function getPrevKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT,
    vertical: kbd_constants_exports.ARROW_UP
  }[orientation];
}
function getDirectionalKeys(dir = "ltr", orientation = "horizontal") {
  if (!["ltr", "rtl"].includes(dir))
    dir = "ltr";
  if (!["horizontal", "vertical"].includes(orientation))
    orientation = "horizontal";
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
}

// node_modules/bits-ui/dist/internal/roving-focus-group.js
var _opts, _currentTabStopId;
var RovingFocusGroup = class {
  constructor(opts) {
    __privateAdd(this, _opts);
    __privateAdd(this, _currentTabStopId, box(null));
    __privateSet(this, _opts, opts);
  }
  getCandidateNodes() {
    if (!true_default || !__privateGet(this, _opts).rootNode.current)
      return [];
    if (__privateGet(this, _opts).candidateSelector) {
      const candidates = Array.from(__privateGet(this, _opts).rootNode.current.querySelectorAll(__privateGet(this, _opts).candidateSelector));
      return candidates;
    } else if (__privateGet(this, _opts).candidateAttr) {
      const candidates = Array.from(__privateGet(this, _opts).rootNode.current.querySelectorAll(`[${__privateGet(this, _opts).candidateAttr}]:not([data-disabled])`));
      return candidates;
    }
    return [];
  }
  focusFirstCandidate() {
    var _a;
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    (_a = items[0]) == null ? void 0 : _a.focus();
  }
  handleKeydown(node, e, both = false) {
    var _a, _b;
    const rootNode = __privateGet(this, _opts).rootNode.current;
    if (!rootNode || !node)
      return;
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    const currentIndex = items.indexOf(node);
    const dir = getElemDirection(rootNode);
    const { nextKey, prevKey } = getDirectionalKeys(dir, __privateGet(this, _opts).orientation.current);
    const loop = __privateGet(this, _opts).loop.current;
    const keyToIndex = {
      [nextKey]: currentIndex + 1,
      [prevKey]: currentIndex - 1,
      [kbd_constants_exports.HOME]: 0,
      [kbd_constants_exports.END]: items.length - 1
    };
    if (both) {
      const altNextKey = nextKey === kbd_constants_exports.ARROW_DOWN ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_DOWN;
      const altPrevKey = prevKey === kbd_constants_exports.ARROW_UP ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_UP;
      keyToIndex[altNextKey] = currentIndex + 1;
      keyToIndex[altPrevKey] = currentIndex - 1;
    }
    let itemIndex = keyToIndex[e.key];
    if (itemIndex === void 0)
      return;
    e.preventDefault();
    if (itemIndex < 0 && loop) {
      itemIndex = items.length - 1;
    } else if (itemIndex === items.length && loop) {
      itemIndex = 0;
    }
    const itemToFocus = items[itemIndex];
    if (!itemToFocus)
      return;
    itemToFocus.focus();
    __privateGet(this, _currentTabStopId).current = itemToFocus.id;
    (_b = (_a = __privateGet(this, _opts)).onCandidateFocus) == null ? void 0 : _b.call(_a, itemToFocus);
    return itemToFocus;
  }
  getTabIndex(node) {
    const items = this.getCandidateNodes();
    const anyActive = __privateGet(this, _currentTabStopId).current !== null;
    if (node && !anyActive && items[0] === node) {
      __privateGet(this, _currentTabStopId).current = node.id;
      return 0;
    } else if ((node == null ? void 0 : node.id) === __privateGet(this, _currentTabStopId).current) {
      return 0;
    }
    return -1;
  }
  setCurrentTabStopId(id) {
    __privateGet(this, _currentTabStopId).current = id;
  }
};
_opts = new WeakMap();
_currentTabStopId = new WeakMap();

// node_modules/bits-ui/dist/bits/accordion/accordion.svelte.js
var accordionAttrs = createBitsAttrs({
  component: "accordion",
  parts: [
    "root",
    "trigger",
    "content",
    "item",
    "header"
  ]
});
var AccordionRootContext = new Context("Accordion.Root");
var AccordionItemContext = new Context("Accordion.Item");
var _props;
var AccordionBaseState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        [accordionAttrs.root]: "",
        ...this.attachment
      })),
      "AccordionBaseState.props"
    ));
    this.opts = opts;
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: accordionAttrs.trigger,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
    this.attachment = attachRef(this.opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props));
  }
  set props(value) {
    set(__privateGet(this, _props), value);
  }
};
_props = new WeakMap();
var AccordionSingleState = class extends AccordionBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    this.opts = opts;
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item) {
    this.opts.value.current = this.includesItem(item) ? "" : item;
  }
};
var _value;
var AccordionMultiState = class extends AccordionBaseState {
  constructor(props) {
    super(props);
    __privateAdd(this, _value);
    __publicField(this, "isMulti", true);
    __privateSet(this, _value, props.value);
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return __privateGet(this, _value).current.includes(item);
  }
  toggleItem(item) {
    __privateGet(this, _value).current = this.includesItem(item) ? __privateGet(this, _value).current.filter((v) => strict_equals(v, item, false)) : [...__privateGet(this, _value).current, item];
  }
};
_value = new WeakMap();
var AccordionRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = strict_equals(type, "single") ? new AccordionSingleState(rest) : new AccordionMultiState(rest);
    return AccordionRootContext.set(rootState);
  }
};
var _isActive, _isDisabled, _props2;
var _AccordionItemState = class _AccordionItemState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isActive, tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "AccordionItemState.isActive"));
    __privateAdd(this, _isDisabled, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "AccordionItemState.isDisabled"));
    __publicField(this, "attachment");
    __privateAdd(this, _props2, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": getDataOpenClosed(this.isActive),
        "data-disabled": getDataDisabled(this.isDisabled),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        [accordionAttrs.item]: "",
        ...this.attachment
      })),
      "AccordionItemState.props"
    ));
    this.opts = opts;
    this.root = opts.rootState;
    this.updateValue = this.updateValue.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return AccordionItemContext.set(new _AccordionItemState({
      ...props,
      rootState: AccordionRootContext.get()
    }));
  }
  get isActive() {
    return get(__privateGet(this, _isActive));
  }
  set isActive(value) {
    set(__privateGet(this, _isActive), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled), value);
  }
  updateValue() {
    this.root.toggleItem(this.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props2));
  }
  set props(value) {
    set(__privateGet(this, _props2), value);
  }
};
_isActive = new WeakMap();
_isDisabled = new WeakMap();
_props2 = new WeakMap();
var AccordionItemState = _AccordionItemState;
var _root2, _isDisabled2, _props3;
var _AccordionTriggerState = class _AccordionTriggerState {
  constructor(opts, itemState) {
    __publicField(this, "opts");
    __publicField(this, "itemState");
    __privateAdd(this, _root2);
    __privateAdd(this, _isDisabled2, tag(user_derived(() => this.opts.disabled.current || this.itemState.opts.disabled.current || __privateGet(this, _root2).opts.disabled.current), "AccordionTriggerState.#isDisabled"));
    __publicField(this, "attachment");
    __privateAdd(this, _props3, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: get(__privateGet(this, _isDisabled2)),
        "aria-expanded": getAriaExpanded(this.itemState.isActive),
        "aria-disabled": getAriaDisabled(get(__privateGet(this, _isDisabled2))),
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled2))),
        "data-state": getDataOpenClosed(this.itemState.isActive),
        "data-orientation": getDataOrientation(__privateGet(this, _root2).opts.orientation.current),
        [accordionAttrs.trigger]: "",
        tabindex: 0,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "AccordionTriggerState.props"
    ));
    this.opts = opts;
    this.itemState = itemState;
    __privateSet(this, _root2, itemState.root);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionTriggerState(props, AccordionItemContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled2)) || strict_equals(e.button, 0, false)) {
      e.preventDefault();
      return;
    }
    this.itemState.updateValue();
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled2))) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.itemState.updateValue();
      return;
    }
    __privateGet(this, _root2).rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props3));
  }
  set props(value) {
    set(__privateGet(this, _props3), value);
  }
};
_root2 = new WeakMap();
_isDisabled2 = new WeakMap();
_props3 = new WeakMap();
var AccordionTriggerState = _AccordionTriggerState;
var _originalStyles, _isMountAnimationPrevented, _dimensions, _open, _updateDimensions, _snippetProps, _props4;
var _AccordionContentState = class _AccordionContentState {
  constructor(opts, item) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "attachment");
    __privateAdd(this, _originalStyles);
    __privateAdd(this, _isMountAnimationPrevented, false);
    __privateAdd(this, _dimensions, tag(state(proxy({ width: 0, height: 0 })), "AccordionContentState.#dimensions"));
    __privateAdd(this, _open, tag(user_derived(() => this.opts.forceMount.current || this.item.isActive), "AccordionContentState.open"));
    __privateAdd(this, _updateDimensions, ([_, node]) => {
      if (!node) return;
      afterTick(() => {
        const element2 = this.opts.ref.current;
        if (!element2) return;
        __privateGet(this, _originalStyles) ?? __privateSet(this, _originalStyles, {
          transitionDuration: element2.style.transitionDuration,
          animationName: element2.style.animationName
        });
        element2.style.transitionDuration = "0s";
        element2.style.animationName = "none";
        const rect = element2.getBoundingClientRect();
        set(__privateGet(this, _dimensions), { width: rect.width, height: rect.height }, true);
        if (!__privateGet(this, _isMountAnimationPrevented) && __privateGet(this, _originalStyles)) {
          element2.style.transitionDuration = __privateGet(this, _originalStyles).transitionDuration;
          element2.style.animationName = __privateGet(this, _originalStyles).animationName;
        }
      });
    });
    __privateAdd(this, _snippetProps, tag(user_derived(() => ({ open: this.item.isActive })), "AccordionContentState.snippetProps"));
    __privateAdd(this, _props4, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": getDataOpenClosed(this.item.isActive),
        "data-disabled": getDataDisabled(this.item.isDisabled),
        "data-orientation": getDataOrientation(this.item.root.opts.orientation.current),
        [accordionAttrs.content]: "",
        style: {
          "--bits-accordion-content-height": `${get(__privateGet(this, _dimensions)).height}px`,
          "--bits-accordion-content-width": `${get(__privateGet(this, _dimensions)).width}px`
        },
        ...this.attachment
      })),
      "AccordionContentState.props"
    ));
    this.opts = opts;
    this.item = item;
    __privateSet(this, _isMountAnimationPrevented, this.item.isActive);
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      const rAF = requestAnimationFrame(() => {
        __privateSet(this, _isMountAnimationPrevented, false);
      });
      return () => cancelAnimationFrame(rAF);
    });
    watch([() => this.open, () => this.opts.ref.current], __privateGet(this, _updateDimensions));
  }
  get open() {
    return get(__privateGet(this, _open));
  }
  set open(value) {
    set(__privateGet(this, _open), value);
  }
  static create(props) {
    return new _AccordionContentState(props, AccordionItemContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps), value);
  }
  get props() {
    return get(__privateGet(this, _props4));
  }
  set props(value) {
    set(__privateGet(this, _props4), value);
  }
};
_originalStyles = new WeakMap();
_isMountAnimationPrevented = new WeakMap();
_dimensions = new WeakMap();
_open = new WeakMap();
_updateDimensions = new WeakMap();
_snippetProps = new WeakMap();
_props4 = new WeakMap();
var AccordionContentState = _AccordionContentState;
var _props5;
var _AccordionHeaderState = class _AccordionHeaderState {
  constructor(opts, item) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "attachment");
    __privateAdd(this, _props5, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "heading",
        "aria-level": this.opts.level.current,
        "data-heading-level": this.opts.level.current,
        "data-state": getDataOpenClosed(this.item.isActive),
        "data-orientation": getDataOrientation(this.item.root.opts.orientation.current),
        [accordionAttrs.header]: "",
        ...this.attachment
      })),
      "AccordionHeaderState.props"
    ));
    this.opts = opts;
    this.item = item;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionHeaderState(props, AccordionItemContext.get());
  }
  get props() {
    return get(__privateGet(this, _props5));
  }
  set props(value) {
    set(__privateGet(this, _props5), value);
  }
};
_props5 = new WeakMap();
var AccordionHeaderState = _AccordionHeaderState;

// node_modules/bits-ui/dist/internal/noop.js
function noop3() {
}

// node_modules/bits-ui/dist/internal/create-id.js
function createId(prefixOrUid, uid) {
  if (uid === void 0)
    return `bits-${prefixOrUid}`;
  return `bits-${prefixOrUid}-${uid}`;
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte
Accordion[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Accordion[FILENAME], [[66, 1]]);
function Accordion($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "vertical"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "type",
      "value",
      "ref",
      "id",
      "onValueChange",
      "loop",
      "orientation"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = AccordionRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion = hmr(Accordion, () => Accordion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion[HMR].source;
    set(Accordion[HMR].source, module.default[HMR].original);
  });
}
var accordion_default = Accordion;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte
Accordion_item[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
var root_22 = add_locations(from_html(`<div><!></div>`), Accordion_item[FILENAME], [[36, 1]]);
function Accordion_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_item);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "value",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const itemState = AccordionItemState.create({
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_item = hmr(Accordion_item, () => Accordion_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_item[HMR].source;
    set(Accordion_item[HMR].source, module.default[HMR].original);
  });
}
var accordion_item_default = Accordion_item;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte
Accordion_header[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
var root_23 = add_locations(from_html(`<div><!></div>`), Accordion_header[FILENAME], [[33, 1]]);
function Accordion_header($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_header);
  let id = prop($$props, "id", 19, () => createId(uid)), level = prop($$props, "level", 3, 2), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "level",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const headerState = AccordionHeaderState.create({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_23();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_header = hmr(Accordion_header, () => Accordion_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_header[HMR].source;
    set(Accordion_header[HMR].source, module.default[HMR].original);
  });
}
var accordion_header_default = Accordion_header;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte
Accordion_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
var root_24 = add_locations(from_html(`<button><!></button>`), Accordion_trigger[FILENAME], [[33, 1]]);
function Accordion_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_trigger);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const triggerState = AccordionTriggerState.create({
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_24();
      attribute_effect(button, () => ({ type: "button", ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_trigger = hmr(Accordion_trigger, () => Accordion_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_trigger[HMR].source;
    set(Accordion_trigger[HMR].source, module.default[HMR].original);
  });
}
var accordion_trigger_default = Accordion_trigger;

// node_modules/bits-ui/dist/internal/state-machine.js
var _machine, _StateMachine_instances, reducer_fn;
var StateMachine = class {
  constructor(initialState, machine) {
    __privateAdd(this, _StateMachine_instances);
    __publicField(this, "state");
    __privateAdd(this, _machine);
    this.state = box(initialState);
    __privateSet(this, _machine, machine);
    this.dispatch = this.dispatch.bind(this);
  }
  dispatch(event) {
    this.state.current = __privateMethod(this, _StateMachine_instances, reducer_fn).call(this, event);
  }
};
_machine = new WeakMap();
_StateMachine_instances = new WeakSet();
reducer_fn = function(event) {
  const nextState = __privateGet(this, _machine)[this.state.current][event];
  return nextState ?? this.state.current;
};

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence.svelte.js
var presenceMachine = {
  mounted: {
    UNMOUNT: "unmounted",
    ANIMATION_OUT: "unmountSuspended"
  },
  unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
  unmounted: { MOUNT: "mounted" }
};
var _prevAnimationNameState, _styles, _isPresent;
var Presence = class {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _prevAnimationNameState, tag(state("none"), "Presence.prevAnimationNameState"));
    __privateAdd(this, _styles, tag(state(proxy({})), "Presence.styles"));
    __publicField(this, "initialStatus");
    __publicField(this, "previousPresent");
    __publicField(this, "machine");
    __publicField(this, "present");
    __privateAdd(this, _isPresent, tag(
      user_derived(() => {
        return ["mounted", "unmountSuspended"].includes(this.machine.state.current);
      }),
      "Presence.isPresent"
    ));
    this.opts = opts;
    this.present = this.opts.open;
    this.initialStatus = opts.open.current ? "mounted" : "unmounted";
    this.previousPresent = new Previous(() => this.present.current);
    this.machine = new StateMachine(this.initialStatus, presenceMachine);
    this.handleAnimationEnd = this.handleAnimationEnd.bind(this);
    this.handleAnimationStart = this.handleAnimationStart.bind(this);
    watchPresenceChange(this);
    watchStatusChange(this);
    watchRefChange(this);
  }
  get prevAnimationNameState() {
    return get(__privateGet(this, _prevAnimationNameState));
  }
  set prevAnimationNameState(value) {
    set(__privateGet(this, _prevAnimationNameState), value, true);
  }
  get styles() {
    return get(__privateGet(this, _styles));
  }
  set styles(value) {
    set(__privateGet(this, _styles), value, true);
  }
  /**
   * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
   * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
   * make sure we only trigger ANIMATION_END for the currently active animation.
   */
  handleAnimationEnd(event) {
    if (!this.opts.ref.current) return;
    const currAnimationName = getAnimationName(this.opts.ref.current);
    const isCurrentAnimation = currAnimationName.includes(event.animationName) || strict_equals(currAnimationName, "none");
    if (strict_equals(event.target, this.opts.ref.current) && isCurrentAnimation) {
      this.machine.dispatch("ANIMATION_END");
    }
  }
  handleAnimationStart(event) {
    if (!this.opts.ref.current) return;
    if (strict_equals(event.target, this.opts.ref.current)) {
      this.prevAnimationNameState = getAnimationName(this.opts.ref.current);
    }
  }
  get isPresent() {
    return get(__privateGet(this, _isPresent));
  }
  set isPresent(value) {
    set(__privateGet(this, _isPresent), value);
  }
};
_prevAnimationNameState = new WeakMap();
_styles = new WeakMap();
_isPresent = new WeakMap();
function watchPresenceChange(state2) {
  watch(() => state2.present.current, () => {
    if (!state2.opts.ref.current) return;
    const hasPresentChanged = strict_equals(state2.present.current, state2.previousPresent.current, false);
    if (!hasPresentChanged) return;
    const prevAnimationName = state2.prevAnimationNameState;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    if (state2.present.current) {
      state2.machine.dispatch("MOUNT");
    } else if (strict_equals(currAnimationName, "none") || strict_equals(state2.styles.display, "none")) {
      state2.machine.dispatch("UNMOUNT");
    } else {
      const isAnimating = strict_equals(prevAnimationName, currAnimationName, false);
      if (state2.previousPresent.current && isAnimating) {
        state2.machine.dispatch("ANIMATION_OUT");
      } else {
        state2.machine.dispatch("UNMOUNT");
      }
    }
  });
}
function watchStatusChange(state2) {
  watch(() => state2.machine.state.current, () => {
    if (!state2.opts.ref.current) return;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    state2.prevAnimationNameState = strict_equals(state2.machine.state.current, "mounted") ? currAnimationName : "none";
  });
}
function watchRefChange(state2) {
  watch(() => state2.opts.ref.current, () => {
    if (!state2.opts.ref.current) return;
    state2.styles = getComputedStyle(state2.opts.ref.current);
    return executeCallbacks(on(state2.opts.ref.current, "animationstart", state2.handleAnimationStart), on(state2.opts.ref.current, "animationcancel", state2.handleAnimationEnd), on(state2.opts.ref.current, "animationend", state2.handleAnimationEnd));
  });
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte
Presence_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte";
function Presence_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Presence_layer);
  const presenceState = new Presence({
    open: box.with(() => $$props.open),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.presence ?? noop, () => ({ present: presenceState.isPresent }));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($$props.forceMount || $$props.open || presenceState.isPresent) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Presence_layer = hmr(Presence_layer, () => Presence_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Presence_layer[HMR].source;
    set(Presence_layer[HMR].source, module.default[HMR].original);
  });
}
var presence_layer_default = Presence_layer;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte
Accordion_content[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
var root_3 = add_locations(from_html(`<div><!></div>`), Accordion_content[FILENAME], [[40, 3]]);
function Accordion_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "id",
      "forceMount",
      "children"
    ],
    "restProps"
  );
  const contentState = AccordionContentState.create({
    forceMount: box.with(() => forceMount()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Accordion_content, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      const mergedProps = user_derived(() => mergeProps(restProps, contentState.props, {
        hidden: forceMount() ? void 0 : !present()
      }));
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            props: get(mergedProps),
            ...contentState.snippetProps
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_3();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      forceMount: true,
      get open() {
        return contentState.open;
      },
      get ref() {
        return contentState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_content = hmr(Accordion_content, () => Accordion_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_content[HMR].source;
    set(Accordion_content[HMR].source, module.default[HMR].original);
  });
}
var accordion_content_default = Accordion_content;

// node_modules/bits-ui/dist/bits/alert-dialog/exports.js
var exports_exports2 = {};
__export(exports_exports2, {
  Action: () => alert_dialog_action_default,
  Cancel: () => alert_dialog_cancel_default,
  Content: () => alert_dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => alert_dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/internal/animations-complete.js
var _opts2, _currentFrame, _isRunning, _AnimationsComplete_instances, cleanup_fn, executeCallback_fn;
var AnimationsComplete = class {
  constructor(opts) {
    __privateAdd(this, _AnimationsComplete_instances);
    __privateAdd(this, _opts2);
    __privateAdd(this, _currentFrame);
    __privateAdd(this, _isRunning, false);
    __privateSet(this, _opts2, opts);
    onDestroyEffect(() => __privateMethod(this, _AnimationsComplete_instances, cleanup_fn).call(this));
  }
  run(fn) {
    if (__privateGet(this, _isRunning))
      return;
    __privateMethod(this, _AnimationsComplete_instances, cleanup_fn).call(this);
    __privateSet(this, _isRunning, true);
    const node = __privateGet(this, _opts2).ref.current;
    if (!node) {
      __privateSet(this, _isRunning, false);
      return;
    }
    if (typeof node.getAnimations !== "function") {
      __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
      return;
    }
    __privateSet(this, _currentFrame, window.requestAnimationFrame(() => {
      const animations = node.getAnimations();
      if (animations.length === 0) {
        __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
        return;
      }
      Promise.allSettled(animations.map((animation) => animation.finished)).then(() => {
        __privateMethod(this, _AnimationsComplete_instances, executeCallback_fn).call(this, fn);
      });
    }));
  }
};
_opts2 = new WeakMap();
_currentFrame = new WeakMap();
_isRunning = new WeakMap();
_AnimationsComplete_instances = new WeakSet();
cleanup_fn = function() {
  if (__privateGet(this, _currentFrame)) {
    window.cancelAnimationFrame(__privateGet(this, _currentFrame));
    __privateSet(this, _currentFrame, void 0);
  }
  __privateSet(this, _isRunning, false);
};
executeCallback_fn = function(fn) {
  const execute = () => {
    fn();
    __privateSet(this, _isRunning, false);
  };
  if (__privateGet(this, _opts2).afterTick) {
    afterTick(execute);
  } else {
    execute();
  }
};

// node_modules/bits-ui/dist/internal/open-change-complete.js
var _opts3, _enabled, _afterAnimations;
var OpenChangeComplete = class {
  constructor(opts) {
    __privateAdd(this, _opts3);
    __privateAdd(this, _enabled);
    __privateAdd(this, _afterAnimations);
    __privateSet(this, _opts3, opts);
    __privateSet(this, _enabled, opts.enabled ?? true);
    __privateSet(this, _afterAnimations, new AnimationsComplete({
      ref: __privateGet(this, _opts3).ref,
      afterTick: __privateGet(this, _opts3).open
    }));
    watch([() => __privateGet(this, _opts3).open.current], ([open]) => {
      if (!__privateGet(this, _enabled))
        return;
      __privateGet(this, _afterAnimations).run(() => {
        if (open === __privateGet(this, _opts3).open.current) {
          __privateGet(this, _opts3).onComplete();
        }
      });
    });
  }
};
_opts3 = new WeakMap();
_enabled = new WeakMap();
_afterAnimations = new WeakMap();

// node_modules/bits-ui/dist/bits/dialog/dialog.svelte.js
var dialogAttrs = createBitsAttrs({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
});
var DialogRootContext = new Context("Dialog.Root | AlertDialog.Root");
var _triggerNode, _contentNode, _descriptionNode, _contentId, _titleId, _triggerId, _descriptionId, _cancelNode, _sharedProps;
var _DialogRootState = class _DialogRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _triggerNode, tag(state(null), "DialogRootState.triggerNode"));
    __privateAdd(this, _contentNode, tag(state(null), "DialogRootState.contentNode"));
    __privateAdd(this, _descriptionNode, tag(state(null), "DialogRootState.descriptionNode"));
    __privateAdd(this, _contentId, tag(state(void 0), "DialogRootState.contentId"));
    __privateAdd(this, _titleId, tag(state(void 0), "DialogRootState.titleId"));
    __privateAdd(this, _triggerId, tag(state(void 0), "DialogRootState.triggerId"));
    __privateAdd(this, _descriptionId, tag(state(void 0), "DialogRootState.descriptionId"));
    __privateAdd(this, _cancelNode, tag(state(null), "DialogRootState.cancelNode"));
    __publicField(this, "getBitsAttr", (part) => {
      return dialogAttrs.getAttr(part, this.opts.variant.current);
    });
    __privateAdd(this, _sharedProps, tag(
      user_derived(() => ({
        "data-state": getDataOpenClosed(this.opts.open.current)
      })),
      "DialogRootState.sharedProps"
    ));
    this.opts = opts;
    this.handleOpen = this.handleOpen.bind(this);
    this.handleClose = this.handleClose.bind(this);
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      enabled: true,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  static create(opts) {
    return DialogRootContext.set(new _DialogRootState(opts));
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId), value, true);
  }
  get titleId() {
    return get(__privateGet(this, _titleId));
  }
  set titleId(value) {
    set(__privateGet(this, _titleId), value, true);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId), value, true);
  }
  get descriptionId() {
    return get(__privateGet(this, _descriptionId));
  }
  set descriptionId(value) {
    set(__privateGet(this, _descriptionId), value, true);
  }
  get cancelNode() {
    return get(__privateGet(this, _cancelNode));
  }
  set cancelNode(value) {
    set(__privateGet(this, _cancelNode), value, true);
  }
  handleOpen() {
    if (this.opts.open.current) return;
    this.opts.open.current = true;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps));
  }
  set sharedProps(value) {
    set(__privateGet(this, _sharedProps), value);
  }
};
_triggerNode = new WeakMap();
_contentNode = new WeakMap();
_descriptionNode = new WeakMap();
_contentId = new WeakMap();
_titleId = new WeakMap();
_triggerId = new WeakMap();
_descriptionId = new WeakMap();
_cancelNode = new WeakMap();
_sharedProps = new WeakMap();
var DialogRootState = _DialogRootState;
var _props6;
var _DialogTriggerState = class _DialogTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props6, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-haspopup": "dialog",
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "aria-controls": this.root.contentId,
        [this.root.getBitsAttr("trigger")]: "",
        onkeydown: this.onkeydown,
        onclick: this.onclick,
        disabled: this.opts.disabled.current ? true : void 0,
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.triggerNode = v;
      this.root.triggerId = v == null ? void 0 : v.id;
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _DialogTriggerState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleOpen();
    }
  }
  get props() {
    return get(__privateGet(this, _props6));
  }
  set props(value) {
    set(__privateGet(this, _props6), value);
  }
};
_props6 = new WeakMap();
var DialogTriggerState = _DialogTriggerState;
var _props7;
var _DialogCloseState = class _DialogCloseState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props7, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr(this.opts.variant.current)]: "",
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        disabled: this.opts.disabled.current ? true : void 0,
        tabindex: 0,
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogCloseState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _DialogCloseState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  get props() {
    return get(__privateGet(this, _props7));
  }
  set props(value) {
    set(__privateGet(this, _props7), value);
  }
};
_props7 = new WeakMap();
var DialogCloseState = _DialogCloseState;
var _props8;
var _DialogActionState = class _DialogActionState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props8, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("action")]: "",
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogActionState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _DialogActionState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props8));
  }
  set props(value) {
    set(__privateGet(this, _props8), value);
  }
};
_props8 = new WeakMap();
var DialogActionState = _DialogActionState;
var _props9;
var _DialogTitleState = class _DialogTitleState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props9, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "heading",
        "aria-level": this.opts.level.current,
        [this.root.getBitsAttr("title")]: "",
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogTitleState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.root.titleId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.titleId = id;
    });
  }
  static create(opts) {
    return new _DialogTitleState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props9));
  }
  set props(value) {
    set(__privateGet(this, _props9), value);
  }
};
_props9 = new WeakMap();
var DialogTitleState = _DialogTitleState;
var _props10;
var _DialogDescriptionState = class _DialogDescriptionState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props10, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("description")]: "",
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogDescriptionState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.root.descriptionId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.descriptionNode = v;
    });
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.descriptionId = id;
    });
  }
  static create(opts) {
    return new _DialogDescriptionState(opts, DialogRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props10));
  }
  set props(value) {
    set(__privateGet(this, _props10), value);
  }
};
_props10 = new WeakMap();
var DialogDescriptionState = _DialogDescriptionState;
var _snippetProps2, _props11;
var _DialogContentState = class _DialogContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps2, tag(user_derived(() => ({ open: this.root.opts.open.current })), "DialogContentState.snippetProps"));
    __privateAdd(this, _props11, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: strict_equals(this.root.opts.variant.current, "alert-dialog") ? "alertdialog" : "dialog",
        "aria-modal": "true",
        "aria-describedby": this.root.descriptionId,
        "aria-labelledby": this.root.titleId,
        [this.root.getBitsAttr("content")]: "",
        style: {
          pointerEvents: "auto",
          outline: strict_equals(this.root.opts.variant.current, "alert-dialog") ? "none" : void 0
        },
        tabindex: strict_equals(this.root.opts.variant.current, "alert-dialog") ? -1 : void 0,
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogContentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.contentNode = v;
      this.root.contentId = v == null ? void 0 : v.id;
    });
  }
  static create(opts) {
    return new _DialogContentState(opts, DialogRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps2));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps2), value);
  }
  get props() {
    return get(__privateGet(this, _props11));
  }
  set props(value) {
    set(__privateGet(this, _props11), value);
  }
};
_snippetProps2 = new WeakMap();
_props11 = new WeakMap();
var DialogContentState = _DialogContentState;
var _snippetProps3, _props12;
var _DialogOverlayState = class _DialogOverlayState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps3, tag(user_derived(() => ({ open: this.root.opts.open.current })), "DialogOverlayState.snippetProps"));
    __privateAdd(this, _props12, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("overlay")]: "",
        style: { pointerEvents: "auto" },
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "DialogOverlayState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _DialogOverlayState(opts, DialogRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps3));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps3), value);
  }
  get props() {
    return get(__privateGet(this, _props12));
  }
  set props(value) {
    set(__privateGet(this, _props12), value);
  }
};
_snippetProps3 = new WeakMap();
_props12 = new WeakMap();
var DialogOverlayState = _DialogOverlayState;
var _props13;
var _AlertDialogCancelState = class _AlertDialogCancelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props13, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("cancel")]: "",
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        tabindex: 0,
        ...this.root.sharedProps,
        ...this.attachment
      })),
      "AlertDialogCancelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.cancelNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _AlertDialogCancelState(opts, DialogRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  get props() {
    return get(__privateGet(this, _props13));
  }
  set props(value) {
    set(__privateGet(this, _props13), value);
  }
};
_props13 = new WeakMap();
var AlertDialogCancelState = _AlertDialogCancelState;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte
Alert_dialog[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte";
function Alert_dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: box.with(() => "alert-dialog"),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog = hmr(Alert_dialog, () => Alert_dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog[HMR].source;
    set(Alert_dialog[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_default = Alert_dialog;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte
Dialog_title[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte";
var root_25 = add_locations(from_html(`<div><!></div>`), Dialog_title[FILENAME], [[33, 1]]);
function Dialog_title($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_title);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "level"
    ],
    "restProps"
  );
  const titleState = DialogTitleState.create({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, titleState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_25();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_title = hmr(Dialog_title, () => Dialog_title[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_title[HMR].source;
    set(Dialog_title[HMR].source, module.default[HMR].original);
  });
}
var dialog_title_default = Dialog_title;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte
Alert_dialog_action[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte";
var root_26 = add_locations(from_html(`<button><!></button>`), Alert_dialog_action[FILENAME], [[31, 1]]);
function Alert_dialog_action($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_action);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const actionState = DialogActionState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, actionState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_26();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_action = hmr(Alert_dialog_action, () => Alert_dialog_action[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_action[HMR].source;
    set(Alert_dialog_action[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_action_default = Alert_dialog_action;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte
Alert_dialog_cancel[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte";
var root_27 = add_locations(from_html(`<button><!></button>`), Alert_dialog_cancel[FILENAME], [[33, 1]]);
function Alert_dialog_cancel($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_cancel);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const cancelState = AlertDialogCancelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cancelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_27();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_cancel = hmr(Alert_dialog_cancel, () => Alert_dialog_cancel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_cancel[HMR].source;
    set(Alert_dialog_cancel[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_cancel_default = Alert_dialog_cancel;

// node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte
Portal_consumer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte";
function Portal_consumer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal_consumer);
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => $$props.children, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    snippet(node_1, () => $$props.children ?? noop);
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal_consumer = hmr(Portal_consumer, () => Portal_consumer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal_consumer[HMR].source;
    set(Portal_consumer[HMR].source, module.default[HMR].original);
  });
}
var portal_consumer_default = Portal_consumer;

// node_modules/bits-ui/dist/internal/is.js
var isBrowser = typeof document !== "undefined";
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isBrowser && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function isHTMLElement2(element2) {
  return element2 instanceof HTMLElement;
}
function isElement2(element2) {
  return element2 instanceof Element;
}
function isElementOrSVGElement(element2) {
  return element2 instanceof Element || element2 instanceof SVGElement;
}
function isNumberString(value) {
  return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));
}
function isNull(value) {
  return value === null;
}
function isTouch(e) {
  return e.pointerType === "touch";
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}
function isNotNull(value) {
  return value !== null;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}

// node_modules/bits-ui/dist/bits/utilities/config/bits-config.js
var BitsConfigContext = new Context("BitsConfig");
function getBitsConfig() {
  const fallback = new BitsConfigState(null, {});
  return BitsConfigContext.getOr(fallback).opts;
}
function useBitsConfig(opts) {
  return BitsConfigContext.set(new BitsConfigState(BitsConfigContext.getOr(null), opts));
}
var BitsConfigState = class {
  constructor(parent, opts) {
    __publicField(this, "opts");
    const resolveConfigOption = createConfigResolver(parent, opts);
    this.opts = {
      defaultPortalTo: resolveConfigOption((config) => config.defaultPortalTo),
      defaultLocale: resolveConfigOption((config) => config.defaultLocale)
    };
  }
};
function createConfigResolver(parent, currentOpts) {
  return (getter) => {
    const configOption = box.with(() => {
      var _a, _b;
      const value = (_a = getter(currentOpts)) == null ? void 0 : _a.current;
      if (value !== void 0)
        return value;
      if (parent === null)
        return void 0;
      return (_b = getter(parent.opts)) == null ? void 0 : _b.current;
    });
    return configOption;
  };
}

// node_modules/bits-ui/dist/bits/utilities/config/prop-resolvers.js
function createPropResolver(configOption, fallback) {
  return (getProp) => {
    const config = getBitsConfig();
    return box.with(() => {
      const propValue = getProp();
      if (propValue !== void 0)
        return propValue;
      const option = configOption(config).current;
      if (option !== void 0)
        return option;
      return fallback;
    });
  };
}
var resolveLocaleProp = createPropResolver((config) => config.defaultLocale, "en");
var resolvePortalToProp = createPropResolver((config) => config.defaultPortalTo, "body");

// node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte
Portal[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  const to = resolvePortalToProp(() => $$props.to);
  const context = getAllContexts();
  let target = tag(user_derived(getTarget), "target");
  function getTarget() {
    if (!isBrowser || $$props.disabled) return null;
    let localTarget = null;
    if (strict_equals(typeof to.current, "string")) {
      const target2 = document.querySelector(to.current);
      if (true_default && strict_equals(target2, null)) {
        throw new Error(`Target element "${to.current}" not found.`);
      }
      localTarget = target2;
    } else {
      localTarget = to.current;
    }
    if (true_default && !(localTarget instanceof Element)) {
      const type = strict_equals(localTarget, null) ? "null" : typeof localTarget;
      throw new TypeError(`Unknown portal target type: ${type}. Allowed types: string (query selector) or Element.`);
    }
    return localTarget;
  }
  let instance;
  function unmountInstance() {
    if (instance) {
      unmount(instance);
      instance = null;
    }
  }
  watch(
    [
      () => get(target),
      () => $$props.disabled
    ],
    ([target2, disabled]) => {
      if (!target2 || disabled) {
        unmountInstance();
        return;
      }
      instance = mount(portal_consumer_default, {
        target: target2,
        props: { children: $$props.children },
        context
      });
      return () => {
        unmountInstance();
      };
    }
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if ($$props.disabled) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var portal_default = Portal;

// node_modules/bits-ui/dist/internal/events.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}
var CustomEventDispatcher = class {
  constructor(eventName, options = { bubbles: true, cancelable: true }) {
    __publicField(this, "eventName");
    __publicField(this, "options");
    this.eventName = eventName;
    this.options = options;
  }
  createEvent(detail) {
    return new CustomEvent(this.eventName, {
      ...this.options,
      detail
    });
  }
  dispatch(element2, detail) {
    const event = this.createEvent(detail);
    element2.dispatchEvent(event);
    return event;
  }
  listen(element2, callback, options) {
    const handler = (event) => {
      callback(event);
    };
    return on(element2, this.eventName, handler, options);
  }
};

// node_modules/bits-ui/dist/internal/debounce.js
function debounce2(fn, wait = 500) {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn(...args);
    }, wait);
  };
  debounced.destroy = () => {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// node_modules/bits-ui/dist/internal/elements.js
function isOrContainsTarget2(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument2(el) {
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}

// node_modules/bits-ui/dist/internal/dom.js
function getFirstNonCommentChild(element2) {
  if (!element2)
    return null;
  for (const child2 of element2.childNodes) {
    if (child2.nodeType !== Node.COMMENT_NODE) {
      return child2;
    }
  }
  return null;
}
function isClickTrulyOutside(event, contentNode) {
  const { clientX, clientY } = event;
  const rect = contentNode.getBoundingClientRect();
  return clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/use-dismissable-layer.svelte.js
globalThis.bitsDismissableLayers ?? (globalThis.bitsDismissableLayers = /* @__PURE__ */ new Map());
var _interactOutsideProp, _behaviorType, _interceptedEvents, _isResponsibleLayer, _isFocusInsideDOMTree, _documentObj, _onFocusOutside, _unsubClickListener, _handleFocus, _DismissibleLayerState_instances, addEventListeners_fn, _handleDismiss, _handleInteractOutside, _markInterceptedEvent, _markNonInterceptedEvent, _markResponsibleLayer, _isTargetWithinLayer, _resetState, isAnyEventIntercepted_fn, _onfocuscapture, _onblurcapture;
var _DismissibleLayerState = class _DismissibleLayerState {
  constructor(opts) {
    __privateAdd(this, _DismissibleLayerState_instances);
    __publicField(this, "opts");
    __privateAdd(this, _interactOutsideProp);
    __privateAdd(this, _behaviorType);
    __privateAdd(this, _interceptedEvents, { pointerdown: false });
    __privateAdd(this, _isResponsibleLayer, false);
    __privateAdd(this, _isFocusInsideDOMTree, false);
    __privateAdd(this, _documentObj);
    __privateAdd(this, _onFocusOutside);
    __privateAdd(this, _unsubClickListener, noop3);
    __privateAdd(this, _handleFocus, (event) => {
      if (event.defaultPrevented) return;
      if (!this.opts.ref.current) return;
      afterTick(() => {
        var _a, _b;
        if (!this.opts.ref.current || __privateGet(this, _isTargetWithinLayer).call(this, event.target)) return;
        if (event.target && !__privateGet(this, _isFocusInsideDOMTree)) {
          (_b = (_a = __privateGet(this, _onFocusOutside)).current) == null ? void 0 : _b.call(_a, event);
        }
      });
    });
    __privateAdd(this, _handleDismiss, (e) => {
      let event = e;
      if (event.defaultPrevented) {
        event = createWrappedEvent(e);
      }
      __privateGet(this, _interactOutsideProp).current(e);
    });
    __privateAdd(this, _handleInteractOutside, debounce2(
      (e) => {
        if (!this.opts.ref.current) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        const isEventValid = this.opts.isValidEvent.current(e, this.opts.ref.current) || isValidEvent(e, this.opts.ref.current);
        if (!__privateGet(this, _isResponsibleLayer) || __privateMethod(this, _DismissibleLayerState_instances, isAnyEventIntercepted_fn).call(this) || !isEventValid) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        let event = e;
        if (event.defaultPrevented) {
          event = createWrappedEvent(event);
        }
        if (strict_equals(__privateGet(this, _behaviorType).current, "close", false) && strict_equals(__privateGet(this, _behaviorType).current, "defer-otherwise-close", false)) {
          __privateGet(this, _unsubClickListener).call(this);
          return;
        }
        if (strict_equals(e.pointerType, "touch")) {
          __privateGet(this, _unsubClickListener).call(this);
          __privateSet(this, _unsubClickListener, addEventListener(__privateGet(this, _documentObj), "click", __privateGet(this, _handleDismiss), { once: true }));
        } else {
          __privateGet(this, _interactOutsideProp).current(event);
        }
      },
      10
    ));
    __privateAdd(this, _markInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = true;
    });
    __privateAdd(this, _markNonInterceptedEvent, (e) => {
      __privateGet(this, _interceptedEvents)[e.type] = false;
    });
    __privateAdd(this, _markResponsibleLayer, () => {
      if (!this.opts.ref.current) return;
      __privateSet(this, _isResponsibleLayer, isResponsibleLayer(this.opts.ref.current));
    });
    __privateAdd(this, _isTargetWithinLayer, (target) => {
      if (!this.opts.ref.current) return false;
      return isOrContainsTarget2(this.opts.ref.current, target);
    });
    __privateAdd(this, _resetState, debounce2(
      () => {
        for (const eventType in __privateGet(this, _interceptedEvents)) {
          __privateGet(this, _interceptedEvents)[eventType] = false;
        }
        __privateSet(this, _isResponsibleLayer, false);
      },
      20
    ));
    __privateAdd(this, _onfocuscapture, () => {
      __privateSet(this, _isFocusInsideDOMTree, true);
    });
    __privateAdd(this, _onblurcapture, () => {
      __privateSet(this, _isFocusInsideDOMTree, false);
    });
    __publicField(this, "props", {
      onfocuscapture: __privateGet(this, _onfocuscapture),
      onblurcapture: __privateGet(this, _onblurcapture)
    });
    this.opts = opts;
    __privateSet(this, _behaviorType, opts.interactOutsideBehavior);
    __privateSet(this, _interactOutsideProp, opts.onInteractOutside);
    __privateSet(this, _onFocusOutside, opts.onFocusOutside);
    user_effect(() => {
      __privateSet(this, _documentObj, getOwnerDocument2(this.opts.ref.current));
    });
    let unsubEvents = noop3;
    const cleanup = () => {
      __privateGet(this, _resetState).call(this);
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      unsubEvents();
    };
    watch(
      [
        () => this.opts.enabled.current,
        () => this.opts.ref.current
      ],
      () => {
        if (!this.opts.enabled.current || !this.opts.ref.current) return;
        afterSleep(1, () => {
          if (!this.opts.ref.current) return;
          globalThis.bitsDismissableLayers.set(this, __privateGet(this, _behaviorType));
          unsubEvents();
          unsubEvents = __privateMethod(this, _DismissibleLayerState_instances, addEventListeners_fn).call(this);
        });
        return cleanup;
      }
    );
    onDestroyEffect(() => {
      __privateGet(this, _resetState).destroy();
      globalThis.bitsDismissableLayers.delete(this);
      __privateGet(this, _handleInteractOutside).destroy();
      __privateGet(this, _unsubClickListener).call(this);
      unsubEvents();
    });
  }
  static create(opts) {
    return new _DismissibleLayerState(opts);
  }
};
_interactOutsideProp = new WeakMap();
_behaviorType = new WeakMap();
_interceptedEvents = new WeakMap();
_isResponsibleLayer = new WeakMap();
_isFocusInsideDOMTree = new WeakMap();
_documentObj = new WeakMap();
_onFocusOutside = new WeakMap();
_unsubClickListener = new WeakMap();
_handleFocus = new WeakMap();
_DismissibleLayerState_instances = new WeakSet();
addEventListeners_fn = function() {
  return executeCallbacks(
    /**
    * CAPTURE INTERACTION START
    * mark interaction-start event as intercepted.
    * mark responsible layer during interaction start
    * to avoid checking if is responsible layer during interaction end
    * when a new floating element may have been opened.
    */
    on(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markInterceptedEvent), __privateGet(this, _markResponsibleLayer)), { capture: true }),
    /**
    * BUBBLE INTERACTION START
    * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
    * to avoid prematurely checking if other events were intercepted.
    */
    on(__privateGet(this, _documentObj), "pointerdown", executeCallbacks(__privateGet(this, _markNonInterceptedEvent), __privateGet(this, _handleInteractOutside))),
    /**
    * HANDLE FOCUS OUTSIDE
    */
    on(__privateGet(this, _documentObj), "focusin", __privateGet(this, _handleFocus))
  );
};
_handleDismiss = new WeakMap();
_handleInteractOutside = new WeakMap();
_markInterceptedEvent = new WeakMap();
_markNonInterceptedEvent = new WeakMap();
_markResponsibleLayer = new WeakMap();
_isTargetWithinLayer = new WeakMap();
_resetState = new WeakMap();
isAnyEventIntercepted_fn = function() {
  const i = Object.values(__privateGet(this, _interceptedEvents)).some(Boolean);
  return i;
};
_onfocuscapture = new WeakMap();
_onblurcapture = new WeakMap();
var DismissibleLayerState = _DismissibleLayerState;
function getTopMostLayer(layersArr) {
  return layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
}
function isResponsibleLayer(node) {
  const layersArr = [...globalThis.bitsDismissableLayers];
  const topMostLayer = getTopMostLayer(layersArr);
  if (topMostLayer) return strict_equals(topMostLayer[0].opts.ref.current, node);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode.opts.ref.current, node);
}
function isValidEvent(e, node) {
  if ("button" in e && e.button > 0) return false;
  const target = e.target;
  if (!isElement2(target)) return false;
  const ownerDocument = getOwnerDocument2(target);
  const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget2(node, target) && isClickTrulyOutside(e, node);
  return isValid;
}
function createWrappedEvent(e) {
  const capturedCurrentTarget = e.currentTarget;
  const capturedTarget = e.target;
  let newEvent;
  if (e instanceof PointerEvent) {
    newEvent = new PointerEvent(e.type, e);
  } else {
    newEvent = new PointerEvent("pointerdown", e);
  }
  let isPrevented = false;
  const wrappedEvent = new Proxy(newEvent, {
    get: (target, prop2) => {
      if (strict_equals(prop2, "currentTarget")) {
        return capturedCurrentTarget;
      }
      if (strict_equals(prop2, "target")) {
        return capturedTarget;
      }
      if (strict_equals(prop2, "preventDefault")) {
        return () => {
          isPrevented = true;
          if (strict_equals(typeof target.preventDefault, "function")) {
            target.preventDefault();
          }
        };
      }
      if (strict_equals(prop2, "defaultPrevented")) {
        return isPrevented;
      }
      if (prop2 in target) {
        return target[prop2];
      }
      return e[prop2];
    }
  });
  return wrappedEvent;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte
Dismissible_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte";
function Dismissible_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dismissible_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false);
  const dismissibleLayerState = DismissibleLayerState.create({
    id: box.with(() => $$props.id),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    onInteractOutside: box.with(() => onInteractOutside()),
    enabled: box.with(() => $$props.enabled),
    onFocusOutside: box.with(() => onFocusOutside()),
    isValidEvent: box.with(() => isValidEvent2()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop, () => ({ props: dismissibleLayerState.props }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dismissible_layer = hmr(Dismissible_layer, () => Dismissible_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dismissible_layer[HMR].source;
    set(Dismissible_layer[HMR].source, module.default[HMR].original);
  });
}
var dismissible_layer_default = Dismissible_layer;

// node_modules/bits-ui/dist/bits/utilities/escape-layer/use-escape-layer.svelte.js
globalThis.bitsEscapeLayers ?? (globalThis.bitsEscapeLayers = /* @__PURE__ */ new Map());
var _addEventListener, _onkeydown;
var _EscapeLayerState = class _EscapeLayerState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __privateAdd(this, _addEventListener, () => {
      return on(this.domContext.getDocument(), "keydown", __privateGet(this, _onkeydown), { passive: false });
    });
    __privateAdd(this, _onkeydown, (e) => {
      if (strict_equals(e.key, kbd_constants_exports.ESCAPE, false) || !isResponsibleEscapeLayer(this)) return;
      const clonedEvent = new KeyboardEvent(e.type, e);
      e.preventDefault();
      const behaviorType = this.opts.escapeKeydownBehavior.current;
      if (strict_equals(behaviorType, "close", false) && strict_equals(behaviorType, "defer-otherwise-close", false)) return;
      this.opts.onEscapeKeydown.current(clonedEvent);
    });
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    let unsubEvents = noop3;
    watch(() => opts.enabled.current, (enabled) => {
      if (enabled) {
        globalThis.bitsEscapeLayers.set(this, opts.escapeKeydownBehavior);
        unsubEvents = __privateGet(this, _addEventListener).call(this);
      }
      return () => {
        unsubEvents();
        globalThis.bitsEscapeLayers.delete(this);
      };
    });
  }
  static create(opts) {
    return new _EscapeLayerState(opts);
  }
};
_addEventListener = new WeakMap();
_onkeydown = new WeakMap();
var EscapeLayerState = _EscapeLayerState;
function isResponsibleEscapeLayer(instance) {
  const layersArr = [...globalThis.bitsEscapeLayers];
  const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
  if (topMostLayer) return strict_equals(topMostLayer[0], instance);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode, instance);
}

// node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte
Escape_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte";
function Escape_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Escape_layer);
  let escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3);
  EscapeLayerState.create({
    escapeKeydownBehavior: box.with(() => escapeKeydownBehavior()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    enabled: box.with(() => $$props.enabled),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Escape_layer = hmr(Escape_layer, () => Escape_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Escape_layer[HMR].source;
    set(Escape_layer[HMR].source, module.default[HMR].original);
  });
}
var escape_layer_default = Escape_layer;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-manager.js
var _scopeStack, _focusHistory;
var _FocusScopeManager = class _FocusScopeManager {
  constructor() {
    __privateAdd(this, _scopeStack, box([]));
    __privateAdd(this, _focusHistory, /* @__PURE__ */ new WeakMap());
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _FocusScopeManager();
    }
    return this.instance;
  }
  register(scope) {
    const current = this.getActive();
    if (current && current !== scope) {
      current.pause();
    }
    __privateGet(this, _scopeStack).current = __privateGet(this, _scopeStack).current.filter((s) => s !== scope);
    __privateGet(this, _scopeStack).current.unshift(scope);
  }
  unregister(scope) {
    __privateGet(this, _scopeStack).current = __privateGet(this, _scopeStack).current.filter((s) => s !== scope);
    const next3 = this.getActive();
    if (next3) {
      next3.resume();
    }
  }
  getActive() {
    return __privateGet(this, _scopeStack).current[0];
  }
  setFocusMemory(scope, element2) {
    __privateGet(this, _focusHistory).set(scope, element2);
  }
  getFocusMemory(scope) {
    return __privateGet(this, _focusHistory).get(scope);
  }
  isActiveScope(scope) {
    return this.getActive() === scope;
  }
};
_scopeStack = new WeakMap();
_focusHistory = new WeakMap();
__publicField(_FocusScopeManager, "instance");
var FocusScopeManager = _FocusScopeManager;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte.js
var _paused, _container, _manager, _cleanupFns, _opts4, _FocusScope_instances, cleanup_fn2, handleOpenAutoFocus_fn, handleCloseAutoFocus_fn, setupEventListeners_fn, getTabbables_fn, getFirstTabbable_fn, getAllFocusables_fn;
var _FocusScope = class _FocusScope {
  constructor(opts) {
    __privateAdd(this, _FocusScope_instances);
    __privateAdd(this, _paused, false);
    __privateAdd(this, _container, null);
    __privateAdd(this, _manager, FocusScopeManager.getInstance());
    __privateAdd(this, _cleanupFns, []);
    __privateAdd(this, _opts4);
    __privateSet(this, _opts4, opts);
  }
  get paused() {
    return __privateGet(this, _paused);
  }
  pause() {
    __privateSet(this, _paused, true);
  }
  resume() {
    __privateSet(this, _paused, false);
  }
  mount(container) {
    if (__privateGet(this, _container)) {
      this.unmount();
    }
    __privateSet(this, _container, container);
    __privateGet(this, _manager).register(this);
    __privateMethod(this, _FocusScope_instances, setupEventListeners_fn).call(this);
    __privateMethod(this, _FocusScope_instances, handleOpenAutoFocus_fn).call(this);
  }
  unmount() {
    if (!__privateGet(this, _container)) return;
    __privateMethod(this, _FocusScope_instances, cleanup_fn2).call(this);
    __privateMethod(this, _FocusScope_instances, handleCloseAutoFocus_fn).call(this);
    __privateGet(this, _manager).unregister(this);
    __privateSet(this, _container, null);
  }
  static use(opts) {
    let scope = null;
    watch(
      [
        () => opts.ref.current,
        () => opts.enabled.current
      ],
      ([ref, enabled]) => {
        if (ref && enabled) {
          if (!scope) {
            scope = new _FocusScope(opts);
          }
          scope.mount(ref);
        } else if (scope) {
          scope.unmount();
          scope = null;
        }
      }
    );
    onDestroyEffect(() => {
      scope == null ? void 0 : scope.unmount();
    });
    return {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
};
_paused = new WeakMap();
_container = new WeakMap();
_manager = new WeakMap();
_cleanupFns = new WeakMap();
_opts4 = new WeakMap();
_FocusScope_instances = new WeakSet();
cleanup_fn2 = function() {
  for (const fn of __privateGet(this, _cleanupFns)) {
    fn();
  }
  __privateSet(this, _cleanupFns, []);
};
handleOpenAutoFocus_fn = function() {
  if (!__privateGet(this, _container)) return;
  const event = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: false, cancelable: true });
  __privateGet(this, _opts4).onOpenAutoFocus.current(event);
  if (!event.defaultPrevented) {
    requestAnimationFrame(() => {
      if (!__privateGet(this, _container)) return;
      const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
      if (firstTabbable) {
        firstTabbable.focus();
        __privateGet(this, _manager).setFocusMemory(this, firstTabbable);
      } else {
        __privateGet(this, _container).focus();
      }
    });
  }
};
handleCloseAutoFocus_fn = function() {
  const event = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: false, cancelable: true });
  __privateGet(this, _opts4).onCloseAutoFocus.current(event);
  if (!event.defaultPrevented) {
    const prevFocused = document.activeElement;
    if (prevFocused && strict_equals(prevFocused, document.body, false)) {
      prevFocused.focus();
    }
  }
};
setupEventListeners_fn = function() {
  if (!__privateGet(this, _container) || !__privateGet(this, _opts4).trap.current) return;
  const container = __privateGet(this, _container);
  const doc = container.ownerDocument;
  const handleFocus = (e) => {
    if (__privateGet(this, _paused) || !__privateGet(this, _manager).isActiveScope(this)) return;
    const target = e.target;
    if (!target) return;
    const isInside = container.contains(target);
    if (isInside) {
      __privateGet(this, _manager).setFocusMemory(this, target);
    } else {
      const lastFocused = __privateGet(this, _manager).getFocusMemory(this);
      if (lastFocused && container.contains(lastFocused) && isFocusable(lastFocused)) {
        e.preventDefault();
        lastFocused.focus();
      } else {
        const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
        const firstFocusable = __privateMethod(this, _FocusScope_instances, getAllFocusables_fn).call(this)[0];
        (firstTabbable || firstFocusable || container).focus();
      }
    }
  };
  const handleKeydown = (e) => {
    if (!__privateGet(this, _opts4).loop || __privateGet(this, _paused) || strict_equals(e.key, "Tab", false)) return;
    if (!__privateGet(this, _manager).isActiveScope(this)) return;
    const tabbables = __privateMethod(this, _FocusScope_instances, getTabbables_fn).call(this);
    if (tabbables.length < 2) return;
    const first = tabbables[0];
    const last = tabbables[tabbables.length - 1];
    if (!e.shiftKey && strict_equals(doc.activeElement, last)) {
      e.preventDefault();
      first.focus();
    } else if (e.shiftKey && strict_equals(doc.activeElement, first)) {
      e.preventDefault();
      last.focus();
    }
  };
  __privateGet(this, _cleanupFns).push(on(doc, "focusin", handleFocus, { capture: true }), on(container, "keydown", handleKeydown));
  const observer = new MutationObserver(() => {
    const lastFocused = __privateGet(this, _manager).getFocusMemory(this);
    if (lastFocused && !container.contains(lastFocused)) {
      const firstTabbable = __privateMethod(this, _FocusScope_instances, getFirstTabbable_fn).call(this);
      const firstFocusable = __privateMethod(this, _FocusScope_instances, getAllFocusables_fn).call(this)[0];
      const elementToFocus = firstTabbable || firstFocusable;
      if (elementToFocus) {
        elementToFocus.focus();
        __privateGet(this, _manager).setFocusMemory(this, elementToFocus);
      } else {
        container.focus();
      }
    }
  });
  observer.observe(container, { childList: true, subtree: true });
  __privateGet(this, _cleanupFns).push(() => observer.disconnect());
};
getTabbables_fn = function() {
  if (!__privateGet(this, _container)) return [];
  return tabbable(__privateGet(this, _container), { includeContainer: false, getShadowRoot: true });
};
getFirstTabbable_fn = function() {
  const tabbables = __privateMethod(this, _FocusScope_instances, getTabbables_fn).call(this);
  return tabbables[0] || null;
};
getAllFocusables_fn = function() {
  if (!__privateGet(this, _container)) return [];
  return focusable(__privateGet(this, _container), { includeContainer: false, getShadowRoot: true });
};
var FocusScope = _FocusScope;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte
Focus_scope[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte";
function Focus_scope($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Focus_scope);
  let enabled = prop($$props, "enabled", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), loop = prop($$props, "loop", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3);
  const focusScopeState = FocusScope.use({
    enabled: box.with(() => enabled()),
    trap: box.with(() => trapFocus()),
    loop: loop(),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.focusScope ?? noop, () => ({ props: focusScopeState.props }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Focus_scope = hmr(Focus_scope, () => Focus_scope[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Focus_scope[HMR].source;
    set(Focus_scope[HMR].source, module.default[HMR].original);
  });
}
var focus_scope_default = Focus_scope;

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/use-text-selection-layer.svelte.js
globalThis.bitsTextSelectionLayers ?? (globalThis.bitsTextSelectionLayers = /* @__PURE__ */ new Map());
var _unsubSelectionLock, _TextSelectionLayerState_instances, addEventListeners_fn2, _pointerdown, _resetSelectionLock;
var _TextSelectionLayerState = class _TextSelectionLayerState {
  constructor(opts) {
    __privateAdd(this, _TextSelectionLayerState_instances);
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __privateAdd(this, _unsubSelectionLock, noop3);
    __privateAdd(this, _pointerdown, (e) => {
      const node = this.opts.ref.current;
      const target = e.target;
      if (!isHTMLElement2(node) || !isHTMLElement2(target) || !this.opts.enabled.current) return;
      if (!isHighestLayer(this) || !contains(node, target)) return;
      this.opts.onPointerDown.current(e);
      if (e.defaultPrevented) return;
      __privateSet(this, _unsubSelectionLock, preventTextSelectionOverflow(node, this.domContext.getDocument().body));
    });
    __privateAdd(this, _resetSelectionLock, () => {
      __privateGet(this, _unsubSelectionLock).call(this);
      __privateSet(this, _unsubSelectionLock, noop3);
    });
    this.opts = opts;
    this.domContext = new DOMContext(opts.ref);
    let unsubEvents = noop3;
    watch(() => this.opts.enabled.current, (isEnabled) => {
      if (isEnabled) {
        globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled);
        unsubEvents();
        unsubEvents = __privateMethod(this, _TextSelectionLayerState_instances, addEventListeners_fn2).call(this);
      }
      return () => {
        unsubEvents();
        __privateGet(this, _resetSelectionLock).call(this);
        globalThis.bitsTextSelectionLayers.delete(this);
      };
    });
  }
  static create(opts) {
    return new _TextSelectionLayerState(opts);
  }
};
_unsubSelectionLock = new WeakMap();
_TextSelectionLayerState_instances = new WeakSet();
addEventListeners_fn2 = function() {
  return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", __privateGet(this, _pointerdown)), on(this.domContext.getDocument(), "pointerup", composeHandlers(__privateGet(this, _resetSelectionLock), this.opts.onPointerUp.current)));
};
_pointerdown = new WeakMap();
_resetSelectionLock = new WeakMap();
var TextSelectionLayerState = _TextSelectionLayerState;
var getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;
function preventTextSelectionOverflow(node, body) {
  const originalBodyUserSelect = getUserSelect(body);
  const originalNodeUserSelect = getUserSelect(node);
  setUserSelect(body, "none");
  setUserSelect(node, "text");
  return () => {
    setUserSelect(body, originalBodyUserSelect);
    setUserSelect(node, originalNodeUserSelect);
  };
}
function setUserSelect(node, value) {
  node.style.userSelect = value;
  node.style.webkitUserSelect = value;
}
function isHighestLayer(instance) {
  const layersArr = [...globalThis.bitsTextSelectionLayers];
  if (!layersArr.length) return false;
  const highestLayer = layersArr.at(-1);
  if (!highestLayer) return false;
  return strict_equals(highestLayer[0], instance);
}

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte
Text_selection_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte";
function Text_selection_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text_selection_layer);
  let preventOverflowTextSelection = prop($$props, "preventOverflowTextSelection", 3, true), onPointerDown = prop($$props, "onPointerDown", 3, noop3), onPointerUp = prop($$props, "onPointerUp", 3, noop3);
  TextSelectionLayerState.create({
    id: box.with(() => $$props.id),
    onPointerDown: box.with(() => onPointerDown()),
    onPointerUp: box.with(() => onPointerUp()),
    enabled: box.with(() => $$props.enabled && preventOverflowTextSelection()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text_selection_layer = hmr(Text_selection_layer, () => Text_selection_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text_selection_layer[HMR].source;
    set(Text_selection_layer[HMR].source, module.default[HMR].original);
  });
}
var text_selection_layer_default = Text_selection_layer;

// node_modules/bits-ui/dist/internal/use-id.js
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 });
function useId(prefix = "bits") {
  globalThis.bitsIdCounter.current++;
  return `${prefix}-${globalThis.bitsIdCounter.current}`;
}

// node_modules/bits-ui/dist/internal/shared-state.svelte.js
var _factory, _subscribers, _state, _scope, _SharedState_instances, dispose_fn;
var SharedState = class {
  constructor(factory) {
    __privateAdd(this, _SharedState_instances);
    __privateAdd(this, _factory);
    __privateAdd(this, _subscribers, 0);
    __privateAdd(this, _state, tag(state(), "SharedState.#state"));
    __privateAdd(this, _scope);
    __privateSet(this, _factory, factory);
  }
  get(...args) {
    __privateSet(this, _subscribers, __privateGet(this, _subscribers) + 1);
    if (strict_equals(get(__privateGet(this, _state)), void 0)) {
      __privateSet(this, _scope, effect_root(() => {
        set(__privateGet(this, _state), __privateGet(this, _factory).call(this, ...args), true);
      }));
    }
    user_effect(() => {
      return () => {
        __privateMethod(this, _SharedState_instances, dispose_fn).call(this);
      };
    });
    return get(__privateGet(this, _state));
  }
};
_factory = new WeakMap();
_subscribers = new WeakMap();
_state = new WeakMap();
_scope = new WeakMap();
_SharedState_instances = new WeakSet();
dispose_fn = function() {
  __privateSet(this, _subscribers, __privateGet(this, _subscribers) - 1);
  if (__privateGet(this, _scope) && __privateGet(this, _subscribers) <= 0) {
    __privateGet(this, _scope).call(this);
    set(__privateGet(this, _state), void 0);
    __privateSet(this, _scope, void 0);
  }
};

// node_modules/bits-ui/dist/internal/body-scroll-lock.svelte.js
var bodyLockStackCount = new SharedState(() => {
  const map = new SvelteMap();
  const locked = tag(
    user_derived(() => {
      for (const value of map.values()) {
        if (value) return true;
      }
      return false;
    }),
    "locked"
  );
  let initialBodyStyle = tag(state(null), "initialBodyStyle");
  let stopTouchMoveListener = null;
  function resetBodyStyle() {
    if (!isBrowser) return;
    document.body.setAttribute("style", get(initialBodyStyle) ?? "");
    document.body.style.removeProperty("--scrollbar-width");
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
  }
  watch(() => get(locked), () => {
    if (!get(locked)) return;
    set(initialBodyStyle, document.body.getAttribute("style"), true);
    const bodyStyle = getComputedStyle(document.body);
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const paddingRight = Number.parseInt(bodyStyle.paddingRight ?? "0", 10);
    const config = {
      padding: paddingRight + verticalScrollbarWidth,
      margin: Number.parseInt(bodyStyle.marginRight ?? "0", 10)
    };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = `${config.padding}px`;
      document.body.style.marginRight = `${config.margin}px`;
      document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = addEventListener(
        document,
        "touchmove",
        (e) => {
          if (strict_equals(e.target, document.documentElement, false)) return;
          if (e.touches.length > 1) return;
          e.preventDefault();
        },
        { passive: false }
      );
    }
    afterTick(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  });
  onDestroyEffect(() => {
    return () => {
      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();
    };
  });
  return {
    get map() {
      return map;
    },
    resetBodyStyle
  };
});
var _id, _initialState, _restoreScrollDelay, _countState;
var BodyScrollLock = class {
  constructor(initialState, restoreScrollDelay = () => null) {
    __privateAdd(this, _id, useId());
    __privateAdd(this, _initialState);
    __privateAdd(this, _restoreScrollDelay, () => null);
    __privateAdd(this, _countState);
    __publicField(this, "locked");
    __privateSet(this, _initialState, initialState);
    __privateSet(this, _restoreScrollDelay, restoreScrollDelay);
    __privateSet(this, _countState, bodyLockStackCount.get());
    if (!__privateGet(this, _countState)) return;
    __privateGet(this, _countState).map.set(__privateGet(this, _id), __privateGet(this, _initialState) ?? false);
    this.locked = box.with(() => __privateGet(this, _countState).map.get(__privateGet(this, _id)) ?? false, (v) => __privateGet(this, _countState).map.set(__privateGet(this, _id), v));
    onDestroyEffect(() => {
      __privateGet(this, _countState).map.delete(__privateGet(this, _id));
      if (isAnyLocked(__privateGet(this, _countState).map)) return;
      const restoreScrollDelay2 = __privateGet(this, _restoreScrollDelay).call(this);
      if (strict_equals(restoreScrollDelay2, null)) {
        requestAnimationFrame(() => __privateGet(this, _countState).resetBodyStyle());
      } else {
        afterSleep(restoreScrollDelay2, () => __privateGet(this, _countState).resetBodyStyle());
      }
    });
  }
};
_id = new WeakMap();
_initialState = new WeakMap();
_restoreScrollDelay = new WeakMap();
_countState = new WeakMap();
function isAnyLocked(map) {
  for (const [_, value] of map) {
    if (value) return true;
  }
  return false;
}

// node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte
Scroll_lock[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte";
function Scroll_lock($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_lock);
  let preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null);
  if (preventScroll()) {
    new BodyScrollLock(preventScroll(), () => restoreScrollDelay());
  }
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_lock = hmr(Scroll_lock, () => Scroll_lock[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_lock[HMR].source;
    set(Scroll_lock[HMR].source, module.default[HMR].original);
  });
}
var scroll_lock_default = Scroll_lock;

// node_modules/bits-ui/dist/internal/should-enable-focus-trap.js
function shouldEnableFocusTrap({ forceMount, present, open }) {
  if (forceMount)
    return open;
  return present && open;
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte
Alert_dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte";
var root_6 = add_locations(from_html(`<!> <!>`, 1), Alert_dialog_content[FILENAME], []);
var root_8 = add_locations(from_html(`<!> <div><!></div>`, 1), Alert_dialog_content[FILENAME], [[109, 8]]);
function Alert_dialog_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "ignore"), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), trapFocus = prop($$props, "trapFocus", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "interactOutsideBehavior",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onOpenAutoFocus",
      "onInteractOutside",
      "preventScroll",
      "trapFocus",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = DialogContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => contentState.root.opts.open.current || forceMount());
  {
    const presence = wrap_snippet(Alert_dialog_content, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression_1 = user_derived(() => shouldEnableFocusTrap({
        forceMount: forceMount(),
        present: contentState.root.opts.open.current,
        open: contentState.root.opts.open.current
      }));
      {
        const focusScope = wrap_snippet(Alert_dialog_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg0 == null ? void 0 : $$arg0().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          escape_layer_default(node_2, spread_props(() => get(mergedProps), {
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get ref() {
              return contentState.opts.ref;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: wrap_snippet(Alert_dialog_content, ($$anchor4, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                get ref() {
                  return contentState.opts.ref;
                },
                get enabled() {
                  return contentState.root.opts.open.current;
                },
                get interactOutsideBehavior() {
                  return interactOutsideBehavior();
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: wrap_snippet(Alert_dialog_content, ($$anchor5, $$slotProps2) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    children: wrap_snippet(Alert_dialog_content, ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      {
                        var consequent_1 = ($$anchor7) => {
                          var fragment_6 = root_6();
                          var node_6 = first_child(fragment_6);
                          {
                            var consequent = ($$anchor8) => {
                              var fragment_7 = comment();
                              var node_7 = first_child(fragment_7);
                              scroll_lock_default(node_7, {
                                get preventScroll() {
                                  return preventScroll();
                                },
                                get restoreScrollDelay() {
                                  return restoreScrollDelay();
                                }
                              });
                              append($$anchor8, fragment_7);
                            };
                            if_block(node_6, ($$render) => {
                              if (contentState.root.opts.open.current) $$render(consequent);
                            });
                          }
                          var node_8 = sibling(node_6, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_8, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        };
                        var alternate = ($$anchor7) => {
                          var fragment_8 = root_8();
                          var node_9 = first_child(fragment_8);
                          scroll_lock_default(node_9, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_9, 2);
                          attribute_effect(div, ($0) => ({ ...$0 }), [
                            () => mergeProps(get(mergedProps), focusScopeProps())
                          ]);
                          var node_10 = child(div);
                          snippet(node_10, () => $$props.children ?? noop);
                          reset(div);
                          append($$anchor7, fragment_8);
                        };
                        if_block(node_5, ($$render) => {
                          if ($$props.child) $$render(consequent_1);
                          else $$render(alternate, false);
                        });
                      }
                      append($$anchor6, fragment_5);
                    }),
                    $$slots: { default: true }
                  }));
                  append($$anchor5, fragment_4);
                }),
                $$slots: { default: true }
              }));
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          }));
          append($$anchor3, fragment_2);
        });
        focus_scope_default(node_1, {
          get ref() {
            return contentState.opts.ref;
          },
          loop: true,
          get trapFocus() {
            return trapFocus();
          },
          get enabled() {
            return get(expression_1);
          },
          onCloseAutoFocus: (e) => {
            onCloseAutoFocus()(e);
            if (e.defaultPrevented) return;
            afterSleep(0, () => {
              var _a;
              return (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
            });
          },
          onOpenAutoFocus: (e) => {
            onOpenAutoFocus()(e);
            if (e.defaultPrevented) return;
            e.preventDefault();
            afterSleep(0, () => {
              var _a;
              return (_a = contentState.opts.ref.current) == null ? void 0 : _a.focus();
            });
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get forceMount() {
        return forceMount();
      },
      get open() {
        return get(expression);
      },
      get ref() {
        return contentState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_content = hmr(Alert_dialog_content, () => Alert_dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_content[HMR].source;
    set(Alert_dialog_content[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_content_default = Alert_dialog_content;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte
Dialog_overlay[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte";
var root_32 = add_locations(from_html(`<div><!></div>`), Dialog_overlay[FILENAME], [[35, 3]]);
function Dialog_overlay($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_overlay);
  let id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "forceMount",
      "child",
      "children",
      "ref"
    ],
    "restProps"
  );
  const overlayState = DialogOverlayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, overlayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => overlayState.root.opts.open.current || forceMount());
  {
    const presence = wrap_snippet(Dialog_overlay, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            props: mergeProps(get(mergedProps)),
            ...overlayState.snippetProps
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_32();
          attribute_effect(div, ($0) => ({ ...$0 }), [() => mergeProps(get(mergedProps))]);
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop, () => overlayState.snippetProps);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return get(expression);
      },
      get ref() {
        return overlayState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_overlay = hmr(Dialog_overlay, () => Dialog_overlay[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_overlay[HMR].source;
    set(Dialog_overlay[HMR].source, module.default[HMR].original);
  });
}
var dialog_overlay_default = Dialog_overlay;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte
Dialog_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte";
var root_28 = add_locations(from_html(`<button><!></button>`), Dialog_trigger[FILENAME], [[33, 1]]);
function Dialog_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = DialogTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_28();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_trigger = hmr(Dialog_trigger, () => Dialog_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_trigger[HMR].source;
    set(Dialog_trigger[HMR].source, module.default[HMR].original);
  });
}
var dialog_trigger_default = Dialog_trigger;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte
Dialog_description[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte";
var root_29 = add_locations(from_html(`<div><!></div>`), Dialog_description[FILENAME], [[31, 1]]);
function Dialog_description($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_description);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const descriptionState = DialogDescriptionState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, descriptionState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_29();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_description = hmr(Dialog_description, () => Dialog_description[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_description[HMR].source;
    set(Dialog_description[HMR].source, module.default[HMR].original);
  });
}
var dialog_description_default = Dialog_description;

// node_modules/bits-ui/dist/bits/aspect-ratio/exports.js
var exports_exports3 = {};
__export(exports_exports3, {
  Root: () => aspect_ratio_default
});

// node_modules/bits-ui/dist/bits/aspect-ratio/aspect-ratio.svelte.js
var aspectRatioAttrs = createBitsAttrs({
  component: "aspect-ratio",
  parts: ["root"]
});
var _props14;
var _AspectRatioRootState = class _AspectRatioRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props14, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: {
          position: "absolute",
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        [aspectRatioAttrs.root]: "",
        ...this.attachment
      })),
      "AspectRatioRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _AspectRatioRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props14));
  }
  set props(value) {
    set(__privateGet(this, _props14), value);
  }
};
_props14 = new WeakMap();
var AspectRatioRootState = _AspectRatioRootState;

// node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte
Aspect_ratio[FILENAME] = "node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte";
var root_210 = add_locations(from_html(`<div><!></div>`), Aspect_ratio[FILENAME], [[34, 2]]);
var root = add_locations(from_html(`<div><!></div>`), Aspect_ratio[FILENAME], [[30, 0]]);
function Aspect_ratio($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Aspect_ratio);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), ratio = prop($$props, "ratio", 3, 1), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "ratio",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = AspectRatioRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ratio: box.with(() => ratio())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var div = root();
  let styles;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_210();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(div);
  template_effect(() => styles = set_style(div, "", styles, {
    position: "relative",
    width: "100%",
    "padding-bottom": `${ratio() ? 100 / ratio() : 0}%`
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Aspect_ratio = hmr(Aspect_ratio, () => Aspect_ratio[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Aspect_ratio[HMR].source;
    set(Aspect_ratio[HMR].source, module.default[HMR].original);
  });
}
var aspect_ratio_default = Aspect_ratio;

// node_modules/bits-ui/dist/bits/avatar/exports.js
var exports_exports4 = {};
__export(exports_exports4, {
  Fallback: () => avatar_fallback_default,
  Image: () => avatar_image_default,
  Root: () => avatar_default
});

// node_modules/bits-ui/dist/bits/avatar/avatar.svelte.js
var avatarAttrs = createBitsAttrs({
  component: "avatar",
  parts: ["root", "image", "fallback"]
});
var AvatarRootContext = new Context("Avatar.Root");
var _props15;
var _AvatarRootState = class _AvatarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _props15, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [avatarAttrs.root]: "",
        "data-status": this.opts.loadingStatus.current,
        ...this.attachment
      })),
      "AvatarRootState.props"
    ));
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    this.loadImage = this.loadImage.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return AvatarRootContext.set(new _AvatarRootState(opts));
  }
  loadImage(src, crossorigin, referrerPolicy) {
    if (strict_equals(this.opts.loadingStatus.current, "loaded")) return;
    let imageTimerId;
    const image = new Image();
    image.src = src;
    if (strict_equals(crossorigin, void 0, false)) image.crossOrigin = crossorigin;
    if (referrerPolicy) image.referrerPolicy = referrerPolicy;
    this.opts.loadingStatus.current = "loading";
    image.onload = () => {
      imageTimerId = this.domContext.setTimeout(
        () => {
          this.opts.loadingStatus.current = "loaded";
        },
        this.opts.delayMs.current
      );
    };
    image.onerror = () => {
      this.opts.loadingStatus.current = "error";
    };
    return () => {
      if (!imageTimerId) return;
      this.domContext.clearTimeout(imageTimerId);
    };
  }
  get props() {
    return get(__privateGet(this, _props15));
  }
  set props(value) {
    set(__privateGet(this, _props15), value);
  }
};
_props15 = new WeakMap();
var AvatarRootState = _AvatarRootState;
var _props16;
var _AvatarImageState = class _AvatarImageState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props16, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: {
          display: strict_equals(this.root.opts.loadingStatus.current, "loaded") ? "block" : "none"
        },
        "data-status": this.root.opts.loadingStatus.current,
        [avatarAttrs.image]: "",
        src: this.opts.src.current,
        crossorigin: this.opts.crossOrigin.current,
        referrerpolicy: this.opts.referrerPolicy.current,
        ...this.attachment
      })),
      "AvatarImageState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(
      [
        () => this.opts.src.current,
        () => this.opts.crossOrigin.current
      ],
      ([src, crossOrigin]) => {
        if (!src) {
          this.root.opts.loadingStatus.current = "error";
          return;
        }
        this.root.loadImage(src, crossOrigin, this.opts.referrerPolicy.current);
      }
    );
  }
  static create(opts) {
    return new _AvatarImageState(opts, AvatarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props16));
  }
  set props(value) {
    set(__privateGet(this, _props16), value);
  }
};
_props16 = new WeakMap();
var AvatarImageState = _AvatarImageState;
var _style, _props17;
var _AvatarFallbackState = class _AvatarFallbackState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _style, tag(user_derived(() => strict_equals(this.root.opts.loadingStatus.current, "loaded") ? { display: "none" } : void 0), "AvatarFallbackState.style"));
    __privateAdd(this, _props17, tag(
      user_derived(() => ({
        style: this.style,
        "data-status": this.root.opts.loadingStatus.current,
        [avatarAttrs.fallback]: "",
        ...this.attachment
      })),
      "AvatarFallbackState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _AvatarFallbackState(opts, AvatarRootContext.get());
  }
  get style() {
    return get(__privateGet(this, _style));
  }
  set style(value) {
    set(__privateGet(this, _style), value);
  }
  get props() {
    return get(__privateGet(this, _props17));
  }
  set props(value) {
    set(__privateGet(this, _props17), value);
  }
};
_style = new WeakMap();
_props17 = new WeakMap();
var AvatarFallbackState = _AvatarFallbackState;

// node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte
Avatar[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte";
var root_211 = add_locations(from_html(`<div><!></div>`), Avatar[FILENAME], [[44, 1]]);
function Avatar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar);
  let delayMs = prop($$props, "delayMs", 3, 0), loadingStatus = prop($$props, "loadingStatus", 15, "loading"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "delayMs",
      "loadingStatus",
      "onLoadingStatusChange",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = AvatarRootState.create({
    delayMs: box.with(() => delayMs()),
    loadingStatus: box.with(() => loadingStatus(), (v) => {
      var _a;
      if (strict_equals(loadingStatus(), v, false)) {
        loadingStatus(v);
        (_a = $$props.onLoadingStatusChange) == null ? void 0 : _a.call($$props, v);
      }
    }),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_211();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar = hmr(Avatar, () => Avatar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar[HMR].source;
    set(Avatar[HMR].source, module.default[HMR].original);
  });
}
var avatar_default = Avatar;

// node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte
Avatar_image[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte";
var root_212 = add_locations(from_html(`<img/>`), Avatar_image[FILENAME], [[36, 1]]);
function Avatar_image($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar_image);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), crossorigin = prop($$props, "crossorigin", 3, void 0), referrerpolicy = prop($$props, "referrerpolicy", 3, void 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "child",
      "id",
      "ref",
      "crossorigin",
      "referrerpolicy"
    ],
    "restProps"
  );
  const imageState = AvatarImageState.create({
    src: box.with(() => $$props.src),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    crossOrigin: box.with(() => crossorigin()),
    referrerPolicy: box.with(() => referrerpolicy())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, imageState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var img = root_212();
      attribute_effect(img, () => ({ ...get(mergedProps), src: $$props.src }));
      replay_events(img);
      append($$anchor2, img);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_image = hmr(Avatar_image, () => Avatar_image[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_image[HMR].source;
    set(Avatar_image[HMR].source, module.default[HMR].original);
  });
}
var avatar_image_default = Avatar_image;

// node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte
Avatar_fallback[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte";
var root_213 = add_locations(from_html(`<span><!></span>`), Avatar_fallback[FILENAME], [[31, 1]]);
function Avatar_fallback($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar_fallback);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const fallbackState = AvatarFallbackState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, fallbackState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_213();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_fallback = hmr(Avatar_fallback, () => Avatar_fallback[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_fallback[HMR].source;
    set(Avatar_fallback[HMR].source, module.default[HMR].original);
  });
}
var avatar_fallback_default = Avatar_fallback;

// node_modules/bits-ui/dist/bits/utilities/config/components/bits-config.svelte
Bits_config[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/config/components/bits-config.svelte";
function Bits_config($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Bits_config);
  useBitsConfig({
    defaultPortalTo: box.with(() => $$props.defaultPortalTo),
    defaultLocale: box.with(() => $$props.defaultLocale)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Bits_config = hmr(Bits_config, () => Bits_config[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Bits_config[HMR].source;
    set(Bits_config[HMR].source, module.default[HMR].original);
  });
}
var bits_config_default = Bits_config;

// node_modules/bits-ui/dist/bits/button/exports.js
var exports_exports5 = {};
__export(exports_exports5, {
  Root: () => button_default
});

// node_modules/bits-ui/dist/bits/button/components/button.svelte
Button[FILENAME] = "node_modules/bits-ui/dist/bits/button/components/button.svelte";
function Button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Button);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "href",
      "type",
      "children",
      "disabled",
      "ref"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  validate_void_dynamic_element(() => $$props.href ? "a" : "button");
  validate_dynamic_element_tag(() => $$props.href ? "a" : "button");
  element(
    node,
    () => $$props.href ? "a" : "button",
    false,
    ($$element, $$anchor2) => {
      bind_this($$element, ($$value) => ref($$value), () => ref());
      attribute_effect($$element, () => ({
        "data-button-root": true,
        type: $$props.href ? void 0 : $$props.type,
        href: $$props.href && !disabled() ? $$props.href : void 0,
        disabled: $$props.href ? void 0 : disabled(),
        "aria-disabled": $$props.href ? disabled() : void 0,
        role: $$props.href && disabled() ? "link" : void 0,
        tabindex: $$props.href && disabled() ? -1 : 0,
        ...restProps
      }));
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    },
    void 0,
    [14, 0]
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Button = hmr(Button, () => Button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Button[HMR].source;
    set(Button[HMR].source, module.default[HMR].original);
  });
}
var button_default = Button;

// node_modules/bits-ui/dist/bits/calendar/exports.js
var exports_exports6 = {};
__export(exports_exports6, {
  Cell: () => calendar_cell_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => calendar_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/internal/date-time/announcer.js
function initAnnouncer(doc) {
  if (!isBrowser || !doc)
    return null;
  let el = doc.querySelector("[data-bits-announcer]");
  const createLog = (kind) => {
    const log = doc.createElement("div");
    log.role = "log";
    log.ariaLive = kind;
    log.setAttribute("aria-relevant", "additions");
    return log;
  };
  if (!isHTMLElement2(el)) {
    const div = doc.createElement("div");
    div.style.cssText = srOnlyStylesString;
    div.setAttribute("data-bits-announcer", "");
    div.appendChild(createLog("assertive"));
    div.appendChild(createLog("polite"));
    el = div;
    doc.body.insertBefore(el, doc.body.firstChild);
  }
  const getLog = (kind) => {
    if (!isHTMLElement2(el))
      return null;
    const log = el.querySelector(`[aria-live="${kind}"]`);
    if (!isHTMLElement2(log))
      return null;
    return log;
  };
  return {
    getLog
  };
}
function getAnnouncer(doc) {
  const announcer = initAnnouncer(doc);
  function announce(value, kind = "assertive", timeout = 7500) {
    if (!announcer || !isBrowser || !doc)
      return;
    const log = announcer.getLog(kind);
    const content = doc.createElement("div");
    if (typeof value === "number") {
      value = value.toString();
    } else if (value === null) {
      value = "Empty";
    } else {
      value = value.trim();
    }
    content.innerText = value;
    if (kind === "assertive") {
      log == null ? void 0 : log.replaceChildren(content);
    } else {
      log == null ? void 0 : log.appendChild(content);
    }
    return setTimeout(() => {
      content.remove();
    }, timeout);
  }
  return {
    announce
  };
}

// node_modules/bits-ui/dist/internal/date-time/utils.js
var defaultDateDefaults = {
  defaultValue: void 0,
  granularity: "day"
};
var defaultTimeDefaults = {
  defaultValue: void 0,
  granularity: "minute"
};
function getDefaultDate(opts) {
  const withDefaults = { ...defaultDateDefaults, ...opts };
  const { defaultValue, granularity } = withDefaults;
  if (Array.isArray(defaultValue) && defaultValue.length) {
    return defaultValue[defaultValue.length - 1];
  }
  if (defaultValue && !Array.isArray(defaultValue)) {
    return defaultValue;
  } else {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ["hour", "minute", "second"];
    if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
  }
}
function getDefaultTime(opts) {
  const withDefaults = { ...defaultTimeDefaults, ...opts };
  const { defaultValue } = withDefaults;
  if (defaultValue) {
    return defaultValue;
  } else {
    return new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
  }
}
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
    dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  } else {
    dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  }
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    return dateValue.toDate();
  } else {
    return dateValue.toDate(tz);
  }
}
function getDateValueType(date) {
  if (date instanceof $35ea8db9cb2ccb90$export$99faa760c7908e4f)
    return "date";
  if (date instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f)
    return "datetime";
  if (date instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function parseAnyDateValue(value, type) {
  switch (type) {
    case "date":
      return $fae977aafc393c5c$export$6b862160d295c8e(value);
    case "datetime":
      return $fae977aafc393c5c$export$588937bcd60ade55(value);
    case "zoneddatetime":
      return $fae977aafc393c5c$export$fd7893f06e92a6a4(value);
    default:
      throw new Error(`Unknown date type: ${type}`);
  }
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) {
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  }
  if (firstDayOfWeek === day) {
    return date;
  }
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) {
    return date;
  }
  if (day > lastDayOfWeek) {
    return date.add({ days: 7 - day + lastDayOfWeek });
  }
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
  if (isUnavailable === void 0 && isDisabled === void 0) {
    return true;
  }
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled == null ? void 0 : isDisabled(dCurrent)) || (isUnavailable == null ? void 0 : isUnavailable(dCurrent))) {
      return false;
    }
  }
  return true;
}

// node_modules/bits-ui/dist/internal/date-time/field/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var EDITABLE_TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [
  ...DATE_SEGMENT_PARTS,
  ...EDITABLE_TIME_SEGMENT_PARTS
];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_TIME_SEGMENT_PARTS = [
  ...EDITABLE_TIME_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");
var ALL_TIME_EXCEPT_LITERAL_PARTS = ALL_TIME_SEGMENT_PARTS.filter((part) => part !== "literal");

// node_modules/bits-ui/dist/internal/date-time/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "ዓዓዓዓ", month: "ሚሜ", day: "ቀቀ" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "سنة", month: "شهر", day: "يوم" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "гггг", month: "мм", day: "дд" },
  bg: { year: "гггг", month: "мм", day: "дд" },
  bn: { year: "yyyy", month: "মিমি", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "ساڵ", month: "مانگ", day: "ڕۆژ" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "åååå", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "źź" },
  el: { year: "εεεε", month: "μμ", day: "ηη" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "سال", month: "ماه", day: "روز" },
  ff: { year: "hhhh", month: "ll", day: "ññ" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "שנה", month: "חודש", day: "יום" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "éééé", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: " 年 ", month: "月", day: "日" },
  ka: { year: "წწწწ", month: "თთ", day: "რრ" },
  kk: { year: "жжжж", month: "аа", day: "кк" },
  kn: { year: "ವವವವ", month: "ಮಿಮೀ", day: "ದಿದಿ" },
  ko: { year: "연도", month: "월", day: "일" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "ປປປປ", month: "ດດ", day: "ວວ" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "വർഷം", month: "മാസം", day: "തീയതി" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "åååå", month: "mm", day: "dd" },
  no: { year: "åååå", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "гггг", month: "мм", day: "дд" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "гггг", month: "мм", day: "дд" },
  sv: { year: "åååå", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "сссс", month: "мм", day: "рр" },
  th: { year: "ปปปป", month: "ดด", day: "วว" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "рррр", month: "мм", day: "дд" },
  "zh-CN": { year: "年", month: "月", day: "日" },
  "zh-TW": { year: "年", month: "月", day: "日" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) {
      return placeholders.en;
    } else {
      return placeholders[localeLanguage];
    }
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field))
    return getPlaceholderObj(locale)[field];
  if (isDefaultField(field))
    return value;
  if (isTimeField(field))
    return "––";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) {
    return new Intl.Locale(locale).language;
  }
  return locale.split("-")[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/helpers.js
function initializeSegmentValues(granularity) {
  const calendarDateTimeGranularities = ["hour", "minute", "second"];
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") {
      return [part, "AM"];
    }
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null)
      return false;
    if (granularity === "day") {
      return !calendarDateTimeGranularities.includes(key);
    } else {
      return true;
    }
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props) {
  const { segmentValues, formatter, locale, dateRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
      const intValue = value !== null ? Number.parseInt(value) : null;
      if (value === "0" && part !== "year") {
        return "0";
      } else if (!isNull(value) && !isNull(intValue)) {
        const formatted = formatter.part(dateRef.set({ [part]: value }), part, {
          hourCycle: props.hourCycle === 24 ? "h23" : void 0
        });
        if (part === "hour" && "dayPeriod" in segmentValues && props.hourCycle !== 24) {
          if (intValue > 12) {
            const hour = intValue - 12;
            if (hour === 0) {
              return "12";
            } else if (hour < 10) {
              return `0${hour}`;
            } else {
              return `${hour}`;
            }
          }
          if (intValue === 0) {
            return "12";
          }
          if (intValue < 10) {
            return `0${intValue}`;
          }
          return `${intValue}`;
        }
        if (part === "year") {
          return `${value}`;
        }
        if (leadingZero && formatted.length === 1) {
          return `0${formatted}`;
        }
        return formatted;
      } else {
        return getPlaceholder(part, "", locale);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
        if (value === "0") {
          return "0";
        } else if (!isNull(value)) {
          const formatted = formatter.part(dateRef.set({ [part]: value }), part);
          if (part === "year") {
            return `${value}`;
          }
          if (leadingZero && formatted.length === 1) {
            return `0${formatted}`;
          }
          return formatted;
        } else {
          return getPlaceholder(part, "", locale);
        }
      }
      return "";
    }
  }
  return content;
}
function createContentArr(props) {
  const { granularity, dateRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(dateRef, getOptsByGranularity(granularity, hourCycle));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "dayPeriod", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(dateRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return segmentContentArr;
}
function createContent(props) {
  const contentObj = createContentObj(props);
  const contentArr = createContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity(granularity, hourCycle) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initSegmentStates() {
  return EDITABLE_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}
function isAnySegmentPart(part) {
  return ALL_SEGMENT_PARTS.includes(part);
}
function getUsedSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getValueFromSegments(props) {
  const { segmentObj, fieldNode, dateRef } = props;
  const usedSegments = getUsedSegments(fieldNode);
  let date = dateRef;
  for (const part of usedSegments) {
    if ("hour" in segmentObj) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    } else if (isDateSegmentPart(part)) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    }
  }
  return date;
}
function areAllSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedSegments(fieldNode);
  for (const part of usedSegments) {
    if ("hour" in segmentValues) {
      if (segmentValues[part] === null) {
        return false;
      }
    } else if (isDateSegmentPart(part)) {
      if (segmentValues[part] === null) {
        return false;
      }
    }
  }
  return true;
}
function isDateAndTimeSegmentObj(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return Object.entries(obj).every(([key, value]) => {
    const validKey = EDITABLE_TIME_SEGMENT_PARTS.includes(key) || DATE_SEGMENT_PARTS.includes(key);
    const validValue = key === "dayPeriod" ? value === "AM" || value === "PM" || value === null : typeof value === "string" || typeof value === "number" || value === null;
    return validKey && validValue;
  });
}
function inferGranularity(value, granularity) {
  if (granularity)
    return granularity;
  if (hasTime(value))
    return "minute";
  return "day";
}
function isAcceptableSegmentKey(key) {
  const acceptableSegmentKeys = [
    kbd_constants_exports.ENTER,
    kbd_constants_exports.ARROW_UP,
    kbd_constants_exports.ARROW_DOWN,
    kbd_constants_exports.ARROW_LEFT,
    kbd_constants_exports.ARROW_RIGHT,
    kbd_constants_exports.BACKSPACE,
    kbd_constants_exports.SPACE
  ];
  if (acceptableSegmentKeys.includes(key))
    return true;
  if (isNumberString(key))
    return true;
  return false;
}
function isFirstSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setDescription(props) {
  const { id, formatter, value, doc } = props;
  if (!isBrowser)
    return;
  const valueString = formatter.selectedDate(value);
  const el = doc.getElementById(id);
  if (!el) {
    const div = doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = id;
    div.innerText = `Selected Date: ${valueString}`;
    doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Date: ${valueString}`;
  }
}
function removeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function getDefaultHourCycle(locale) {
  const formatter = new Intl.DateTimeFormat(locale, { hour: "numeric" });
  const parts = formatter.formatToParts(/* @__PURE__ */ new Date("2023-01-01T13:00:00"));
  const hourPart = parts.find((part) => part.type === "hour");
  return (hourPart == null ? void 0 : hourPart.value) === "1" ? 12 : 24;
}

// node_modules/bits-ui/dist/internal/date-time/field/segments.js
function handleSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function handleTimeSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextTimeSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function getNextSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === segments.length - 1 || index === -1)
    return null;
  const nextIndex = index + 1;
  const nextSegment = segments[nextIndex];
  return nextSegment;
}
function getPrevSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === 0 || index === -1)
    return null;
  const prevIndex = index - 1;
  const prevSegment = segments[prevIndex];
  return prevSegment;
}
function getPrevNextSegments(startingNode, fieldNode) {
  const segments = getSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function getPrevNextTimeSegments(startingNode, fieldNode) {
  const segments = getTimeSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function moveToNextSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToNextTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextTimeSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToPrevTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextTimeSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function moveToPrevSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function isSegmentNavigationKey(key) {
  if (key === kbd_constants_exports.ARROW_RIGHT || key === kbd_constants_exports.ARROW_LEFT)
    return true;
  return false;
}
function getSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (!isAnySegmentPart(segment) || segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getTimeSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getFirstTimeSegment(fieldNode) {
  return getTimeSegments(fieldNode)[0];
}
function getFirstSegment(fieldNode) {
  return getSegments(fieldNode)[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/time-helpers.js
function createTimeContentObj(props) {
  const { segmentValues, formatter, locale, timeRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isEditableTimeSegmentPart(part))
      return obj;
    if (part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    const value = segmentValues[part];
    const leadingZero = typeof value === "string" && (value == null ? void 0 : value.startsWith("0"));
    const intValue = value !== null ? Number.parseInt(value) : null;
    if (!isNull(value) && !isNull(intValue)) {
      const formatted = formatter.part(timeRef.set({ [part]: value }), part, {
        hourCycle: props.hourCycle === 24 ? "h23" : void 0
      });
      if (part === "hour" && "dayPeriod" in segmentValues && props.hourCycle !== 24) {
        if (intValue > 12) {
          const hour = intValue - 12;
          if (hour === 0) {
            return "12";
          } else if (hour < 10) {
            return `0${hour}`;
          } else {
            return `${hour}`;
          }
        }
        if (intValue === 0) {
          return "12";
        }
        if (intValue < 10) {
          return `0${intValue}`;
        }
        return `${intValue}`;
      }
      if (leadingZero && formatted.length === 1) {
        return `0${formatted}`;
      }
      return formatted;
    } else {
      return getPlaceholder(part, "", locale);
    }
  }
  return content;
}
function createTimeContentArr(props) {
  const { granularity, timeRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(timeRef, getOptsByGranularity2(granularity, hourCycle));
  const timeSegmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isEditableTimeSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(timeRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return timeSegmentContentArr;
}
function createTimeContent(props) {
  const contentObj = createTimeContentObj(props);
  const contentArr = createTimeContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity2(granularity, hourCycle) {
  const opts = {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "hour") {
    delete opts.minute;
    delete opts.second;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initTimeSegmentStates() {
  return EDITABLE_TIME_SEGMENT_PARTS.reduce((acc, key) => {
    acc[key] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isEditableTimeSegmentPart(part) {
  return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
}
function getUsedTimeSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getTimeSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getTimeValueFromSegments(props) {
  const usedSegments = getUsedTimeSegments(props.fieldNode);
  for (const part of usedSegments) {
    const value = props.segmentObj[part];
    if (isNull(value))
      continue;
    props.timeRef = props.timeRef.set({ [part]: props.segmentObj[part] });
  }
  return props.timeRef;
}
function areAllTimeSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedTimeSegments(fieldNode);
  for (const part of usedSegments) {
    if (segmentValues[part] === null)
      return false;
  }
  return true;
}
function isFirstTimeSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getTimeSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setTimeDescription(props) {
  if (!isBrowser)
    return;
  const valueString = props.formatter.selectedTime(props.value);
  const el = props.doc.getElementById(props.id);
  if (!el) {
    const div = props.doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = props.id;
    div.innerText = `Selected Time: ${valueString}`;
    props.doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Time: ${valueString}`;
  }
}
function removeTimeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function convertTimeValueToDateValue(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f) {
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2020, 1, 1, time.hour, time.minute, time.second, time.millisecond);
  }
  return time;
}
function convertTimeValueToTime(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f)
    return time;
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(time.hour, time.minute, time.second, time.millisecond);
}
function isTimeBefore(timeToCompare, referenceTime) {
  return timeToCompare.compare(referenceTime) < 0;
}
function getISOTimeValue(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f) {
    return $35ea8db9cb2ccb90$export$680ea196effce5f.toString();
  }
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(time.hour, time.minute, time.second, time.millisecond).toString();
}

// node_modules/bits-ui/dist/internal/date-time/formatter.js
var defaultPartOptions = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function createFormatter(opts) {
  let locale = opts.initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date) {
    if (typeof opts.monthFormat.current !== "function" && typeof opts.yearFormat.current !== "function") {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        month: opts.monthFormat.current,
        year: opts.yearFormat.current
      }).format(date);
    }
    const formattedMonth = typeof opts.monthFormat.current === "function" ? opts.monthFormat.current(date.getMonth() + 1) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: opts.monthFormat.current }).format(date);
    const formattedYear = typeof opts.yearFormat.current === "function" ? opts.yearFormat.current(date.getFullYear()) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: opts.yearFormat.current }).format(date);
    return `${formattedMonth} ${formattedYear}`;
  }
  function fullMonth(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
  }
  function fullYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
  }
  function dayPeriod(date, hourCycle = void 0) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = (_a = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM") {
      return "PM";
    }
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts2 = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts2);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek
  };
}
function createTimeFormatter(initialLocale) {
  let locale = initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedTime(date) {
    return custom(toDate(convertTimeValueToDateValue(date)), {
      timeStyle: "long"
    });
  }
  function toParts(timeValue, options) {
    const dateValue = convertTimeValueToDateValue(timeValue);
    if (isZonedDateTime(dateValue)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: dateValue.timeZone
      }).formatToParts(toDate(dateValue));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(dateValue));
    }
  }
  function dayPeriod(date, hourCycle = void 0) {
    var _a;
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = (_a = parts.find((p2) => p2.type === "dayPeriod")) == null ? void 0 : _a.value;
    if (value === "PM")
      return "PM";
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedTime
  };
}

// node_modules/bits-ui/dist/internal/arrays.js
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((value, index) => isEqual(value, arr2[index]));
}
function isEqual(a2, b) {
  if (Number.isNaN(a2) && Number.isNaN(b))
    return true;
  if (Array.isArray(a2) && Array.isArray(b))
    return arraysAreEqual(a2, b);
  if (typeof a2 === "object" && typeof b === "object")
    return isDeepEqual(a2, b);
  return Object.is(a2, b);
}
function isDeepEqual(a2, b) {
  if (typeof a2 !== "object" || typeof b !== "object" || a2 === null || b === null)
    return false;
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length)
    return false;
  for (const key of aKeys) {
    if (!bKeys.includes(key))
      return false;
    if (!isEqual(a2[key], b[key])) {
      return false;
    }
  }
  return true;
}
function chunk(arr, size2) {
  if (size2 <= 0)
    return [];
  const result = [];
  for (let i = 0; i < arr.length; i += size2) {
    result.push(arr.slice(i, i + size2));
  }
  return result;
}
function isValidIndex(index, arr) {
  return index >= 0 && index < arr.length;
}
function next2(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === array.length - 1)
    return loop ? array[0] : void 0;
  return array[index + 1];
}
function prev(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === 0)
    return loop ? array[array.length - 1] : void 0;
  return array[index - 1];
}
function forward(array, index, increment, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index + increment;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function backward(array, index, decrement, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index - decrement;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function getNextMatch(values, search, currentMatch) {
  const lowerSearch = search.toLowerCase();
  if (lowerSearch.endsWith(" ")) {
    const searchWithoutSpace = lowerSearch.slice(0, -1);
    const matchesWithoutSpace = values.filter((value) => value.toLowerCase().startsWith(searchWithoutSpace));
    if (matchesWithoutSpace.length <= 1) {
      return getNextMatch(values, searchWithoutSpace, currentMatch);
    }
    const currentMatchLowercase = currentMatch == null ? void 0 : currentMatch.toLowerCase();
    if (currentMatchLowercase && currentMatchLowercase.startsWith(searchWithoutSpace) && currentMatchLowercase.charAt(searchWithoutSpace.length) === " " && search.trim() === searchWithoutSpace) {
      return currentMatch;
    }
    const spacedMatches = values.filter((value) => value.toLowerCase().startsWith(lowerSearch));
    if (spacedMatches.length > 0) {
      const currentMatchIndex2 = currentMatch ? values.indexOf(currentMatch) : -1;
      let wrappedMatches = wrapArray(spacedMatches, Math.max(currentMatchIndex2, 0));
      const nextMatch2 = wrappedMatches.find((match) => match !== currentMatch);
      return nextMatch2 || currentMatch;
    }
  }
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const normalizedLowerSearch = normalizedSearch.toLowerCase();
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value == null ? void 0 : value.toLowerCase().startsWith(normalizedLowerSearch));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

// node_modules/bits-ui/dist/internal/date-time/calendar-helpers.svelte.js
function isCalendarDayNode(node) {
  if (!isHTMLElement2(node)) return false;
  if (!node.hasAttribute("data-bits-day")) return false;
  return true;
}
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = strict_equals(weekStartsOn, void 0, false) ? getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, "en-US") : getLastFirstDayOfWeek(firstDayOfMonth, 0, locale);
  const nextSaturday = strict_equals(weekStartsOn, void 0, false) ? getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, "en-US") : getNextLastDayOfWeek(lastDayOfMonth, 0, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) {
      startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
    }
    let length = extraDays;
    if (strict_equals(nextMonthDays.length, 0)) {
      length = extraDays - 1;
      nextMonthDays.push(startFrom);
    }
    const extraDaysArray = Array.from({ length }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return { value: dateObj, dates: allDays, weeks };
}
function createMonths(props) {
  const { numberOfMonths, dateObj, ...monthProps } = props;
  const months = [];
  if (!numberOfMonths || strict_equals(numberOfMonths, 1)) {
    months.push(createMonth({ ...monthProps, dateObj }));
    return months;
  }
  months.push(createMonth({ ...monthProps, dateObj }));
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({ ...monthProps, dateObj: nextMonth }));
  }
  return months;
}
function getSelectableCells(calendarNode) {
  if (!calendarNode) return [];
  const selectableSelector = `[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])`;
  return Array.from(calendarNode.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement2(el));
}
function setPlaceholderToNodeValue(node, placeholder) {
  const cellValue = node.getAttribute("data-value");
  if (!cellValue) return;
  placeholder.current = parseStringToDateValue(cellValue, placeholder.current);
}
function shiftCalendarFocus({
  node,
  add,
  placeholder,
  calendarNode,
  isPrevButtonDisabled,
  isNextButtonDisabled,
  months,
  numberOfMonths
}) {
  var _a, _b;
  const candidateCells = getSelectableCells(calendarNode);
  if (!candidateCells.length) return;
  const index = candidateCells.indexOf(node);
  const nextIndex = index + add;
  if (isValidIndex(nextIndex, candidateCells)) {
    const nextCell = candidateCells[nextIndex];
    setPlaceholderToNodeValue(nextCell, placeholder);
    return nextCell.focus();
  }
  if (nextIndex < 0) {
    if (isPrevButtonDisabled) return;
    const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.subtract({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = newCandidateCells.length - Math.abs(nextIndex);
      if (isValidIndex(newIndex, newCandidateCells)) {
        const newCell = newCandidateCells[newIndex];
        setPlaceholderToNodeValue(newCell, placeholder);
        return newCell.focus();
      }
    });
  }
  if (nextIndex >= candidateCells.length) {
    if (isNextButtonDisabled) return;
    const firstMonth = (_b = months[0]) == null ? void 0 : _b.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.add({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = nextIndex - candidateCells.length;
      if (isValidIndex(newIndex, newCandidateCells)) {
        const nextCell = newCandidateCells[newIndex];
        return nextCell.focus();
      }
    });
  }
}
var ARROW_KEYS = [
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT
];
var SELECT_KEYS = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
function handleCalendarKeydown({
  event,
  handleCellClick,
  shiftFocus,
  placeholderValue
}) {
  const currentCell = event.target;
  if (!isCalendarDayNode(currentCell)) return;
  if (!ARROW_KEYS.includes(event.key) && !SELECT_KEYS.includes(event.key)) return;
  event.preventDefault();
  const kbdFocusMap = {
    [kbd_constants_exports.ARROW_DOWN]: 7,
    [kbd_constants_exports.ARROW_UP]: -7,
    [kbd_constants_exports.ARROW_LEFT]: -1,
    [kbd_constants_exports.ARROW_RIGHT]: 1
  };
  if (ARROW_KEYS.includes(event.key)) {
    const add = kbdFocusMap[event.key];
    if (strict_equals(add, void 0, false)) {
      shiftFocus(currentCell, add);
    }
  }
  if (SELECT_KEYS.includes(event.key)) {
    const cellValue = currentCell.getAttribute("data-value");
    if (!cellValue) return;
    handleCellClick(event, parseStringToDateValue(cellValue, placeholderValue));
  }
}
function handleCalendarNextPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.add({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.add({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function handleCalendarPrevPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  var _a;
  const firstMonth = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.subtract({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.subtract({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function getWeekdays({ months, formatter, weekdayFormat }) {
  if (!months.length) return [];
  const firstMonth = months[0];
  const firstWeek = firstMonth.weeks[0];
  if (!firstWeek) return [];
  return firstWeek.map((date) => formatter.dayOfWeek(toDate(date), weekdayFormat));
}
function useMonthViewOptionsSync(props) {
  user_effect(() => {
    const weekStartsOn = props.weekStartsOn.current;
    const locale = props.locale.current;
    const fixedWeeks = props.fixedWeeks.current;
    const numberOfMonths = props.numberOfMonths.current;
    untrack(() => {
      const placeholder = props.placeholder.current;
      if (!placeholder) return;
      const defaultMonthProps = {
        weekStartsOn,
        locale,
        fixedWeeks,
        numberOfMonths
      };
      props.setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder }));
    });
  });
}
function createAccessibleHeading({ calendarNode, label, accessibleHeadingId }) {
  const doc = getDocument(calendarNode);
  const div = doc.createElement("div");
  div.style.cssText = styleToString({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const h2 = doc.createElement("div");
  h2.textContent = label;
  h2.id = accessibleHeadingId;
  h2.role = "heading";
  h2.ariaLevel = "2";
  calendarNode.insertBefore(div, calendarNode.firstChild);
  div.appendChild(h2);
  return () => {
    var _a;
    const h22 = doc.getElementById(accessibleHeadingId);
    if (!h22) return;
    (_a = div.parentElement) == null ? void 0 : _a.removeChild(div);
    h22.remove();
  };
}
function useMonthViewPlaceholderSync({
  placeholder,
  getVisibleMonths,
  weekStartsOn,
  locale,
  fixedWeeks,
  numberOfMonths,
  setMonths
}) {
  user_effect(() => {
    placeholder.current;
    untrack(() => {
      if (getVisibleMonths().some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, placeholder.current))) {
        return;
      }
      const defaultMonthProps = {
        weekStartsOn: weekStartsOn.current,
        locale: locale.current,
        fixedWeeks: fixedWeeks.current,
        numberOfMonths: numberOfMonths.current
      };
      setMonths(createMonths({
        ...defaultMonthProps,
        dateObj: placeholder.current
      }));
    });
  });
}
function getIsNextButtonDisabled({ maxValue, months, disabled }) {
  var _a;
  if (!maxValue || !months.length) return false;
  if (disabled) return true;
  const lastMonthInView = (_a = months[months.length - 1]) == null ? void 0 : _a.value;
  if (!lastMonthInView) return false;
  const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
  return isAfter(firstMonthOfNextPage, maxValue);
}
function getIsPrevButtonDisabled({ minValue, months, disabled }) {
  var _a;
  if (!minValue || !months.length) return false;
  if (disabled) return true;
  const firstMonthInView = (_a = months[0]) == null ? void 0 : _a.value;
  if (!firstMonthInView) return false;
  const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
  return isBefore(lastMonthOfPrevPage, minValue);
}
function getCalendarHeadingValue({ months, locale, formatter }) {
  if (!months.length) return "";
  if (strict_equals(locale, formatter.getLocale(), false)) {
    formatter.setLocale(locale);
  }
  if (strict_equals(months.length, 1)) {
    const month = toDate(months[0].value);
    return `${formatter.fullMonthAndYear(month)}`;
  }
  const startMonth = toDate(months[0].value);
  const endMonth = toDate(months[months.length - 1].value);
  const startMonthName = formatter.fullMonth(startMonth);
  const endMonthName = formatter.fullMonth(endMonth);
  const startMonthYear = formatter.fullYear(startMonth);
  const endMonthYear = formatter.fullYear(endMonth);
  const content = strict_equals(startMonthYear, endMonthYear) ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
  return content;
}
function getCalendarElementProps({
  fullCalendarLabel,
  id,
  isInvalid,
  disabled,
  readonly
}) {
  return {
    id,
    role: "application",
    "aria-label": fullCalendarLabel,
    "data-invalid": getDataInvalid(isInvalid),
    "data-disabled": getDataDisabled(disabled),
    "data-readonly": getDataReadonly(readonly)
  };
}
function pickerOpenFocus(e) {
  const doc = getDocument(e.target);
  const nodeToFocus = doc.querySelector("[data-bits-day][data-focused]");
  if (nodeToFocus) {
    e.preventDefault();
    nodeToFocus == null ? void 0 : nodeToFocus.focus();
  }
}
function getFirstNonDisabledDateInView(calendarRef) {
  if (!isBrowser) return;
  const daysInView = Array.from(calendarRef.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (strict_equals(daysInView.length, 0)) return;
  const element2 = daysInView[0];
  const value = element2 == null ? void 0 : element2.getAttribute("data-value");
  const type = element2 == null ? void 0 : element2.getAttribute("data-type");
  if (!value || !type) return;
  return parseAnyDateValue(value, type);
}
function useEnsureNonDisabledPlaceholder({
  ref,
  placeholder,
  defaultPlaceholder,
  minValue,
  maxValue,
  isDateDisabled
}) {
  function isDisabled(date) {
    if (isDateDisabled.current(date)) return true;
    if (minValue.current && isBefore(date, minValue.current)) return true;
    if (maxValue.current && isBefore(maxValue.current, date)) return true;
    return false;
  }
  watch(() => ref.current, () => {
    if (!ref.current) return;
    if (placeholder.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(placeholder.current, defaultPlaceholder) && isDisabled(defaultPlaceholder)) {
      placeholder.current = getFirstNonDisabledDateInView(ref.current) ?? defaultPlaceholder;
    }
  });
}
function getDateWithPreviousTime(date, prev2) {
  if (!date || !prev2) return date;
  if (hasTime(date) && hasTime(prev2)) {
    return date.set({
      hour: prev2.hour,
      minute: prev2.minute,
      millisecond: prev2.millisecond,
      second: prev2.second
    });
  }
  return date;
}
var calendarAttrs = createBitsAttrs({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function getDefaultYears(opts) {
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const latestYear = Math.max(opts.placeholderYear, currentYear);
  let minYear;
  let maxYear;
  if (opts.minValue) {
    minYear = opts.minValue.year;
  } else {
    const initialMinYear = latestYear - 100;
    minYear = opts.placeholderYear < initialMinYear ? opts.placeholderYear - 10 : initialMinYear;
  }
  if (opts.maxValue) {
    maxYear = opts.maxValue.year;
  } else {
    maxYear = latestYear + 10;
  }
  if (minYear > maxYear) {
    minYear = maxYear;
  }
  const totalYears = maxYear - minYear + 1;
  return Array.from({ length: totalYears }, (_, i) => minYear + i);
}

// node_modules/bits-ui/dist/bits/calendar/calendar.svelte.js
var CalendarRootContext = new Context("Calendar.Root | RangeCalender.Root");
var _visibleMonths, _months, _weekdays, _initialPlaceholderYear, _defaultYears, _CalendarRootState_instances, setupInitialFocusEffect_fn, setupAccessibleHeadingEffect_fn, setupFormatterEffect_fn, _isNextButtonDisabled, _isPrevButtonDisabled, _isInvalid, _headingValue, _fullCalendarLabel, isMultipleSelectionValid_fn, _snippetProps4, _props18;
var _CalendarRootState = class _CalendarRootState {
  constructor(opts) {
    __privateAdd(this, _CalendarRootState_instances);
    __publicField(this, "opts");
    __privateAdd(this, _visibleMonths, tag(user_derived(() => this.months.map((month) => month.value)), "CalendarRootState.visibleMonths"));
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _months, tag(state(proxy([])), "CalendarRootState.months"));
    __publicField(this, "announcer");
    __privateAdd(this, _weekdays, tag(
      user_derived(() => {
        return getWeekdays({
          months: this.months,
          formatter: this.formatter,
          weekdayFormat: this.opts.weekdayFormat.current
        });
      }),
      "CalendarRootState.weekdays"
    ));
    __privateAdd(this, _initialPlaceholderYear, tag(user_derived(() => untrack(() => this.opts.placeholder.current.year)), "CalendarRootState.initialPlaceholderYear"));
    __privateAdd(this, _defaultYears, tag(
      user_derived(() => {
        return getDefaultYears({
          minValue: this.opts.minValue.current,
          maxValue: this.opts.maxValue.current,
          placeholderYear: this.initialPlaceholderYear
        });
      }),
      "CalendarRootState.defaultYears"
    ));
    __privateAdd(this, _isNextButtonDisabled, tag(
      user_derived(() => {
        return getIsNextButtonDisabled({
          maxValue: this.opts.maxValue.current,
          months: this.months,
          disabled: this.opts.disabled.current
        });
      }),
      "CalendarRootState.isNextButtonDisabled"
    ));
    __privateAdd(this, _isPrevButtonDisabled, tag(
      user_derived(() => {
        return getIsPrevButtonDisabled({
          minValue: this.opts.minValue.current,
          months: this.months,
          disabled: this.opts.disabled.current
        });
      }),
      "CalendarRootState.isPrevButtonDisabled"
    ));
    __privateAdd(this, _isInvalid, tag(
      user_derived(() => {
        const value = this.opts.value.current;
        const isDateDisabled = this.opts.isDateDisabled.current;
        const isDateUnavailable = this.opts.isDateUnavailable.current;
        if (Array.isArray(value)) {
          if (!value.length) return false;
          for (const date of value) {
            if (isDateDisabled(date)) return true;
            if (isDateUnavailable(date)) return true;
          }
        } else {
          if (!value) return false;
          if (isDateDisabled(value)) return true;
          if (isDateUnavailable(value)) return true;
        }
        return false;
      }),
      "CalendarRootState.isInvalid"
    ));
    __privateAdd(this, _headingValue, tag(
      user_derived(() => {
        this.opts.monthFormat.current;
        this.opts.yearFormat.current;
        return getCalendarHeadingValue({
          months: this.months,
          formatter: this.formatter,
          locale: this.opts.locale.current
        });
      }),
      "CalendarRootState.headingValue"
    ));
    __privateAdd(this, _fullCalendarLabel, tag(
      user_derived(() => {
        return `${this.opts.calendarLabel.current} ${this.headingValue}`;
      }),
      "CalendarRootState.fullCalendarLabel"
    ));
    __privateAdd(this, _snippetProps4, tag(user_derived(() => ({ months: this.months, weekdays: this.weekdays })), "CalendarRootState.snippetProps"));
    __publicField(this, "getBitsAttr", (part) => {
      return calendarAttrs.getAttr(part);
    });
    __privateAdd(this, _props18, tag(
      user_derived(() => ({
        ...getCalendarElementProps({
          fullCalendarLabel: this.fullCalendarLabel,
          id: this.opts.id.current,
          isInvalid: this.isInvalid,
          disabled: this.opts.disabled.current,
          readonly: this.opts.readonly.current
        }),
        [this.getBitsAttr("root")]: "",
        //
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "CalendarRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.setMonths = this.setMonths.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateSelected = this.isDateSelected.bind(this);
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this);
    this.handleSingleUpdate = this.handleSingleUpdate.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.getBitsAttr = this.getBitsAttr.bind(this);
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    __privateMethod(this, _CalendarRootState_instances, setupInitialFocusEffect_fn).call(this);
    __privateMethod(this, _CalendarRootState_instances, setupAccessibleHeadingEffect_fn).call(this);
    __privateMethod(this, _CalendarRootState_instances, setupFormatterEffect_fn).call(this);
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (months) => this.months = months
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    watch(() => this.fullCalendarLabel, (label) => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = label;
    });
    watch(() => this.opts.value.current, () => {
      const value = this.opts.value.current;
      if (Array.isArray(value) && value.length) {
        const lastValue = value[value.length - 1];
        if (lastValue && strict_equals(this.opts.placeholder.current, lastValue, false)) {
          this.opts.placeholder.current = lastValue;
        }
      } else if (!Array.isArray(value) && value && strict_equals(this.opts.placeholder.current, value, false)) {
        this.opts.placeholder.current = value;
      }
    });
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  static create(opts) {
    return CalendarRootContext.set(new _CalendarRootState(opts));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths));
  }
  set visibleMonths(value) {
    set(__privateGet(this, _visibleMonths), value);
  }
  get months() {
    return get(__privateGet(this, _months));
  }
  set months(value) {
    set(__privateGet(this, _months), value, true);
  }
  setMonths(months) {
    this.months = months;
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays));
  }
  set weekdays(value) {
    set(__privateGet(this, _weekdays), value);
  }
  get initialPlaceholderYear() {
    return get(__privateGet(this, _initialPlaceholderYear));
  }
  set initialPlaceholderYear(value) {
    set(__privateGet(this, _initialPlaceholderYear), value);
  }
  get defaultYears() {
    return get(__privateGet(this, _defaultYears));
  }
  set defaultYears(value) {
    set(__privateGet(this, _defaultYears), value);
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled));
  }
  set isNextButtonDisabled(value) {
    set(__privateGet(this, _isNextButtonDisabled), value);
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled));
  }
  set isPrevButtonDisabled(value) {
    set(__privateGet(this, _isPrevButtonDisabled), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid), value);
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue));
  }
  set headingValue(value) {
    set(__privateGet(this, _headingValue), value);
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel));
  }
  set fullCalendarLabel(value) {
    set(__privateGet(this, _fullCalendarLabel), value);
  }
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isBefore(maxValue, date)) return true;
    return false;
  }
  isDateSelected(date) {
    const value = this.opts.value.current;
    if (Array.isArray(value)) {
      return value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    } else if (!value) {
      return false;
    }
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(value, date);
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  handleCellClick(_, date) {
    var _a, _b, _c, _d, _e, _f;
    if (this.opts.readonly.current || ((_b = (_a = this.opts.isDateDisabled).current) == null ? void 0 : _b.call(_a, date)) || ((_d = (_c = this.opts.isDateUnavailable).current) == null ? void 0 : _d.call(_c, date))) {
      return;
    }
    const prev2 = this.opts.value.current;
    const multiple = strict_equals(this.opts.type.current, "multiple");
    if (multiple) {
      if (Array.isArray(prev2) || strict_equals(prev2, void 0)) {
        this.opts.value.current = this.handleMultipleUpdate(prev2, date);
      }
    } else if (!Array.isArray(prev2)) {
      const next3 = this.handleSingleUpdate(prev2, date);
      if (!next3) {
        this.announcer.announce("Selected date is now empty.", "polite", 5e3);
      } else {
        this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(next3, false)}`, "polite");
      }
      this.opts.value.current = getDateWithPreviousTime(next3, prev2);
      if (strict_equals(next3, void 0, false)) {
        (_f = (_e = this.opts.onDateSelect) == null ? void 0 : _e.current) == null ? void 0 : _f.call(_e);
      }
    }
  }
  handleMultipleUpdate(prev2, date) {
    if (!prev2) {
      const newSelection = [date];
      return __privateMethod(this, _CalendarRootState_instances, isMultipleSelectionValid_fn).call(this, newSelection) ? newSelection : [date];
    }
    if (!Array.isArray(prev2)) {
      if (true_default) throw new Error("Invalid value for multiple prop.");
      return;
    }
    const index = prev2.findIndex((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    const preventDeselect = this.opts.preventDeselect.current;
    if (strict_equals(index, -1)) {
      const newSelection = [...prev2, date];
      if (__privateMethod(this, _CalendarRootState_instances, isMultipleSelectionValid_fn).call(this, newSelection)) {
        return newSelection;
      } else {
        return [date];
      }
    } else if (preventDeselect) {
      return prev2;
    } else {
      const next3 = prev2.filter((d) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      if (!next3.length) {
        this.opts.placeholder.current = date;
        return void 0;
      }
      return next3;
    }
  }
  handleSingleUpdate(prev2, date) {
    if (Array.isArray(prev2)) {
      if (true_default) throw new Error("Invalid value for single prop.");
    }
    if (!prev2) return date;
    const preventDeselect = this.opts.preventDeselect.current;
    if (!preventDeselect && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prev2, date)) {
      this.opts.placeholder.current = date;
      return void 0;
    }
    return date;
  }
  onkeydown(event) {
    handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps4));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps4), value);
  }
  get props() {
    return get(__privateGet(this, _props18));
  }
  set props(value) {
    set(__privateGet(this, _props18), value);
  }
};
_visibleMonths = new WeakMap();
_months = new WeakMap();
_weekdays = new WeakMap();
_initialPlaceholderYear = new WeakMap();
_defaultYears = new WeakMap();
_CalendarRootState_instances = new WeakSet();
setupInitialFocusEffect_fn = function() {
  user_effect(() => {
    var _a;
    const initialFocus = untrack(() => this.opts.initialFocus.current);
    if (initialFocus) {
      const firstFocusedDay = (_a = this.opts.ref.current) == null ? void 0 : _a.querySelector(`[data-focused]`);
      if (firstFocusedDay) {
        firstFocusedDay.focus();
      }
    }
  });
};
setupAccessibleHeadingEffect_fn = function() {
  user_effect(() => {
    if (!this.opts.ref.current) return;
    const removeHeading = createAccessibleHeading({
      calendarNode: this.opts.ref.current,
      label: this.fullCalendarLabel,
      accessibleHeadingId: this.accessibleHeadingId
    });
    return removeHeading;
  });
};
setupFormatterEffect_fn = function() {
  user_pre_effect(() => {
    if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
    this.formatter.setLocale(this.opts.locale.current);
  });
};
_isNextButtonDisabled = new WeakMap();
_isPrevButtonDisabled = new WeakMap();
_isInvalid = new WeakMap();
_headingValue = new WeakMap();
_fullCalendarLabel = new WeakMap();
isMultipleSelectionValid_fn = function(selectedDates) {
  if (strict_equals(this.opts.type.current, "multiple", false)) return true;
  if (!this.opts.maxDays.current) return true;
  const selectedCount = selectedDates.length;
  if (this.opts.maxDays.current && selectedCount > this.opts.maxDays.current) return false;
  return true;
};
_snippetProps4 = new WeakMap();
_props18 = new WeakMap();
var CalendarRootState = _CalendarRootState;
var _props19;
var _CalendarHeadingState = class _CalendarHeadingState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props19, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-hidden": getAriaHidden(true),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("heading")]: "",
        ...this.attachment
      })),
      "CalendarHeadingState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeadingState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props19));
  }
  set props(value) {
    set(__privateGet(this, _props19), value);
  }
};
_props19 = new WeakMap();
var CalendarHeadingState = _CalendarHeadingState;
var CalendarCellContext = new Context("Calendar.Cell | RangeCalendar.Cell");
var _cellDate, _isUnavailable, _isDateToday, _isOutsideMonth, _isOutsideVisibleMonths, _isDisabled3, _isFocusedDate, _isSelectedDate, _labelText, _snippetProps5, _ariaDisabled, _sharedDataAttrs, _props20;
var _CalendarCellState = class _CalendarCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _cellDate, tag(user_derived(() => toDate(this.opts.date.current)), "CalendarCellState.cellDate"));
    __privateAdd(this, _isUnavailable, tag(user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)), "CalendarCellState.isUnavailable"));
    __privateAdd(this, _isDateToday, tag(user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), "CalendarCellState.isDateToday"));
    __privateAdd(this, _isOutsideMonth, tag(user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)), "CalendarCellState.isOutsideMonth"));
    __privateAdd(this, _isOutsideVisibleMonths, tag(user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)), "CalendarCellState.isOutsideVisibleMonths"));
    __privateAdd(this, _isDisabled3, tag(user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current), "CalendarCellState.isDisabled"));
    __privateAdd(this, _isFocusedDate, tag(user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)), "CalendarCellState.isFocusedDate"));
    __privateAdd(this, _isSelectedDate, tag(user_derived(() => this.root.isDateSelected(this.opts.date.current)), "CalendarCellState.isSelectedDate"));
    __privateAdd(this, _labelText, tag(
      user_derived(() => this.root.formatter.custom(this.cellDate, {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      })),
      "CalendarCellState.labelText"
    ));
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps5, tag(
      user_derived(() => ({
        disabled: this.isDisabled,
        unavailable: this.isUnavailable,
        selected: this.isSelectedDate,
        day: `${this.opts.date.current.day}`
      })),
      "CalendarCellState.snippetProps"
    ));
    __privateAdd(this, _ariaDisabled, tag(
      user_derived(() => {
        return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
      }),
      "CalendarCellState.ariaDisabled"
    ));
    __privateAdd(this, _sharedDataAttrs, tag(
      user_derived(() => ({
        "data-unavailable": getDataUnavailable(this.isUnavailable),
        "data-today": this.isDateToday ? "" : void 0,
        "data-outside-month": this.isOutsideMonth ? "" : void 0,
        "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
        "data-focused": this.isFocusedDate ? "" : void 0,
        "data-selected": getDataSelected(this.isSelectedDate),
        "data-value": this.opts.date.current.toString(),
        "data-type": getDateValueType(this.opts.date.current),
        "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
      })),
      "CalendarCellState.sharedDataAttrs"
    ));
    __privateAdd(this, _props20, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "gridcell",
        "aria-selected": getAriaSelected(this.isSelectedDate),
        "aria-disabled": getAriaDisabled(this.ariaDisabled),
        ...this.sharedDataAttrs,
        [this.root.getBitsAttr("cell")]: "",
        ...this.attachment
      })),
      "CalendarCellState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CalendarCellContext.set(new _CalendarCellState(opts, CalendarRootContext.get()));
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate));
  }
  set cellDate(value) {
    set(__privateGet(this, _cellDate), value);
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable));
  }
  set isUnavailable(value) {
    set(__privateGet(this, _isUnavailable), value);
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday));
  }
  set isDateToday(value) {
    set(__privateGet(this, _isDateToday), value);
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth));
  }
  set isOutsideMonth(value) {
    set(__privateGet(this, _isOutsideMonth), value);
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths));
  }
  set isOutsideVisibleMonths(value) {
    set(__privateGet(this, _isOutsideVisibleMonths), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled3));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled3), value);
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate));
  }
  set isFocusedDate(value) {
    set(__privateGet(this, _isFocusedDate), value);
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate));
  }
  set isSelectedDate(value) {
    set(__privateGet(this, _isSelectedDate), value);
  }
  get labelText() {
    return get(__privateGet(this, _labelText));
  }
  set labelText(value) {
    set(__privateGet(this, _labelText), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps5));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps5), value);
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled));
  }
  set ariaDisabled(value) {
    set(__privateGet(this, _ariaDisabled), value);
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs));
  }
  set sharedDataAttrs(value) {
    set(__privateGet(this, _sharedDataAttrs), value);
  }
  get props() {
    return get(__privateGet(this, _props20));
  }
  set props(value) {
    set(__privateGet(this, _props20), value);
  }
};
_cellDate = new WeakMap();
_isUnavailable = new WeakMap();
_isDateToday = new WeakMap();
_isOutsideMonth = new WeakMap();
_isOutsideVisibleMonths = new WeakMap();
_isDisabled3 = new WeakMap();
_isFocusedDate = new WeakMap();
_isSelectedDate = new WeakMap();
_labelText = new WeakMap();
_snippetProps5 = new WeakMap();
_ariaDisabled = new WeakMap();
_sharedDataAttrs = new WeakMap();
_props20 = new WeakMap();
var CalendarCellState = _CalendarCellState;
var _tabindex, _snippetProps6, _props21;
var _CalendarDayState = class _CalendarDayState {
  constructor(opts, cell) {
    __publicField(this, "opts");
    __publicField(this, "cell");
    __publicField(this, "attachment");
    __privateAdd(this, _tabindex, tag(user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1), "CalendarDayState.#tabindex"));
    __privateAdd(this, _snippetProps6, tag(
      user_derived(() => ({
        disabled: this.cell.isDisabled,
        unavailable: this.cell.isUnavailable,
        selected: this.cell.isSelectedDate,
        day: `${this.cell.opts.date.current.day}`
      })),
      "CalendarDayState.snippetProps"
    ));
    __privateAdd(this, _props21, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "button",
        "aria-label": this.cell.labelText,
        "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
        ...this.cell.sharedDataAttrs,
        tabindex: get(__privateGet(this, _tabindex)),
        [this.cell.root.getBitsAttr("day")]: "",
        // Shared logic for range calendar and calendar
        "data-bits-day": "",
        //
        onclick: this.onclick,
        ...this.attachment
      })),
      "CalendarDayState.props"
    ));
    this.opts = opts;
    this.cell = cell;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarDayState(opts, CalendarCellContext.get());
  }
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps6));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps6), value);
  }
  get props() {
    return get(__privateGet(this, _props21));
  }
  set props(value) {
    set(__privateGet(this, _props21), value);
  }
};
_tabindex = new WeakMap();
_snippetProps6 = new WeakMap();
_props21 = new WeakMap();
var CalendarDayState = _CalendarDayState;
var _isDisabled4, _props22;
var _CalendarNextButtonState = class _CalendarNextButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isDisabled4, tag(user_derived(() => this.root.isNextButtonDisabled), "CalendarNextButtonState.isDisabled"));
    __publicField(this, "attachment");
    __privateAdd(this, _props22, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "button",
        type: "button",
        "aria-label": "Next",
        "aria-disabled": getAriaDisabled(this.isDisabled),
        "data-disabled": getDataDisabled(this.isDisabled),
        disabled: this.isDisabled,
        [this.root.getBitsAttr("next-button")]: "",
        //
        onclick: this.onclick,
        ...this.attachment
      })),
      "CalendarNextButtonState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarNextButtonState(opts, CalendarRootContext.get());
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled4));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled4), value);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.nextPage();
  }
  get props() {
    return get(__privateGet(this, _props22));
  }
  set props(value) {
    set(__privateGet(this, _props22), value);
  }
};
_isDisabled4 = new WeakMap();
_props22 = new WeakMap();
var CalendarNextButtonState = _CalendarNextButtonState;
var _isDisabled5, _props23;
var _CalendarPrevButtonState = class _CalendarPrevButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isDisabled5, tag(user_derived(() => this.root.isPrevButtonDisabled), "CalendarPrevButtonState.isDisabled"));
    __publicField(this, "attachment");
    __privateAdd(this, _props23, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "button",
        type: "button",
        "aria-label": "Previous",
        "aria-disabled": getAriaDisabled(this.isDisabled),
        "data-disabled": getDataDisabled(this.isDisabled),
        disabled: this.isDisabled,
        [this.root.getBitsAttr("prev-button")]: "",
        //
        onclick: this.onclick,
        ...this.attachment
      })),
      "CalendarPrevButtonState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarPrevButtonState(opts, CalendarRootContext.get());
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled5));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled5), value);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.prevPage();
  }
  get props() {
    return get(__privateGet(this, _props23));
  }
  set props(value) {
    set(__privateGet(this, _props23), value);
  }
};
_isDisabled5 = new WeakMap();
_props23 = new WeakMap();
var CalendarPrevButtonState = _CalendarPrevButtonState;
var _props24;
var _CalendarGridState = class _CalendarGridState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props24, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        tabindex: -1,
        role: "grid",
        "aria-readonly": getAriaReadonly(this.root.opts.readonly.current),
        "aria-disabled": getAriaDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        [this.root.getBitsAttr("grid")]: "",
        ...this.attachment
      })),
      "CalendarGridState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props24));
  }
  set props(value) {
    set(__privateGet(this, _props24), value);
  }
};
_props24 = new WeakMap();
var CalendarGridState = _CalendarGridState;
var _props25;
var _CalendarGridBodyState = class _CalendarGridBodyState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props25, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("grid-body")]: "",
        ...this.attachment
      })),
      "CalendarGridBodyState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridBodyState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props25));
  }
  set props(value) {
    set(__privateGet(this, _props25), value);
  }
};
_props25 = new WeakMap();
var CalendarGridBodyState = _CalendarGridBodyState;
var _props26;
var _CalendarGridHeadState = class _CalendarGridHeadState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props26, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("grid-head")]: "",
        ...this.attachment
      })),
      "CalendarGridHeadState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridHeadState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props26));
  }
  set props(value) {
    set(__privateGet(this, _props26), value);
  }
};
_props26 = new WeakMap();
var CalendarGridHeadState = _CalendarGridHeadState;
var _props27;
var _CalendarGridRowState = class _CalendarGridRowState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props27, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("grid-row")]: "",
        ...this.attachment
      })),
      "CalendarGridRowState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarGridRowState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props27));
  }
  set props(value) {
    set(__privateGet(this, _props27), value);
  }
};
_props27 = new WeakMap();
var CalendarGridRowState = _CalendarGridRowState;
var _props28;
var _CalendarHeadCellState = class _CalendarHeadCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props28, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("head-cell")]: "",
        ...this.attachment
      })),
      "CalendarHeadCellState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeadCellState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props28));
  }
  set props(value) {
    set(__privateGet(this, _props28), value);
  }
};
_props28 = new WeakMap();
var CalendarHeadCellState = _CalendarHeadCellState;
var _props29;
var _CalendarHeaderState = class _CalendarHeaderState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props29, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-readonly": getDataReadonly(this.root.opts.readonly.current),
        [this.root.getBitsAttr("header")]: "",
        ...this.attachment
      })),
      "CalendarHeaderState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarHeaderState(opts, CalendarRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props29));
  }
  set props(value) {
    set(__privateGet(this, _props29), value);
  }
};
_props29 = new WeakMap();
var CalendarHeaderState = _CalendarHeaderState;
var _monthItems, _currentMonth, _isDisabled6, _snippetProps7, _props30;
var _CalendarMonthSelectState = class _CalendarMonthSelectState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _monthItems, tag(
      user_derived(() => {
        this.root.opts.locale.current;
        const monthNumbers = this.opts.months.current;
        const monthFormat = this.opts.monthFormat.current;
        const months = [];
        for (const month of monthNumbers) {
          const date = this.root.opts.placeholder.current.set({ month });
          let label;
          if (strict_equals(typeof monthFormat, "function")) {
            label = monthFormat(month);
          } else {
            label = this.root.formatter.custom(toDate(date), { month: monthFormat });
          }
          months.push({ value: month, label });
        }
        return months;
      }),
      "CalendarMonthSelectState.monthItems"
    ));
    __privateAdd(this, _currentMonth, tag(user_derived(() => this.root.opts.placeholder.current.month), "CalendarMonthSelectState.currentMonth"));
    __privateAdd(this, _isDisabled6, tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "CalendarMonthSelectState.isDisabled"));
    __privateAdd(this, _snippetProps7, tag(
      user_derived(() => {
        return {
          monthItems: this.monthItems,
          selectedMonthItem: this.monthItems.find((month) => strict_equals(month.value, this.currentMonth))
        };
      }),
      "CalendarMonthSelectState.snippetProps"
    ));
    __privateAdd(this, _props30, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        value: this.currentMonth,
        disabled: this.isDisabled,
        "data-disabled": getDataDisabled(this.isDisabled),
        [this.root.getBitsAttr("month-select")]: "",
        //
        onchange: this.onchange,
        ...this.attachment
      })),
      "CalendarMonthSelectState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarMonthSelectState(opts, CalendarRootContext.get());
  }
  get monthItems() {
    return get(__privateGet(this, _monthItems));
  }
  set monthItems(value) {
    set(__privateGet(this, _monthItems), value);
  }
  get currentMonth() {
    return get(__privateGet(this, _currentMonth));
  }
  set currentMonth(value) {
    set(__privateGet(this, _currentMonth), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled6));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled6), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps7));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps7), value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const month = parseInt(target.value, 10);
    if (!isNaN(month)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month });
    }
  }
  get props() {
    return get(__privateGet(this, _props30));
  }
  set props(value) {
    set(__privateGet(this, _props30), value);
  }
};
_monthItems = new WeakMap();
_currentMonth = new WeakMap();
_isDisabled6 = new WeakMap();
_snippetProps7 = new WeakMap();
_props30 = new WeakMap();
var CalendarMonthSelectState = _CalendarMonthSelectState;
var _years, _yearItems, _currentYear, _isDisabled7, _snippetProps8, _props31;
var _CalendarYearSelectState = class _CalendarYearSelectState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _years, tag(
      user_derived(() => {
        if (this.opts.years.current && this.opts.years.current.length) return this.opts.years.current;
        return this.root.defaultYears;
      }),
      "CalendarYearSelectState.years"
    ));
    __privateAdd(this, _yearItems, tag(
      user_derived(() => {
        this.root.opts.locale.current;
        const yearFormat = this.opts.yearFormat.current;
        const localYears = [];
        for (const year of this.years) {
          const date = this.root.opts.placeholder.current.set({ year });
          let label;
          if (strict_equals(typeof yearFormat, "function")) {
            label = yearFormat(year);
          } else {
            label = this.root.formatter.custom(toDate(date), { year: yearFormat });
          }
          localYears.push({ value: year, label });
        }
        return localYears;
      }),
      "CalendarYearSelectState.yearItems"
    ));
    __privateAdd(this, _currentYear, tag(user_derived(() => this.root.opts.placeholder.current.year), "CalendarYearSelectState.currentYear"));
    __privateAdd(this, _isDisabled7, tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "CalendarYearSelectState.isDisabled"));
    __privateAdd(this, _snippetProps8, tag(
      user_derived(() => {
        return {
          yearItems: this.yearItems,
          selectedYearItem: this.yearItems.find((year) => strict_equals(year.value, this.currentYear))
        };
      }),
      "CalendarYearSelectState.snippetProps"
    ));
    __privateAdd(this, _props31, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        value: this.currentYear,
        disabled: this.isDisabled,
        "data-disabled": getDataDisabled(this.isDisabled),
        [this.root.getBitsAttr("year-select")]: "",
        //
        onchange: this.onchange,
        ...this.attachment
      })),
      "CalendarYearSelectState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CalendarYearSelectState(opts, CalendarRootContext.get());
  }
  get years() {
    return get(__privateGet(this, _years));
  }
  set years(value) {
    set(__privateGet(this, _years), value);
  }
  get yearItems() {
    return get(__privateGet(this, _yearItems));
  }
  set yearItems(value) {
    set(__privateGet(this, _yearItems), value);
  }
  get currentYear() {
    return get(__privateGet(this, _currentYear));
  }
  set currentYear(value) {
    set(__privateGet(this, _currentYear), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled7));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled7), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps8));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps8), value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const year = parseInt(target.value, 10);
    if (!isNaN(year)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year });
    }
  }
  get props() {
    return get(__privateGet(this, _props31));
  }
  set props(value) {
    set(__privateGet(this, _props31), value);
  }
};
_years = new WeakMap();
_yearItems = new WeakMap();
_currentYear = new WeakMap();
_isDisabled7 = new WeakMap();
_snippetProps8 = new WeakMap();
_props31 = new WeakMap();
var CalendarYearSelectState = _CalendarYearSelectState;

// node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte
Calendar[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte";
var root_214 = add_locations(from_html(`<div><!></div>`), Calendar[FILENAME], [[128, 1]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "type",
      "disableDaysOutsideMonth",
      "initialFocus",
      "maxDays",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  const defaultPlaceholder = getDefaultDate({ defaultValue: value() });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? void 0 : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = CalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    weekdayFormat: box.with(() => weekdayFormat()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    pagedNavigation: box.with(() => pagedNavigation()),
    isDateDisabled: box.with(() => isDateDisabled()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: box.with(() => calendarLabel()),
    readonly: box.with(() => readonly()),
    disabled: box.with(() => disabled()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    initialFocus: box.with(() => initialFocus()),
    maxDays: box.with(() => $$props.maxDays),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    preventDeselect: box.with(() => preventDeselect()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    type: box.with(() => $$props.type),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_214();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module.default[HMR].original);
  });
}
var calendar_default = Calendar;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte
Calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte";
var root_215 = add_locations(from_html(`<div><!></div>`), Calendar_day[FILENAME], [[34, 1]]);
function Calendar_day($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_day);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const dayState = CalendarDayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, dayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_215();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_day = hmr(Calendar_day, () => Calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_day[HMR].source;
    set(Calendar_day[HMR].source, module.default[HMR].original);
  });
}
var calendar_day_default = Calendar_day;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte
Calendar_grid[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte";
var root_216 = add_locations(from_html(`<table><!></table>`), Calendar_grid[FILENAME], [[31, 1]]);
function Calendar_grid($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridState = CalendarGridState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var table = root_216();
      attribute_effect(table, () => ({ ...get(mergedProps) }));
      var node_2 = child(table);
      snippet(node_2, () => $$props.children ?? noop);
      reset(table);
      append($$anchor2, table);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid = hmr(Calendar_grid, () => Calendar_grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid[HMR].source;
    set(Calendar_grid[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_default = Calendar_grid;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte
Calendar_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte";
var root_217 = add_locations(from_html(`<tbody><!></tbody>`), Calendar_grid_body[FILENAME], [[31, 1]]);
function Calendar_grid_body($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_body);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridBodyState = CalendarGridBodyState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridBodyState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tbody = root_217();
      attribute_effect(tbody, () => ({ ...get(mergedProps) }));
      var node_2 = child(tbody);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tbody);
      append($$anchor2, tbody);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_body = hmr(Calendar_grid_body, () => Calendar_grid_body[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_body[HMR].source;
    set(Calendar_grid_body[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_body_default = Calendar_grid_body;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte
Calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte";
var root_218 = add_locations(from_html(`<td><!></td>`), Calendar_cell[FILENAME], [[38, 1]]);
function Calendar_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = CalendarCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_218();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      append($$anchor2, td);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_cell = hmr(Calendar_cell, () => Calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_cell[HMR].source;
    set(Calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_cell_default = Calendar_cell;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte
Calendar_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte";
var root_219 = add_locations(from_html(`<thead><!></thead>`), Calendar_grid_head[FILENAME], [[31, 1]]);
function Calendar_grid_head($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_head);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridHeadState = CalendarGridHeadState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridHeadState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var thead = root_219();
      attribute_effect(thead, () => ({ ...get(mergedProps) }));
      var node_2 = child(thead);
      snippet(node_2, () => $$props.children ?? noop);
      reset(thead);
      append($$anchor2, thead);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_head = hmr(Calendar_grid_head, () => Calendar_grid_head[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_head[HMR].source;
    set(Calendar_grid_head[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_head_default = Calendar_grid_head;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte
Calendar_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte";
var root_220 = add_locations(from_html(`<th><!></th>`), Calendar_head_cell[FILENAME], [[31, 1]]);
function Calendar_head_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_head_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headCellState = CalendarHeadCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headCellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var th = root_220();
      attribute_effect(th, () => ({ ...get(mergedProps) }));
      var node_2 = child(th);
      snippet(node_2, () => $$props.children ?? noop);
      reset(th);
      append($$anchor2, th);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_head_cell = hmr(Calendar_head_cell, () => Calendar_head_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_head_cell[HMR].source;
    set(Calendar_head_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_head_cell_default = Calendar_head_cell;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte
Calendar_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte";
var root_221 = add_locations(from_html(`<tr><!></tr>`), Calendar_grid_row[FILENAME], [[31, 1]]);
function Calendar_grid_row($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_row);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridRowState = CalendarGridRowState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridRowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tr = root_221();
      attribute_effect(tr, () => ({ ...get(mergedProps) }));
      var node_2 = child(tr);
      snippet(node_2, () => $$props.children ?? noop);
      reset(tr);
      append($$anchor2, tr);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_row = hmr(Calendar_grid_row, () => Calendar_grid_row[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_row[HMR].source;
    set(Calendar_grid_row[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_row_default = Calendar_grid_row;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte
Calendar_header[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte";
var root_222 = add_locations(from_html(`<header><!></header>`), Calendar_header[FILENAME], [[31, 1]]);
function Calendar_header($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_header);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headerState = CalendarHeaderState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var header = root_222();
      attribute_effect(header, () => ({ ...get(mergedProps) }));
      var node_2 = child(header);
      snippet(node_2, () => $$props.children ?? noop);
      reset(header);
      append($$anchor2, header);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_header = hmr(Calendar_header, () => Calendar_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_header[HMR].source;
    set(Calendar_header[HMR].source, module.default[HMR].original);
  });
}
var calendar_header_default = Calendar_header;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte
Calendar_heading[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte";
var root_223 = add_locations(from_html(`<div><!></div>`), Calendar_heading[FILENAME], [[31, 1]]);
function Calendar_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headingState = CalendarHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        headingValue: headingState.root.headingValue
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_223();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => ({ headingValue: headingState.root.headingValue }));
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, headingState.root.headingValue));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_heading = hmr(Calendar_heading, () => Calendar_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_heading[HMR].source;
    set(Calendar_heading[HMR].source, module.default[HMR].original);
  });
}
var calendar_heading_default = Calendar_heading;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-month-select.svelte
Calendar_month_select[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-month-select.svelte";
var root_5 = add_locations(from_html(`<option> </option>`), Calendar_month_select[FILENAME], [[45, 4]]);
var root_224 = add_locations(from_html(`<select><!></select>`), Calendar_month_select[FILENAME], [[40, 1]]);
function Calendar_month_select($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_month_select);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), months = prop($$props, "months", 19, () => [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12
  ]), monthFormat = prop($$props, "monthFormat", 3, "long"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a month"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "months",
      "monthFormat",
      "disabled",
      "aria-label"
    ],
    "restProps"
  );
  const monthSelectState = CalendarMonthSelectState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    months: box.with(() => months()),
    monthFormat: box.with(() => monthFormat()),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, monthSelectState.props, { "aria-label": ariaLabel() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...monthSelectState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_224();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => monthSelectState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => monthSelectState.monthItems, (month) => month.value);
          each(node_4, 17, () => monthSelectState.monthItems, (month) => month.value, ($$anchor4, month) => {
            var option = root_5();
            var option_value = {};
            var text2 = child(option, true);
            reset(option);
            template_effect(() => {
              if (option_value !== (option_value = get(month).value)) {
                option.value = (option.__value = get(month).value) ?? "";
              }
              set_selected(option, strict_equals(get(month).value, monthSelectState.currentMonth));
              set_text(text2, get(month).label);
            });
            append($$anchor4, option);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(select);
      append($$anchor2, select);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_month_select = hmr(Calendar_month_select, () => Calendar_month_select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_month_select[HMR].source;
    set(Calendar_month_select[HMR].source, module.default[HMR].original);
  });
}
var calendar_month_select_default = Calendar_month_select;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte
Calendar_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte";
var root_225 = add_locations(from_html(`<button><!></button>`), Calendar_next_button[FILENAME], [[33, 1]]);
function Calendar_next_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_next_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const nextButtonState = CalendarNextButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, nextButtonState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_225();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_next_button = hmr(Calendar_next_button, () => Calendar_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_next_button[HMR].source;
    set(Calendar_next_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_next_button_default = Calendar_next_button;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte
Calendar_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte";
var root_226 = add_locations(from_html(`<button><!></button>`), Calendar_prev_button[FILENAME], [[33, 1]]);
function Calendar_prev_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_prev_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const prevButtonState = CalendarPrevButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, prevButtonState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_226();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_prev_button = hmr(Calendar_prev_button, () => Calendar_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_prev_button[HMR].source;
    set(Calendar_prev_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_prev_button_default = Calendar_prev_button;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-year-select.svelte
Calendar_year_select[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-year-select.svelte";
var root_52 = add_locations(from_html(`<option> </option>`), Calendar_year_select[FILENAME], [[45, 4]]);
var root_227 = add_locations(from_html(`<select><!></select>`), Calendar_year_select[FILENAME], [[40, 1]]);
function Calendar_year_select($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_year_select);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), yearFormat = prop($$props, "yearFormat", 3, "numeric"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a year"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "years",
      "yearFormat",
      "disabled",
      "aria-label"
    ],
    "restProps"
  );
  const yearSelectState = CalendarYearSelectState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    years: box.with(() => $$props.years),
    yearFormat: box.with(() => yearFormat()),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, yearSelectState.props, { "aria-label": ariaLabel() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...yearSelectState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var select = root_227();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => yearSelectState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => yearSelectState.yearItems, (year) => year.value);
          each(node_4, 17, () => yearSelectState.yearItems, (year) => year.value, ($$anchor4, year) => {
            var option = root_52();
            var option_value = {};
            var text2 = child(option, true);
            reset(option);
            template_effect(() => {
              if (option_value !== (option_value = get(year).value)) {
                option.value = (option.__value = get(year).value) ?? "";
              }
              set_selected(option, strict_equals(get(year).value, yearSelectState.currentYear));
              set_text(text2, get(year).label);
            });
            append($$anchor4, option);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(select);
      append($$anchor2, select);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_year_select = hmr(Calendar_year_select, () => Calendar_year_select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_year_select[HMR].source;
    set(Calendar_year_select[HMR].source, module.default[HMR].original);
  });
}
var calendar_year_select_default = Calendar_year_select;

// node_modules/bits-ui/dist/bits/checkbox/exports.js
var exports_exports7 = {};
__export(exports_exports7, {
  Group: () => checkbox_group_default,
  GroupLabel: () => checkbox_group_label_default,
  Root: () => checkbox_default
});

// node_modules/bits-ui/dist/bits/checkbox/checkbox.svelte.js
var checkboxAttrs = createBitsAttrs({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
});
var CheckboxGroupContext = new Context("Checkbox.Group");
var _labelId, _props32;
var _CheckboxGroupState = class _CheckboxGroupState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _labelId, tag(state(void 0), "CheckboxGroupState.labelId"));
    __privateAdd(this, _props32, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        "aria-labelledby": this.labelId,
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        [checkboxAttrs.group]: "",
        ...this.attachment
      })),
      "CheckboxGroupState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CheckboxGroupContext.set(new _CheckboxGroupState(opts));
  }
  get labelId() {
    return get(__privateGet(this, _labelId));
  }
  set labelId(value) {
    set(__privateGet(this, _labelId), value, true);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [
        ...snapshot(this.opts.value.current),
        checkboxValue
      ];
      this.opts.value.current = newValue;
      if (arraysAreEqual(this.opts.value.current, newValue)) return;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (strict_equals(index, -1)) return;
    const newValue = this.opts.value.current.filter((v) => strict_equals(v, checkboxValue, false));
    this.opts.value.current = newValue;
    if (arraysAreEqual(this.opts.value.current, newValue)) return;
    this.opts.onValueChange.current(newValue);
  }
  get props() {
    return get(__privateGet(this, _props32));
  }
  set props(value) {
    set(__privateGet(this, _props32), value);
  }
};
_labelId = new WeakMap();
_props32 = new WeakMap();
var CheckboxGroupState = _CheckboxGroupState;
var _props33;
var _CheckboxGroupLabelState = class _CheckboxGroupLabelState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props33, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.group.opts.disabled.current),
        [checkboxAttrs["group-label"]]: "",
        ...this.attachment
      })),
      "CheckboxGroupLabelState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.group.labelId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.group.labelId = id;
    });
  }
  static create(opts) {
    return new _CheckboxGroupLabelState(opts, CheckboxGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props33));
  }
  set props(value) {
    set(__privateGet(this, _props33), value);
  }
};
_props33 = new WeakMap();
var CheckboxGroupLabelState = _CheckboxGroupLabelState;
var CheckboxRootContext = new Context("Checkbox.Root");
var _trueName, _trueRequired, _trueDisabled, _CheckboxRootState_instances, toggle_fn, _snippetProps9, _props34;
var _CheckboxRootState = class _CheckboxRootState {
  constructor(opts, group) {
    __privateAdd(this, _CheckboxRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "group");
    __privateAdd(this, _trueName, tag(
      user_derived(() => {
        if (this.group && this.group.opts.name.current) {
          return this.group.opts.name.current;
        } else {
          return this.opts.name.current;
        }
      }),
      "CheckboxRootState.trueName"
    ));
    __privateAdd(this, _trueRequired, tag(
      user_derived(() => {
        if (this.group && this.group.opts.required.current) {
          return true;
        }
        return this.opts.required.current;
      }),
      "CheckboxRootState.trueRequired"
    ));
    __privateAdd(this, _trueDisabled, tag(
      user_derived(() => {
        if (this.group && this.group.opts.disabled.current) {
          return true;
        }
        return this.opts.disabled.current;
      }),
      "CheckboxRootState.trueDisabled"
    ));
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps9, tag(
      user_derived(() => ({
        checked: this.opts.checked.current,
        indeterminate: this.opts.indeterminate.current
      })),
      "CheckboxRootState.snippetProps"
    ));
    __privateAdd(this, _props34, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "checkbox",
        type: this.opts.type.current,
        disabled: this.trueDisabled,
        "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
        "aria-required": getAriaRequired(this.trueRequired),
        "data-disabled": getDataDisabled(this.trueDisabled),
        "data-state": getCheckboxDataState(this.opts.checked.current, this.opts.indeterminate.current),
        [checkboxAttrs.root]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "CheckboxRootState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    watch.pre(
      [
        () => {
          var _a;
          return snapshot((_a = this.group) == null ? void 0 : _a.opts.value.current);
        },
        () => this.opts.value.current
      ],
      ([groupValue, value]) => {
        if (!groupValue || !value) return;
        this.opts.checked.current = groupValue.includes(value);
      }
    );
    watch.pre(() => this.opts.checked.current, (checked) => {
      var _a, _b;
      if (!this.group) return;
      if (checked) {
        (_a = this.group) == null ? void 0 : _a.addValue(this.opts.value.current);
      } else {
        (_b = this.group) == null ? void 0 : _b.removeValue(this.opts.value.current);
      }
    });
  }
  static create(opts, group = null) {
    return CheckboxRootContext.set(new _CheckboxRootState(opts, group));
  }
  get trueName() {
    return get(__privateGet(this, _trueName));
  }
  set trueName(value) {
    set(__privateGet(this, _trueName), value);
  }
  get trueRequired() {
    return get(__privateGet(this, _trueRequired));
  }
  set trueRequired(value) {
    set(__privateGet(this, _trueRequired), value);
  }
  get trueDisabled() {
    return get(__privateGet(this, _trueDisabled));
  }
  set trueDisabled(value) {
    set(__privateGet(this, _trueDisabled), value);
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER)) e.preventDefault();
    if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      __privateMethod(this, _CheckboxRootState_instances, toggle_fn).call(this);
    }
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _CheckboxRootState_instances, toggle_fn).call(this);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps9));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps9), value);
  }
  get props() {
    return get(__privateGet(this, _props34));
  }
  set props(value) {
    set(__privateGet(this, _props34), value);
  }
};
_trueName = new WeakMap();
_trueRequired = new WeakMap();
_trueDisabled = new WeakMap();
_CheckboxRootState_instances = new WeakSet();
toggle_fn = function() {
  if (this.opts.indeterminate.current) {
    this.opts.indeterminate.current = false;
    this.opts.checked.current = true;
  } else {
    this.opts.checked.current = !this.opts.checked.current;
  }
};
_snippetProps9 = new WeakMap();
_props34 = new WeakMap();
var CheckboxRootState = _CheckboxRootState;
var _trueChecked, _shouldRender, _props35;
var _CheckboxInputState = class _CheckboxInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _trueChecked, tag(
      user_derived(() => {
        if (!this.root.group) return this.root.opts.checked.current;
        if (strict_equals(this.root.opts.value.current, void 0, false) && this.root.group.opts.value.current.includes(this.root.opts.value.current)) {
          return true;
        }
        return false;
      }),
      "CheckboxInputState.trueChecked"
    ));
    __privateAdd(this, _shouldRender, tag(user_derived(() => Boolean(this.root.trueName)), "CheckboxInputState.shouldRender"));
    __privateAdd(this, _props35, tag(
      user_derived(() => ({
        type: "checkbox",
        checked: strict_equals(this.root.opts.checked.current, true),
        disabled: this.root.trueDisabled,
        required: this.root.trueRequired,
        name: this.root.trueName,
        value: this.root.opts.value.current
      })),
      "CheckboxInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _CheckboxInputState(CheckboxRootContext.get());
  }
  get trueChecked() {
    return get(__privateGet(this, _trueChecked));
  }
  set trueChecked(value) {
    set(__privateGet(this, _trueChecked), value);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender), value);
  }
  get props() {
    return get(__privateGet(this, _props35));
  }
  set props(value) {
    set(__privateGet(this, _props35), value);
  }
};
_trueChecked = new WeakMap();
_shouldRender = new WeakMap();
_props35 = new WeakMap();
var CheckboxInputState = _CheckboxInputState;
function getCheckboxDataState(checked, indeterminate) {
  if (indeterminate) return "indeterminate";
  return checked ? "checked" : "unchecked";
}

// node_modules/bits-ui/dist/bits/utilities/hidden-input.svelte
Hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/hidden-input.svelte";
var root_1 = add_locations(from_html(`<input/>`), Hidden_input[FILENAME], [[17, 1]]);
var root_228 = add_locations(from_html(`<input/>`), Hidden_input[FILENAME], [[19, 1]]);
function Hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input);
  let value = prop($$props, "value", 15), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "value"], "restProps");
  const mergedProps = tag(
    user_derived(() => mergeProps(restProps, {
      "aria-hidden": "true",
      tabindex: -1,
      style: srOnlyStylesString
    })),
    "mergedProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var input = root_1();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps), value: value() }));
      append($$anchor2, input);
    };
    var alternate = ($$anchor2) => {
      var input_1 = root_228();
      remove_input_defaults(input_1);
      attribute_effect(input_1, () => ({ ...get(mergedProps) }));
      bind_value(input_1, value);
      append($$anchor2, input_1);
    };
    if_block(node, ($$render) => {
      if (strict_equals(get(mergedProps).type, "checkbox")) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Hidden_input = hmr(Hidden_input, () => Hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Hidden_input[HMR].source;
    set(Hidden_input[HMR].source, module.default[HMR].original);
  });
}
var hidden_input_default = Hidden_input;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte
Checkbox_input[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte";
function Checkbox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Checkbox_input);
  const inputState = CheckboxInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => inputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => inputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_input = hmr(Checkbox_input, () => Checkbox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_input[HMR].source;
    set(Checkbox_input[HMR].source, module.default[HMR].original);
  });
}
var checkbox_input_default = Checkbox_input;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte
Checkbox[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte";
var root_229 = add_locations(from_html(`<button><!></button>`), Checkbox[FILENAME], [[90, 1]]);
var root2 = add_locations(from_html(`<!> <!>`, 1), Checkbox[FILENAME], []);
function Checkbox($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox);
  let checked = prop($$props, "checked", 15, false), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), name = prop($$props, "name", 3, void 0), value = prop($$props, "value", 3, "on"), id = prop($$props, "id", 19, () => createId(uid)), indeterminate = prop($$props, "indeterminate", 15, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "checked",
      "ref",
      "onCheckedChange",
      "children",
      "disabled",
      "required",
      "name",
      "value",
      "id",
      "indeterminate",
      "onIndeterminateChange",
      "child",
      "type"
    ],
    "restProps"
  );
  const group = CheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const rootState = CheckboxRootState.create(
    {
      checked: box.with(() => checked(), (v) => {
        var _a;
        checked(v);
        (_a = $$props.onCheckedChange) == null ? void 0 : _a.call($$props, v);
      }),
      disabled: box.with(() => disabled() ?? false),
      required: box.with(() => required()),
      name: box.with(() => name()),
      value: box.with(() => value()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      indeterminate: box.with(() => indeterminate(), (v) => {
        var _a;
        indeterminate(v);
        (_a = $$props.onIndeterminateChange) == null ? void 0 : _a.call($$props, v);
      }),
      type: box.with(() => type())
    },
    group
  );
  const mergedProps = tag(user_derived(() => mergeProps({ ...restProps }, rootState.props)), "mergedProps");
  var fragment = root2();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_229();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  checkbox_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox = hmr(Checkbox, () => Checkbox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox[HMR].source;
    set(Checkbox[HMR].source, module.default[HMR].original);
  });
}
var checkbox_default = Checkbox;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group.svelte
Checkbox_group[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group.svelte";
var root_230 = add_locations(from_html(`<div><!></div>`), Checkbox_group[FILENAME], [[50, 1]]);
function Checkbox_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox_group);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), value = prop($$props, "value", 31, () => tag_proxy(proxy([]), "value")), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "value",
      "onValueChange",
      "name",
      "required",
      "disabled",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = CheckboxGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean($$props.disabled)),
    required: box.with(() => Boolean($$props.required)),
    name: box.with(() => $$props.name),
    value: box.with(() => snapshot(value()), (v) => {
      if (arraysAreEqual(value(), v)) return;
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: box.with(() => onValueChange())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_230();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_group = hmr(Checkbox_group, () => Checkbox_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_group[HMR].source;
    set(Checkbox_group[HMR].source, module.default[HMR].original);
  });
}
var checkbox_group_default = Checkbox_group;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group-label.svelte
Checkbox_group_label[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group-label.svelte";
var root_231 = add_locations(from_html(`<span><!></span>`), Checkbox_group_label[FILENAME], [[31, 1]]);
function Checkbox_group_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox_group_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const labelState = CheckboxGroupLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_231();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_group_label = hmr(Checkbox_group_label, () => Checkbox_group_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_group_label[HMR].source;
    set(Checkbox_group_label[HMR].source, module.default[HMR].original);
  });
}
var checkbox_group_label_default = Checkbox_group_label;

// node_modules/bits-ui/dist/bits/collapsible/exports.js
var exports_exports8 = {};
__export(exports_exports8, {
  Content: () => collapsible_content_default,
  Root: () => collapsible_default,
  Trigger: () => collapsible_trigger_default
});

// node_modules/bits-ui/dist/bits/collapsible/collapsible.svelte.js
var collapsibleAttrs = createBitsAttrs({
  component: "collapsible",
  parts: ["root", "content", "trigger"]
});
var CollapsibleRootContext = new Context("Collapsible.Root");
var _contentNode2, _contentId2, _props36;
var _CollapsibleRootState = class _CollapsibleRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _contentNode2, tag(state(null), "CollapsibleRootState.contentNode"));
    __privateAdd(this, _contentId2, tag(state(void 0), "CollapsibleRootState.contentId"));
    __privateAdd(this, _props36, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": getDataOpenClosed(this.opts.open.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        [collapsibleAttrs.root]: "",
        ...this.attachment
      })),
      "CollapsibleRootState.props"
    ));
    this.opts = opts;
    this.toggleOpen = this.toggleOpen.bind(this);
    this.attachment = attachRef(this.opts.ref);
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  static create(opts) {
    return CollapsibleRootContext.set(new _CollapsibleRootState(opts));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode2));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode2), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId2));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId2), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  get props() {
    return get(__privateGet(this, _props36));
  }
  set props(value) {
    set(__privateGet(this, _props36), value);
  }
};
_contentNode2 = new WeakMap();
_contentId2 = new WeakMap();
_props36 = new WeakMap();
var CollapsibleRootState = _CollapsibleRootState;
var _present, _originalStyles2, _isMountAnimationPrevented2, _width2, _height2, _snippetProps10, _props37;
var _CollapsibleContentState = class _CollapsibleContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _present, tag(user_derived(() => this.opts.forceMount.current || this.root.opts.open.current), "CollapsibleContentState.present"));
    __privateAdd(this, _originalStyles2);
    __privateAdd(this, _isMountAnimationPrevented2, tag(state(false), "CollapsibleContentState.#isMountAnimationPrevented"));
    __privateAdd(this, _width2, tag(state(0), "CollapsibleContentState.#width"));
    __privateAdd(this, _height2, tag(state(0), "CollapsibleContentState.#height"));
    __privateAdd(this, _snippetProps10, tag(user_derived(() => ({ open: this.root.opts.open.current })), "CollapsibleContentState.snippetProps"));
    __privateAdd(this, _props37, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: {
          "--bits-collapsible-content-height": get(__privateGet(this, _height2)) ? `${get(__privateGet(this, _height2))}px` : void 0,
          "--bits-collapsible-content-width": get(__privateGet(this, _width2)) ? `${get(__privateGet(this, _width2))}px` : void 0
        },
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        [collapsibleAttrs.content]: "",
        ...this.attachment
      })),
      "CollapsibleContentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    set(__privateGet(this, _isMountAnimationPrevented2), root18.opts.open.current, true);
    this.root.contentId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.contentId = id;
    });
    user_pre_effect(() => {
      const rAF = requestAnimationFrame(() => {
        set(__privateGet(this, _isMountAnimationPrevented2), false);
      });
      return () => {
        cancelAnimationFrame(rAF);
      };
    });
    watch(
      [
        () => this.opts.ref.current,
        () => this.present
      ],
      ([node]) => {
        if (!node) return;
        afterTick(() => {
          if (!this.opts.ref.current) return;
          __privateSet(this, _originalStyles2, __privateGet(this, _originalStyles2) || {
            transitionDuration: node.style.transitionDuration,
            animationName: node.style.animationName
          });
          node.style.transitionDuration = "0s";
          node.style.animationName = "none";
          const rect = node.getBoundingClientRect();
          set(__privateGet(this, _height2), rect.height, true);
          set(__privateGet(this, _width2), rect.width, true);
          if (!get(__privateGet(this, _isMountAnimationPrevented2))) {
            const { animationName, transitionDuration } = __privateGet(this, _originalStyles2);
            node.style.transitionDuration = transitionDuration;
            node.style.animationName = animationName;
          }
        });
      }
    );
  }
  static create(opts) {
    return new _CollapsibleContentState(opts, CollapsibleRootContext.get());
  }
  get present() {
    return get(__privateGet(this, _present));
  }
  set present(value) {
    set(__privateGet(this, _present), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps10));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps10), value);
  }
  get props() {
    return get(__privateGet(this, _props37));
  }
  set props(value) {
    set(__privateGet(this, _props37), value);
  }
};
_present = new WeakMap();
_originalStyles2 = new WeakMap();
_isMountAnimationPrevented2 = new WeakMap();
_width2 = new WeakMap();
_height2 = new WeakMap();
_snippetProps10 = new WeakMap();
_props37 = new WeakMap();
var CollapsibleContentState = _CollapsibleContentState;
var _isDisabled8, _props38;
var _CollapsibleTriggerState = class _CollapsibleTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled8, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "CollapsibleTriggerState.#isDisabled"));
    __privateAdd(this, _props38, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        type: "button",
        disabled: get(__privateGet(this, _isDisabled8)),
        "aria-controls": this.root.contentId,
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled8))),
        [collapsibleAttrs.trigger]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "CollapsibleTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _CollapsibleTriggerState(opts, CollapsibleRootContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled8))) return;
    if (strict_equals(e.button, 0, false)) return e.preventDefault();
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled8))) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.toggleOpen();
    }
  }
  get props() {
    return get(__privateGet(this, _props38));
  }
  set props(value) {
    set(__privateGet(this, _props38), value);
  }
};
_isDisabled8 = new WeakMap();
_props38 = new WeakMap();
var CollapsibleTriggerState = _CollapsibleTriggerState;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte
Collapsible[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte";
var root_232 = add_locations(from_html(`<div><!></div>`), Collapsible[FILENAME], [[45, 1]]);
function Collapsible($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), open = prop($$props, "open", 15, false), disabled = prop($$props, "disabled", 3, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "open",
      "disabled",
      "onOpenChange",
      "onOpenChangeComplete"
    ],
    "restProps"
  );
  const rootState = CollapsibleRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_232();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible = hmr(Collapsible, () => Collapsible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible[HMR].source;
    set(Collapsible[HMR].source, module.default[HMR].original);
  });
}
var collapsible_default = Collapsible;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte
Collapsible_content[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte";
var root_33 = add_locations(from_html(`<div><!></div>`), Collapsible_content[FILENAME], [[40, 3]]);
function Collapsible_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible_content);
  let ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "forceMount",
      "children",
      "id"
    ],
    "restProps"
  );
  const contentState = CollapsibleContentState.create({
    id: box.with(() => id()),
    forceMount: box.with(() => forceMount()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Collapsible_content, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      const mergedProps = user_derived(() => mergeProps(restProps, contentState.props, {
        hidden: forceMount() ? void 0 : !present()
      }));
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          var render_arg = derived_safe_equal(() => ({
            ...contentState.snippetProps,
            props: get(mergedProps)
          }));
          snippet(node_2, () => $$props.child, () => get(render_arg));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_33();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      forceMount: true,
      get open() {
        return contentState.present;
      },
      get ref() {
        return contentState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_content = hmr(Collapsible_content, () => Collapsible_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_content[HMR].source;
    set(Collapsible_content[HMR].source, module.default[HMR].original);
  });
}
var collapsible_content_default = Collapsible_content;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte
Collapsible_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte";
var root_233 = add_locations(from_html(`<button><!></button>`), Collapsible_trigger[FILENAME], [[33, 1]]);
function Collapsible_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = CollapsibleTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_233();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_trigger = hmr(Collapsible_trigger, () => Collapsible_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_trigger[HMR].source;
    set(Collapsible_trigger[HMR].source, module.default[HMR].original);
  });
}
var collapsible_trigger_default = Collapsible_trigger;

// node_modules/bits-ui/dist/bits/combobox/exports.js
var exports_exports9 = {};
__export(exports_exports9, {
  Arrow: () => arrow_default,
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Input: () => combobox_input_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => combobox_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Separator: () => separator_default,
  Trigger: () => combobox_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js
function get3(valueOrGetValue) {
  return strict_equals(typeof valueOrGetValue, "function") ? valueOrGetValue() : valueOrGetValue;
}
function getDPR(element2) {
  if (strict_equals(typeof window, "undefined")) return 1;
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function getFloatingContentCSSVars(name) {
  return {
    [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,
    [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,
    [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,
    [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,
    [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`
  };
}

// node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js
function useFloating(options) {
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = tag(user_derived(() => get3(options.open) ?? true), "openOption");
  const middlewareOption = tag(user_derived(() => get3(options.middleware)), "middlewareOption");
  const transformOption = tag(user_derived(() => get3(options.transform) ?? true), "transformOption");
  const placementOption = tag(user_derived(() => get3(options.placement) ?? "bottom"), "placementOption");
  const strategyOption = tag(user_derived(() => get3(options.strategy) ?? "absolute"), "strategyOption");
  const sideOffsetOption = tag(user_derived(() => get3(options.sideOffset) ?? 0), "sideOffsetOption");
  const alignOffsetOption = tag(user_derived(() => get3(options.alignOffset) ?? 0), "alignOffsetOption");
  const reference = options.reference;
  let x = tag(state(0), "x");
  let y = tag(state(0), "y");
  const floating = box(null);
  let strategy = tag(state(proxy(get(strategyOption))), "strategy");
  let placement = tag(state(proxy(get(placementOption))), "placement");
  let middlewareData = tag(state(proxy({})), "middlewareData");
  let isPositioned = tag(state(false), "isPositioned");
  const floatingStyles = tag(
    user_derived(() => {
      const xVal = floating.current ? roundByDPR(floating.current, get(x)) : get(x);
      const yVal = floating.current ? roundByDPR(floating.current, get(y)) : get(y);
      if (get(transformOption)) {
        return {
          position: get(strategy),
          left: "0",
          top: "0",
          transform: `translate(${xVal}px, ${yVal}px)`,
          ...floating.current && getDPR(floating.current) >= 1.5 && { willChange: "transform" }
        };
      }
      return {
        position: get(strategy),
        left: `${xVal}px`,
        top: `${yVal}px`
      };
    }),
    "floatingStyles"
  );
  let whileElementsMountedCleanup;
  function update() {
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    computePosition(reference.current, floating.current, {
      middleware: get(middlewareOption),
      placement: get(placementOption),
      strategy: get(strategyOption)
    }).then((position) => {
      if (!get(openOption) && strict_equals(get(x), 0, false) && strict_equals(get(y), 0, false)) {
        const maxExpectedOffset = Math.max(Math.abs(get(sideOffsetOption)), Math.abs(get(alignOffsetOption)), 15);
        if (position.x <= maxExpectedOffset && position.y <= maxExpectedOffset) return;
      }
      set(x, position.x, true);
      set(y, position.y, true);
      set(strategy, position.strategy, true);
      set(placement, position.placement, true);
      set(middlewareData, position.middlewareData, true);
      set(isPositioned, true);
    });
  }
  function cleanup() {
    if (strict_equals(typeof whileElementsMountedCleanup, "function")) {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (strict_equals(whileElementsMountedOption, void 0)) {
      update();
      return;
    }
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update);
  }
  function reset2() {
    if (!get(openOption)) {
      set(isPositioned, false);
    }
  }
  user_effect(update);
  user_effect(attach);
  user_effect(reset2);
  user_effect(() => cleanup);
  return {
    floating,
    reference,
    get strategy() {
      return get(strategy);
    },
    get placement() {
      return get(placement);
    },
    get middlewareData() {
      return get(middlewareData);
    },
    get isPositioned() {
      return get(isPositioned);
    },
    get floatingStyles() {
      return get(floatingStyles);
    },
    get update() {
      return update;
    }
  };
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/use-floating-layer.svelte.js
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var FloatingRootContext = new Context("Floating.Root");
var FloatingContentContext = new Context("Floating.Content");
var FloatingTooltipRootContext = new Context("Floating.Root");
var FloatingRootState = class _FloatingRootState {
  constructor() {
    __publicField(this, "anchorNode", box(null));
    __publicField(this, "customAnchorNode", box(null));
    __publicField(this, "triggerNode", box(null));
    user_effect(() => {
      if (this.customAnchorNode.current) {
        if (strict_equals(typeof this.customAnchorNode.current, "string")) {
          this.anchorNode.current = document.querySelector(this.customAnchorNode.current);
        } else {
          this.anchorNode.current = this.customAnchorNode.current;
        }
      } else {
        this.anchorNode.current = this.triggerNode.current;
      }
    });
  }
  static create(tooltip = false) {
    return tooltip ? FloatingTooltipRootContext.set(new _FloatingRootState()) : FloatingRootContext.set(new _FloatingRootState());
  }
};
var _transformedStyle, _updatePositionStrategy, _arrowSize, _arrowWidth, _arrowHeight, _desiredPlacement, _boundary, _hasExplicitBoundaries, _detectOverflowOptions, _availableWidth, _availableHeight, _anchorWidth, _anchorHeight, _middleware, _placedSide, _placedAlign, _arrowX, _arrowY, _cannotCenterArrow, _contentZIndex, _arrowBaseSide, _wrapperProps, _props39, _arrowStyle;
var _FloatingContentState = class _FloatingContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    // nodes
    __publicField(this, "contentRef", box(null));
    __publicField(this, "wrapperRef", box(null));
    __publicField(this, "arrowRef", box(null));
    __publicField(this, "contentAttachment", attachRef(this.contentRef));
    __publicField(this, "wrapperAttachment", attachRef(this.wrapperRef));
    __publicField(this, "arrowAttachment", attachRef(this.arrowRef));
    // ids
    __publicField(this, "arrowId", box(useId()));
    __privateAdd(this, _transformedStyle, tag(
      user_derived(() => {
        if (strict_equals(typeof this.opts.style, "string")) return cssToStyleObj(this.opts.style);
        if (!this.opts.style) return {};
      }),
      "FloatingContentState.#transformedStyle"
    ));
    __privateAdd(this, _updatePositionStrategy);
    __privateAdd(this, _arrowSize, new ElementSize(() => this.arrowRef.current ?? void 0));
    __privateAdd(this, _arrowWidth, tag(user_derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.width) ?? 0;
    }), "FloatingContentState.#arrowWidth"));
    __privateAdd(this, _arrowHeight, tag(user_derived(() => {
      var _a;
      return ((_a = __privateGet(this, _arrowSize)) == null ? void 0 : _a.height) ?? 0;
    }), "FloatingContentState.#arrowHeight"));
    __privateAdd(this, _desiredPlacement, tag(user_derived(() => {
      var _a;
      return ((_a = this.opts.side) == null ? void 0 : _a.current) + (strict_equals(this.opts.align.current, "center", false) ? `-${this.opts.align.current}` : "");
    }), "FloatingContentState.#desiredPlacement"));
    __privateAdd(this, _boundary, tag(user_derived(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]), "FloatingContentState.#boundary"));
    __privateAdd(this, _hasExplicitBoundaries, tag(user_derived(() => get(__privateGet(this, _boundary)).length > 0), "FloatingContentState.hasExplicitBoundaries"));
    __privateAdd(this, _detectOverflowOptions, tag(
      user_derived(() => ({
        padding: this.opts.collisionPadding.current,
        boundary: get(__privateGet(this, _boundary)).filter(isNotNull),
        altBoundary: this.hasExplicitBoundaries
      })),
      "FloatingContentState.detectOverflowOptions"
    ));
    __privateAdd(this, _availableWidth, tag(state(void 0), "FloatingContentState.#availableWidth"));
    __privateAdd(this, _availableHeight, tag(state(void 0), "FloatingContentState.#availableHeight"));
    __privateAdd(this, _anchorWidth, tag(state(void 0), "FloatingContentState.#anchorWidth"));
    __privateAdd(this, _anchorHeight, tag(state(void 0), "FloatingContentState.#anchorHeight"));
    __privateAdd(this, _middleware, tag(
      user_derived(() => [
        offset({
          mainAxis: this.opts.sideOffset.current + get(__privateGet(this, _arrowHeight)),
          alignmentAxis: this.opts.alignOffset.current
        }),
        this.opts.avoidCollisions.current && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: strict_equals(this.opts.sticky.current, "partial") ? limitShift() : void 0,
          ...this.detectOverflowOptions
        }),
        this.opts.avoidCollisions.current && flip({ ...this.detectOverflowOptions }),
        size({
          ...this.detectOverflowOptions,
          apply: ({ rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            set(__privateGet(this, _availableWidth), availableWidth, true);
            set(__privateGet(this, _availableHeight), availableHeight, true);
            set(__privateGet(this, _anchorWidth), anchorWidth, true);
            set(__privateGet(this, _anchorHeight), anchorHeight, true);
          }
        }),
        this.arrowRef.current && arrow({
          element: this.arrowRef.current,
          padding: this.opts.arrowPadding.current
        }),
        transformOrigin({
          arrowWidth: get(__privateGet(this, _arrowWidth)),
          arrowHeight: get(__privateGet(this, _arrowHeight))
        }),
        this.opts.hideWhenDetached.current && hide({
          strategy: "referenceHidden",
          ...this.detectOverflowOptions
        })
      ].filter(Boolean)),
      "FloatingContentState.middleware"
    ));
    __publicField(this, "floating");
    __privateAdd(this, _placedSide, tag(user_derived(() => getSideFromPlacement(this.floating.placement)), "FloatingContentState.placedSide"));
    __privateAdd(this, _placedAlign, tag(user_derived(() => getAlignFromPlacement(this.floating.placement)), "FloatingContentState.placedAlign"));
    __privateAdd(this, _arrowX, tag(user_derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.x) ?? 0;
    }), "FloatingContentState.arrowX"));
    __privateAdd(this, _arrowY, tag(user_derived(() => {
      var _a;
      return ((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.y) ?? 0;
    }), "FloatingContentState.arrowY"));
    __privateAdd(this, _cannotCenterArrow, tag(user_derived(() => {
      var _a;
      return strict_equals((_a = this.floating.middlewareData.arrow) == null ? void 0 : _a.centerOffset, 0, false);
    }), "FloatingContentState.cannotCenterArrow"));
    __privateAdd(this, _contentZIndex, tag(state(), "FloatingContentState.contentZIndex"));
    __privateAdd(this, _arrowBaseSide, tag(user_derived(() => OPPOSITE_SIDE[this.placedSide]), "FloatingContentState.arrowBaseSide"));
    __privateAdd(this, _wrapperProps, tag(
      user_derived(() => {
        var _a, _b, _c;
        return {
          id: this.opts.wrapperId.current,
          "data-bits-floating-content-wrapper": "",
          style: {
            ...this.floating.floatingStyles,
            // keep off page when measuring
            transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: this.contentZIndex,
            "--bits-floating-transform-origin": `${(_a = this.floating.middlewareData.transformOrigin) == null ? void 0 : _a.x} ${(_b = this.floating.middlewareData.transformOrigin) == null ? void 0 : _b.y}`,
            "--bits-floating-available-width": `${get(__privateGet(this, _availableWidth))}px`,
            "--bits-floating-available-height": `${get(__privateGet(this, _availableHeight))}px`,
            "--bits-floating-anchor-width": `${get(__privateGet(this, _anchorWidth))}px`,
            "--bits-floating-anchor-height": `${get(__privateGet(this, _anchorHeight))}px`,
            // hide the content if using the hide middleware and should be hidden
            ...((_c = this.floating.middlewareData.hide) == null ? void 0 : _c.referenceHidden) && {
              visibility: "hidden",
              "pointer-events": "none"
            },
            ...get(__privateGet(this, _transformedStyle))
          },
          // Floating UI calculates logical alignment based the `dir` attribute
          dir: this.opts.dir.current,
          ...this.wrapperAttachment
        };
      }),
      "FloatingContentState.wrapperProps"
    ));
    __privateAdd(this, _props39, tag(
      user_derived(() => ({
        "data-side": this.placedSide,
        "data-align": this.placedAlign,
        style: styleToString({ ...get(__privateGet(this, _transformedStyle)) }),
        ...this.contentAttachment
      })),
      "FloatingContentState.props"
    ));
    __privateAdd(this, _arrowStyle, tag(
      user_derived(() => ({
        position: "absolute",
        left: this.arrowX ? `${this.arrowX}px` : void 0,
        top: this.arrowY ? `${this.arrowY}px` : void 0,
        [this.arrowBaseSide]: 0,
        "transform-origin": {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[this.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[this.placedSide],
        visibility: this.cannotCenterArrow ? "hidden" : void 0
      })),
      "FloatingContentState.arrowStyle"
    ));
    this.opts = opts;
    this.root = root18;
    if (opts.customAnchor) {
      this.root.customAnchorNode.current = opts.customAnchor.current;
    }
    watch(() => opts.customAnchor.current, (customAnchor) => {
      this.root.customAnchorNode.current = customAnchor;
    });
    this.floating = useFloating({
      strategy: () => this.opts.strategy.current,
      placement: () => get(__privateGet(this, _desiredPlacement)),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...args) => {
        var _a;
        const cleanup = autoUpdate(...args, {
          animationFrame: strict_equals((_a = __privateGet(this, _updatePositionStrategy)) == null ? void 0 : _a.current, "always")
        });
        return cleanup;
      },
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    });
    user_effect(() => {
      var _a;
      if (!this.floating.isPositioned) return;
      (_a = this.opts.onPlaced) == null ? void 0 : _a.current();
    });
    watch(() => this.contentRef.current, (contentNode) => {
      if (!contentNode) return;
      const win = getWindow(contentNode);
      this.contentZIndex = win.getComputedStyle(contentNode).zIndex;
    });
    user_effect(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
  static create(opts, tooltip = false) {
    return tooltip ? FloatingContentContext.set(new _FloatingContentState(opts, FloatingTooltipRootContext.get())) : FloatingContentContext.set(new _FloatingContentState(opts, FloatingRootContext.get()));
  }
  get hasExplicitBoundaries() {
    return get(__privateGet(this, _hasExplicitBoundaries));
  }
  set hasExplicitBoundaries(value) {
    set(__privateGet(this, _hasExplicitBoundaries), value);
  }
  get detectOverflowOptions() {
    return get(__privateGet(this, _detectOverflowOptions));
  }
  set detectOverflowOptions(value) {
    set(__privateGet(this, _detectOverflowOptions), value);
  }
  get middleware() {
    return get(__privateGet(this, _middleware));
  }
  set middleware(value) {
    set(__privateGet(this, _middleware), value);
  }
  get placedSide() {
    return get(__privateGet(this, _placedSide));
  }
  set placedSide(value) {
    set(__privateGet(this, _placedSide), value);
  }
  get placedAlign() {
    return get(__privateGet(this, _placedAlign));
  }
  set placedAlign(value) {
    set(__privateGet(this, _placedAlign), value);
  }
  get arrowX() {
    return get(__privateGet(this, _arrowX));
  }
  set arrowX(value) {
    set(__privateGet(this, _arrowX), value);
  }
  get arrowY() {
    return get(__privateGet(this, _arrowY));
  }
  set arrowY(value) {
    set(__privateGet(this, _arrowY), value);
  }
  get cannotCenterArrow() {
    return get(__privateGet(this, _cannotCenterArrow));
  }
  set cannotCenterArrow(value) {
    set(__privateGet(this, _cannotCenterArrow), value);
  }
  get contentZIndex() {
    return get(__privateGet(this, _contentZIndex));
  }
  set contentZIndex(value) {
    set(__privateGet(this, _contentZIndex), value, true);
  }
  get arrowBaseSide() {
    return get(__privateGet(this, _arrowBaseSide));
  }
  set arrowBaseSide(value) {
    set(__privateGet(this, _arrowBaseSide), value);
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps));
  }
  set wrapperProps(value) {
    set(__privateGet(this, _wrapperProps), value);
  }
  get props() {
    return get(__privateGet(this, _props39));
  }
  set props(value) {
    set(__privateGet(this, _props39), value);
  }
  get arrowStyle() {
    return get(__privateGet(this, _arrowStyle));
  }
  set arrowStyle(value) {
    set(__privateGet(this, _arrowStyle), value);
  }
};
_transformedStyle = new WeakMap();
_updatePositionStrategy = new WeakMap();
_arrowSize = new WeakMap();
_arrowWidth = new WeakMap();
_arrowHeight = new WeakMap();
_desiredPlacement = new WeakMap();
_boundary = new WeakMap();
_hasExplicitBoundaries = new WeakMap();
_detectOverflowOptions = new WeakMap();
_availableWidth = new WeakMap();
_availableHeight = new WeakMap();
_anchorWidth = new WeakMap();
_anchorHeight = new WeakMap();
_middleware = new WeakMap();
_placedSide = new WeakMap();
_placedAlign = new WeakMap();
_arrowX = new WeakMap();
_arrowY = new WeakMap();
_cannotCenterArrow = new WeakMap();
_contentZIndex = new WeakMap();
_arrowBaseSide = new WeakMap();
_wrapperProps = new WeakMap();
_props39 = new WeakMap();
_arrowStyle = new WeakMap();
var FloatingContentState = _FloatingContentState;
var _props40;
var _FloatingArrowState = class _FloatingArrowState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __privateAdd(this, _props40, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: this.content.arrowStyle,
        "data-side": this.content.placedSide,
        ...this.content.arrowAttachment
      })),
      "FloatingArrowState.props"
    ));
    this.opts = opts;
    this.content = content;
  }
  static create(opts) {
    return new _FloatingArrowState(opts, FloatingContentContext.get());
  }
  get props() {
    return get(__privateGet(this, _props40));
  }
  set props(value) {
    set(__privateGet(this, _props40), value);
  }
};
_props40 = new WeakMap();
var FloatingArrowState = _FloatingArrowState;
var FloatingAnchorState = class _FloatingAnchorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    this.opts = opts;
    this.root = root18;
    if (opts.virtualEl && opts.virtualEl.current) {
      root18.triggerNode = box.from(opts.virtualEl.current);
    } else {
      root18.triggerNode = opts.ref;
    }
  }
  static create(opts, tooltip = false) {
    return tooltip ? new _FloatingAnchorState(opts, FloatingTooltipRootContext.get()) : new _FloatingAnchorState(opts, FloatingRootContext.get());
  }
};
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      var _a, _b, _c;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = strict_equals((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset, 0, false);
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
      const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (strict_equals(placedSide, "bottom")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (strict_equals(placedSide, "top")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (strict_equals(placedSide, "right")) {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (strict_equals(placedSide, "left")) {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function getSideFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[0];
}
function getAlignFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[1];
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte
Floating_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte";
function Floating_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingRootState.create(tooltip());
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer = hmr(Floating_layer, () => Floating_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer[HMR].source;
    set(Floating_layer[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_default = Floating_layer;

// node_modules/bits-ui/dist/internal/box-auto-reset.svelte.js
var defaultOptions = { afterMs: 1e4, onChange: noop3 };
function boxAutoReset(defaultValue, options) {
  const { afterMs, onChange, getWindow: getWindow2 } = { ...defaultOptions, ...options };
  let timeout = null;
  let value = tag(state(proxy(defaultValue)), "value");
  function resetAfter() {
    return getWindow2().setTimeout(
      () => {
        set(value, defaultValue, true);
        onChange == null ? void 0 : onChange(defaultValue);
      },
      afterMs
    );
  }
  user_effect(() => {
    return () => {
      if (timeout) getWindow2().clearTimeout(timeout);
    };
  });
  return box.with(() => get(value), (v) => {
    set(value, v, true);
    onChange == null ? void 0 : onChange(v);
    if (timeout) getWindow2().clearTimeout(timeout);
    timeout = resetAfter();
  });
}

// node_modules/bits-ui/dist/internal/data-typeahead.svelte.js
var _opts5, _candidateValues, _search;
var DataTypeahead = class {
  constructor(opts) {
    __privateAdd(this, _opts5);
    __privateAdd(this, _candidateValues, tag(user_derived(() => __privateGet(this, _opts5).candidateValues()), "DataTypeahead.#candidateValues"));
    __privateAdd(this, _search);
    __privateSet(this, _opts5, opts);
    __privateSet(this, _search, boxAutoReset("", {
      afterMs: 1e3,
      getWindow: __privateGet(this, _opts5).getWindow
    }));
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key) {
    if (!__privateGet(this, _opts5).enabled() || !get(__privateGet(this, _candidateValues)).length) return;
    __privateGet(this, _search).current = __privateGet(this, _search).current + key;
    const currentItem = __privateGet(this, _opts5).getCurrentItem();
    const currentMatch = get(__privateGet(this, _candidateValues)).find((item) => strict_equals(item, currentItem)) ?? "";
    const values = get(__privateGet(this, _candidateValues)).map((item) => item ?? "");
    const nextMatch = getNextMatch(values, __privateGet(this, _search).current, currentMatch);
    const newItem = get(__privateGet(this, _candidateValues)).find((item) => strict_equals(item, nextMatch));
    if (newItem) {
      __privateGet(this, _opts5).onMatch(newItem);
    }
    return newItem;
  }
  resetTypeahead() {
    __privateGet(this, _search).current = "";
  }
};
_opts5 = new WeakMap();
_candidateValues = new WeakMap();
_search = new WeakMap();

// node_modules/bits-ui/dist/internal/dom-typeahead.svelte.js
var _opts6, _search2, _onMatch, _getCurrentItem;
var DOMTypeahead = class {
  constructor(opts) {
    __privateAdd(this, _opts6);
    __privateAdd(this, _search2);
    __privateAdd(this, _onMatch, tag(
      user_derived(() => {
        if (__privateGet(this, _opts6).onMatch) return __privateGet(this, _opts6).onMatch;
        return (node) => node.focus();
      }),
      "DOMTypeahead.#onMatch"
    ));
    __privateAdd(this, _getCurrentItem, tag(
      user_derived(() => {
        if (__privateGet(this, _opts6).getCurrentItem) return __privateGet(this, _opts6).getCurrentItem;
        return __privateGet(this, _opts6).getActiveElement;
      }),
      "DOMTypeahead.#getCurrentItem"
    ));
    __privateSet(this, _opts6, opts);
    __privateSet(this, _search2, boxAutoReset("", { afterMs: 1e3, getWindow: opts.getWindow }));
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key, candidates) {
    var _a, _b;
    if (!candidates.length) return;
    __privateGet(this, _search2).current = __privateGet(this, _search2).current + key;
    const currentItem = get(__privateGet(this, _getCurrentItem))();
    const currentMatch = ((_b = (_a = candidates.find((item) => strict_equals(item, currentItem))) == null ? void 0 : _a.textContent) == null ? void 0 : _b.trim()) ?? "";
    const values = candidates.map((item) => {
      var _a2;
      return ((_a2 = item.textContent) == null ? void 0 : _a2.trim()) ?? "";
    });
    const nextMatch = getNextMatch(values, __privateGet(this, _search2).current, currentMatch);
    const newItem = candidates.find((item) => {
      var _a2;
      return strict_equals((_a2 = item.textContent) == null ? void 0 : _a2.trim(), nextMatch);
    });
    if (newItem) get(__privateGet(this, _onMatch))(newItem);
    return newItem;
  }
  resetTypeahead() {
    __privateGet(this, _search2).current = "";
  }
  get search() {
    return __privateGet(this, _search2).current;
  }
};
_opts6 = new WeakMap();
_search2 = new WeakMap();
_onMatch = new WeakMap();
_getCurrentItem = new WeakMap();

// node_modules/bits-ui/dist/bits/select/select.svelte.js
var INTERACTION_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ESCAPE,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.SHIFT,
  kbd_constants_exports.CAPS_LOCK,
  kbd_constants_exports.CONTROL,
  kbd_constants_exports.ALT,
  kbd_constants_exports.META,
  kbd_constants_exports.ENTER,
  kbd_constants_exports.F1,
  kbd_constants_exports.F2,
  kbd_constants_exports.F3,
  kbd_constants_exports.F4,
  kbd_constants_exports.F5,
  kbd_constants_exports.F6,
  kbd_constants_exports.F7,
  kbd_constants_exports.F8,
  kbd_constants_exports.F9,
  kbd_constants_exports.F10,
  kbd_constants_exports.F11,
  kbd_constants_exports.F12
];
var FIRST_KEYS2 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS2 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS2 = [...FIRST_KEYS2, ...LAST_KEYS2];
var SELECTION_KEYS2 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var selectAttrs = createBitsAttrs({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
});
var SelectRootContext = new Context("Select.Root | Combobox.Root");
var SelectGroupContext = new Context("Select.Group | Combobox.Group");
var SelectContentContext = new Context("Select.Content | Combobox.Content");
var _touchedInput, _inputNode, _contentNode3, _triggerNode2, _valueId, _highlightedNode, _highlightedValue, _highlightedId, _highlightedLabel;
var SelectBaseRootState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _touchedInput, tag(state(false), "SelectBaseRootState.touchedInput"));
    __privateAdd(this, _inputNode, tag(state(null), "SelectBaseRootState.inputNode"));
    __privateAdd(this, _contentNode3, tag(state(null), "SelectBaseRootState.contentNode"));
    __privateAdd(this, _triggerNode2, tag(state(null), "SelectBaseRootState.triggerNode"));
    __privateAdd(this, _valueId, tag(state(""), "SelectBaseRootState.valueId"));
    __privateAdd(this, _highlightedNode, tag(state(null), "SelectBaseRootState.highlightedNode"));
    __privateAdd(this, _highlightedValue, tag(
      user_derived(() => {
        if (!this.highlightedNode) return null;
        return this.highlightedNode.getAttribute("data-value");
      }),
      "SelectBaseRootState.highlightedValue"
    ));
    __privateAdd(this, _highlightedId, tag(
      user_derived(() => {
        if (!this.highlightedNode) return void 0;
        return this.highlightedNode.id;
      }),
      "SelectBaseRootState.highlightedId"
    ));
    __privateAdd(this, _highlightedLabel, tag(
      user_derived(() => {
        if (!this.highlightedNode) return null;
        return this.highlightedNode.getAttribute("data-label");
      }),
      "SelectBaseRootState.highlightedLabel"
    ));
    __publicField(this, "isUsingKeyboard", false);
    __publicField(this, "isCombobox", false);
    __publicField(this, "domContext", new DOMContext(() => null));
    __publicField(this, "getBitsAttr", (part) => {
      return selectAttrs.getAttr(part, this.isCombobox ? "combobox" : void 0);
    });
    this.opts = opts;
    this.isCombobox = opts.isCombobox;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    user_pre_effect(() => {
      if (!this.opts.open.current) {
        this.setHighlightedNode(null);
      }
    });
  }
  get touchedInput() {
    return get(__privateGet(this, _touchedInput));
  }
  set touchedInput(value) {
    set(__privateGet(this, _touchedInput), value, true);
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode3));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode3), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode2));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode2), value, true);
  }
  get valueId() {
    return get(__privateGet(this, _valueId));
  }
  set valueId(value) {
    set(__privateGet(this, _valueId), value, true);
  }
  get highlightedNode() {
    return get(__privateGet(this, _highlightedNode));
  }
  set highlightedNode(value) {
    set(__privateGet(this, _highlightedNode), value, true);
  }
  get highlightedValue() {
    return get(__privateGet(this, _highlightedValue));
  }
  set highlightedValue(value) {
    set(__privateGet(this, _highlightedValue), value);
  }
  get highlightedId() {
    return get(__privateGet(this, _highlightedId));
  }
  set highlightedId(value) {
    set(__privateGet(this, _highlightedId), value);
  }
  get highlightedLabel() {
    return get(__privateGet(this, _highlightedLabel));
  }
  set highlightedLabel(value) {
    set(__privateGet(this, _highlightedLabel), value);
  }
  setHighlightedNode(node, initial = false) {
    this.highlightedNode = node;
    if (node && (this.isUsingKeyboard || initial)) {
      node.scrollIntoView({ block: this.opts.scrollAlignment.current });
    }
  }
  getCandidateNodes() {
    const node = this.contentNode;
    if (!node) return [];
    return Array.from(node.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`));
  }
  setHighlightedToFirstCandidate() {
    this.setHighlightedNode(null);
    const candidateNodes = this.getCandidateNodes();
    if (!candidateNodes.length) return;
    this.setHighlightedNode(candidateNodes[0]);
  }
  getNodeByValue(value) {
    const candidateNodes = this.getCandidateNodes();
    return candidateNodes.find((node) => strict_equals(node.dataset.value, value)) ?? null;
  }
  setOpen(open) {
    this.opts.open.current = open;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(true);
  }
  handleClose() {
    this.setHighlightedNode(null);
    this.setOpen(false);
  }
  toggleMenu() {
    this.toggleOpen();
  }
};
_touchedInput = new WeakMap();
_inputNode = new WeakMap();
_contentNode3 = new WeakMap();
_triggerNode2 = new WeakMap();
_valueId = new WeakMap();
_highlightedNode = new WeakMap();
_highlightedValue = new WeakMap();
_highlightedId = new WeakMap();
_highlightedLabel = new WeakMap();
var _hasValue, _currentLabel, _candidateLabels, _dataTypeaheadEnabled;
var SelectSingleRootState = class extends SelectBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _hasValue, tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "SelectSingleRootState.hasValue"));
    __privateAdd(this, _currentLabel, tag(
      user_derived(() => {
        var _a;
        if (!this.opts.items.current.length) return "";
        const match = (_a = this.opts.items.current.find((item) => strict_equals(item.value, this.opts.value.current))) == null ? void 0 : _a.label;
        return match ?? "";
      }),
      "SelectSingleRootState.currentLabel"
    ));
    __privateAdd(this, _candidateLabels, tag(
      user_derived(() => {
        if (!this.opts.items.current.length) return [];
        const filteredItems = this.opts.items.current.filter((item) => !item.disabled);
        return filteredItems.map((item) => item.label);
      }),
      "SelectSingleRootState.candidateLabels"
    ));
    __privateAdd(this, _dataTypeaheadEnabled, tag(
      user_derived(() => {
        if (this.isMulti) return false;
        if (strict_equals(this.opts.items.current.length, 0)) return false;
        return true;
      }),
      "SelectSingleRootState.dataTypeaheadEnabled"
    ));
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue), value);
  }
  get currentLabel() {
    return get(__privateGet(this, _currentLabel));
  }
  set currentLabel(value) {
    set(__privateGet(this, _currentLabel), value);
  }
  get candidateLabels() {
    return get(__privateGet(this, _candidateLabels));
  }
  set candidateLabels(value) {
    set(__privateGet(this, _candidateLabels), value);
  }
  get dataTypeaheadEnabled() {
    return get(__privateGet(this, _dataTypeaheadEnabled));
  }
  set dataTypeaheadEnabled(value) {
    set(__privateGet(this, _dataTypeaheadEnabled), value);
  }
  includesItem(itemValue) {
    return strict_equals(this.opts.value.current, itemValue);
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    this.opts.value.current = this.includesItem(itemValue) ? "" : itemValue;
    this.opts.inputValue.current = itemLabel;
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (strict_equals(this.opts.value.current, "", false)) {
        const node = this.getNodeByValue(this.opts.value.current);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate, true);
    });
  }
};
_hasValue = new WeakMap();
_currentLabel = new WeakMap();
_candidateLabels = new WeakMap();
_dataTypeaheadEnabled = new WeakMap();
var _hasValue2;
var SelectMultipleRootState = class extends SelectBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _hasValue2, tag(user_derived(() => this.opts.value.current.length > 0), "SelectMultipleRootState.hasValue"));
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue2));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue2), value);
  }
  includesItem(itemValue) {
    return this.opts.value.current.includes(itemValue);
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    if (this.includesItem(itemValue)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, itemValue, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, itemValue];
    }
    this.opts.inputValue.current = itemLabel;
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (!this.domContext) return;
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (this.opts.value.current.length && strict_equals(this.opts.value.current[0], "", false)) {
        const node = this.getNodeByValue(this.opts.value.current[0]);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate, true);
    });
  }
};
_hasValue2 = new WeakMap();
var SelectRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = strict_equals(type, "single") ? new SelectSingleRootState(rest) : new SelectMultipleRootState(rest);
    return SelectRootContext.set(rootState);
  }
};
var _props41;
var _SelectInputState = class _SelectInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props41, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "combobox",
        disabled: this.root.opts.disabled.current ? true : void 0,
        "aria-activedescendant": this.root.highlightedId,
        "aria-autocomplete": "list",
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        onkeydown: this.onkeydown,
        oninput: this.oninput,
        [this.root.getBitsAttr("input")]: "",
        ...this.attachment
      })),
      "SelectInputState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.inputNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.oninput = this.oninput.bind(this);
    watch(
      [
        () => this.root.opts.value.current,
        () => this.opts.clearOnDeselect.current
      ],
      ([value, clearOnDeselect], [prevValue]) => {
        if (!clearOnDeselect) return;
        if (Array.isArray(value) && Array.isArray(prevValue)) {
          if (strict_equals(value.length, 0) && strict_equals(prevValue.length, 0, false)) {
            this.root.opts.inputValue.current = "";
          }
        } else if (strict_equals(value, "") && strict_equals(prevValue, "", false)) {
          this.root.opts.inputValue.current = "";
        }
      }
    );
  }
  static create(opts) {
    return new _SelectInputState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (strict_equals(e.key, kbd_constants_exports.ESCAPE)) return;
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (INTERACTION_KEYS.includes(e.key)) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
      if (strict_equals(e.key, kbd_constants_exports.BACKSPACE) && strict_equals(this.root.opts.inputValue.current, "")) return;
      this.root.handleOpen();
      if (this.root.hasValue) return;
      const candidateNodes = this.root.getCandidateNodes();
      if (!candidateNodes.length) return;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        const firstCandidate = candidateNodes[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        const lastCandidate = candidateNodes[candidateNodes.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.root.handleClose();
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.ENTER) && !e.isComposing) {
      e.preventDefault();
      const isCurrentSelectedValue = strict_equals(this.root.highlightedValue, this.root.opts.value.current);
      if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
        this.root.handleClose();
        return;
      }
      if (this.root.highlightedValue) {
        this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
      }
      if (!this.root.isMulti && !isCurrentSelectedValue) {
        this.root.handleClose();
      }
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS2.includes(e.key)) {
      e.preventDefault();
      const candidateNodes = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        nextItem = next2(candidateNodes, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        nextItem = prev(candidateNodes, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
        nextItem = forward(candidateNodes, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
        nextItem = backward(candidateNodes, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
        nextItem = candidateNodes[0];
      } else if (strict_equals(e.key, kbd_constants_exports.END)) {
        nextItem = candidateNodes[candidateNodes.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    if (INTERACTION_KEYS.includes(e.key)) return;
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  oninput(e) {
    this.root.opts.inputValue.current = e.currentTarget.value;
    this.root.setHighlightedToFirstCandidate();
  }
  get props() {
    return get(__privateGet(this, _props41));
  }
  set props(value) {
    set(__privateGet(this, _props41), value);
  }
};
_props41 = new WeakMap();
var SelectInputState = _SelectInputState;
var _props42;
var _SelectComboTriggerState = class _SelectComboTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props42, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: this.root.opts.disabled.current ? true : void 0,
        "aria-haspopup": "listbox",
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        [this.root.getBitsAttr("trigger")]: "",
        onpointerdown: this.onpointerdown,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "SelectComboTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
  }
  static create(opts) {
    return new _SelectComboTriggerState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    var _a;
    if (!this.root.domContext) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      if (strict_equals(this.root.domContext.getActiveElement(), this.root.inputNode, false)) {
        (_a = this.root.inputNode) == null ? void 0 : _a.focus();
      }
      this.root.toggleMenu();
    }
  }
  /**
   * `pointerdown` fires before the `focus` event, so we can prevent the default
   * behavior of focusing the button and keep focus on the input.
   */
  onpointerdown(e) {
    var _a;
    if (this.root.opts.disabled.current || !this.root.domContext) return;
    e.preventDefault();
    if (strict_equals(this.root.domContext.getActiveElement(), this.root.inputNode, false)) {
      (_a = this.root.inputNode) == null ? void 0 : _a.focus();
    }
    this.root.toggleMenu();
  }
  get props() {
    return get(__privateGet(this, _props42));
  }
  set props(value) {
    set(__privateGet(this, _props42), value);
  }
};
_props42 = new WeakMap();
var SelectComboTriggerState = _SelectComboTriggerState;
var _domTypeahead, _dataTypeahead, _SelectTriggerState_instances, handleOpen_fn, handlePointerOpen_fn, handleKeyboardSelection_fn, _props43;
var _SelectTriggerState = class _SelectTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _SelectTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _domTypeahead);
    __privateAdd(this, _dataTypeahead);
    __privateAdd(this, _props43, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: this.root.opts.disabled.current ? true : void 0,
        "aria-haspopup": "listbox",
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "aria-activedescendant": this.root.highlightedId,
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-placeholder": this.root.hasValue ? void 0 : "",
        [this.root.getBitsAttr("trigger")]: "",
        onpointerdown: this.onpointerdown,
        onkeydown: this.onkeydown,
        onclick: this.onclick,
        onpointerup: this.onpointerup,
        ...this.attachment
      })),
      "SelectTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    __privateSet(this, _domTypeahead, new DOMTypeahead({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (node) => {
        this.root.setHighlightedNode(node);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    }));
    __privateSet(this, _dataTypeahead, new DataTypeahead({
      getCurrentItem: () => {
        if (this.root.isMulti) return "";
        return this.root.currentLabel;
      },
      onMatch: (label) => {
        if (this.root.isMulti) return;
        if (!this.root.opts.items.current) return;
        const matchedItem = this.root.opts.items.current.find((item) => strict_equals(item.label, label));
        if (!matchedItem) return;
        this.root.opts.value.current = matchedItem.value;
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    }));
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _SelectTriggerState(opts, SelectRootContext.get());
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN) || strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        e.preventDefault();
        this.root.handleOpen();
      } else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        __privateGet(this, _dataTypeahead).handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const candidateNodes2 = this.root.getCandidateNodes();
      if (!candidateNodes2.length) return;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        const firstCandidate = candidateNodes2[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        const lastCandidate = candidateNodes2[candidateNodes2.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.root.handleClose();
      return;
    }
    if ((strict_equals(e.key, kbd_constants_exports.ENTER) || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    strict_equals(e.key, kbd_constants_exports.SPACE) && strict_equals(__privateGet(this, _domTypeahead).search, "")) && !e.isComposing) {
      e.preventDefault();
      const shouldReturn = __privateMethod(this, _SelectTriggerState_instances, handleKeyboardSelection_fn).call(this);
      if (shouldReturn) return;
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS2.includes(e.key)) {
      e.preventDefault();
      const candidateNodes2 = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes2.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        nextItem = next2(candidateNodes2, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        nextItem = prev(candidateNodes2, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
        nextItem = forward(candidateNodes2, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
        nextItem = backward(candidateNodes2, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
        nextItem = candidateNodes2[0];
      } else if (strict_equals(e.key, kbd_constants_exports.END)) {
        nextItem = candidateNodes2[candidateNodes2.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = strict_equals(e.key.length, 1);
    const isSpaceKey = strict_equals(e.key, kbd_constants_exports.SPACE);
    const candidateNodes = this.root.getCandidateNodes();
    if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
    if (!isModifierKey && (isCharacterKey || isSpaceKey)) {
      const matchedNode = __privateGet(this, _domTypeahead).handleTypeaheadSearch(e.key, candidateNodes);
      if (!matchedNode && isSpaceKey) {
        e.preventDefault();
        __privateMethod(this, _SelectTriggerState_instances, handleKeyboardSelection_fn).call(this);
      }
      return;
    }
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    const currTarget = e.currentTarget;
    currTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
    const target = e.target;
    if (target == null ? void 0 : target.hasPointerCapture(e.pointerId)) {
      target == null ? void 0 : target.releasePointerCapture(e.pointerId);
    }
    if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
      if (strict_equals(this.root.opts.open.current, false)) {
        __privateMethod(this, _SelectTriggerState_instances, handlePointerOpen_fn).call(this, e);
      } else {
        this.root.handleClose();
      }
    }
  }
  onpointerup(e) {
    if (this.root.opts.disabled.current) return;
    e.preventDefault();
    if (strict_equals(e.pointerType, "touch")) {
      if (strict_equals(this.root.opts.open.current, false)) {
        __privateMethod(this, _SelectTriggerState_instances, handlePointerOpen_fn).call(this, e);
      } else {
        this.root.handleClose();
      }
    }
  }
  get props() {
    return get(__privateGet(this, _props43));
  }
  set props(value) {
    set(__privateGet(this, _props43), value);
  }
};
_domTypeahead = new WeakMap();
_dataTypeahead = new WeakMap();
_SelectTriggerState_instances = new WeakSet();
handleOpen_fn = function() {
  this.root.opts.open.current = true;
  __privateGet(this, _dataTypeahead).resetTypeahead();
  __privateGet(this, _domTypeahead).resetTypeahead();
};
handlePointerOpen_fn = function(_) {
  __privateMethod(this, _SelectTriggerState_instances, handleOpen_fn).call(this);
};
/**
 * Logic used to handle keyboard selection/deselection.
 *
 * If it returns true, it means the item was selected and whatever is calling
 * this function should return early
 *
 */
handleKeyboardSelection_fn = function() {
  const isCurrentSelectedValue = strict_equals(this.root.highlightedValue, this.root.opts.value.current);
  if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
    this.root.handleClose();
    return true;
  }
  if (strict_equals(this.root.highlightedValue, null, false)) {
    this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
  }
  if (!this.root.isMulti && !isCurrentSelectedValue) {
    this.root.handleClose();
    return true;
  }
  return false;
};
_props43 = new WeakMap();
var SelectTriggerState = _SelectTriggerState;
var _viewportNode, _isPositioned, _styles2, _snippetProps11, _props44;
var _SelectContentState = class _SelectContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _viewportNode, tag(state(null), "SelectContentState.viewportNode"));
    __privateAdd(this, _isPositioned, tag(state(false), "SelectContentState.isPositioned"));
    __publicField(this, "domContext");
    __privateAdd(this, _styles2, tag(
      user_derived(() => {
        return getFloatingContentCSSVars(this.root.isCombobox ? "combobox" : "select");
      }),
      "SelectContentState.#styles"
    ));
    __publicField(this, "onInteractOutside", (e) => {
      if (strict_equals(e.target, this.root.triggerNode) || strict_equals(e.target, this.root.inputNode)) {
        e.preventDefault();
        return;
      }
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      this.opts.onEscapeKeydown.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps11, tag(user_derived(() => ({ open: this.root.opts.open.current })), "SelectContentState.snippetProps"));
    __privateAdd(this, _props44, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "listbox",
        "aria-multiselectable": this.root.isMulti ? "true" : void 0,
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        [this.root.getBitsAttr("content")]: "",
        style: {
          display: "flex",
          flexDirection: "column",
          outline: "none",
          boxSizing: "border-box",
          pointerEvents: "auto",
          ...get(__privateGet(this, _styles2))
        },
        onpointermove: this.onpointermove,
        ...this.attachment
      })),
      "SelectContentState.props"
    ));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus,
      trapFocus: false,
      loop: false,
      onPlaced: () => {
        if (this.root.opts.open.current) {
          this.isPositioned = true;
        }
      }
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.contentNode = v);
    this.domContext = new DOMContext(this.opts.ref);
    if (strict_equals(this.root.domContext, null)) {
      this.root.domContext = this.domContext;
    }
    onDestroyEffect(() => {
      this.root.contentNode = null;
      this.isPositioned = false;
    });
    watch(() => this.root.opts.open.current, () => {
      if (this.root.opts.open.current) return;
      this.isPositioned = false;
    });
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return SelectContentContext.set(new _SelectContentState(opts, SelectRootContext.get()));
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode), value, true);
  }
  get isPositioned() {
    return get(__privateGet(this, _isPositioned));
  }
  set isPositioned(value) {
    set(__privateGet(this, _isPositioned), value, true);
  }
  onpointermove(_) {
    this.root.isUsingKeyboard = false;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps11));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps11), value);
  }
  get props() {
    return get(__privateGet(this, _props44));
  }
  set props(value) {
    set(__privateGet(this, _props44), value);
  }
};
_viewportNode = new WeakMap();
_isPositioned = new WeakMap();
_styles2 = new WeakMap();
_snippetProps11 = new WeakMap();
_props44 = new WeakMap();
var SelectContentState = _SelectContentState;
var _isSelected, _isHighlighted, _mounted, _snippetProps12, _props45;
var _SelectItemState = class _SelectItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isSelected, tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "SelectItemState.isSelected"));
    __privateAdd(this, _isHighlighted, tag(user_derived(() => strict_equals(this.root.highlightedValue, this.opts.value.current)), "SelectItemState.isHighlighted"));
    __publicField(this, "prevHighlighted", new Previous(() => this.isHighlighted));
    __privateAdd(this, _mounted, tag(state(false), "SelectItemState.mounted"));
    __privateAdd(this, _snippetProps12, tag(
      user_derived(() => ({
        selected: this.isSelected,
        highlighted: this.isHighlighted
      })),
      "SelectItemState.snippetProps"
    ));
    __privateAdd(this, _props45, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "option",
        "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
        "data-value": this.opts.value.current,
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-highlighted": strict_equals(this.root.highlightedValue, this.opts.value.current) && !this.opts.disabled.current ? "" : void 0,
        "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
        "data-label": this.opts.label.current,
        [this.root.getBitsAttr("item")]: "",
        onpointermove: this.onpointermove,
        onpointerdown: this.onpointerdown,
        onpointerup: this.onpointerup,
        ...this.attachment
      })),
      "SelectItemState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.isHighlighted,
        () => this.prevHighlighted.current
      ],
      () => {
        if (this.isHighlighted) {
          this.opts.onHighlight.current();
        } else if (this.prevHighlighted.current) {
          this.opts.onUnhighlight.current();
        }
      }
    );
    watch(() => this.mounted, () => {
      if (!this.mounted) return;
      this.root.setInitialHighlightedNode();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return new _SelectItemState(opts, SelectRootContext.get());
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected));
  }
  set isSelected(value) {
    set(__privateGet(this, _isSelected), value);
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted));
  }
  set isHighlighted(value) {
    set(__privateGet(this, _isHighlighted), value);
  }
  get mounted() {
    return get(__privateGet(this, _mounted));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted), value, true);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const isCurrentSelectedValue = strict_equals(this.opts.value.current, this.root.opts.value.current);
    if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current);
    if (!this.root.isMulti && !isCurrentSelectedValue) {
      this.root.handleClose();
    }
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps12));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps12), value);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (e.defaultPrevented || !this.opts.ref.current) return;
    if (strict_equals(e.pointerType, "touch") && !isIOS) {
      on(
        this.opts.ref.current,
        "click",
        () => {
          this.handleSelect();
          this.root.setHighlightedNode(this.opts.ref.current);
        },
        { once: true }
      );
      return;
    }
    e.preventDefault();
    this.handleSelect();
    if (strict_equals(e.pointerType, "touch")) {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    if (strict_equals(e.pointerType, "touch")) return;
    if (strict_equals(this.root.highlightedNode, this.opts.ref.current, false)) {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  get props() {
    return get(__privateGet(this, _props45));
  }
  set props(value) {
    set(__privateGet(this, _props45), value);
  }
};
_isSelected = new WeakMap();
_isHighlighted = new WeakMap();
_mounted = new WeakMap();
_snippetProps12 = new WeakMap();
_props45 = new WeakMap();
var SelectItemState = _SelectItemState;
var _labelNode, _props46;
var _SelectGroupState = class _SelectGroupState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _labelNode, tag(state(null), "SelectGroupState.labelNode"));
    __publicField(this, "attachment");
    __privateAdd(this, _props46, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          role: "group",
          [this.root.getBitsAttr("group")]: "",
          "aria-labelledby": ((_a = this.labelNode) == null ? void 0 : _a.id) ?? void 0,
          ...this.attachment
        };
      }),
      "SelectGroupState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return SelectGroupContext.set(new _SelectGroupState(opts, SelectRootContext.get()));
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode), value, true);
  }
  get props() {
    return get(__privateGet(this, _props46));
  }
  set props(value) {
    set(__privateGet(this, _props46), value);
  }
};
_labelNode = new WeakMap();
_props46 = new WeakMap();
var SelectGroupState = _SelectGroupState;
var _props47;
var _SelectGroupHeadingState = class _SelectGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props47, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.group.root.getBitsAttr("group-label")]: "",
        ...this.attachment
      })),
      "SelectGroupHeadingState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(opts.ref, (v) => this.group.labelNode = v);
  }
  static create(opts) {
    return new _SelectGroupHeadingState(opts, SelectGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props47));
  }
  set props(value) {
    set(__privateGet(this, _props47), value);
  }
};
_props47 = new WeakMap();
var SelectGroupHeadingState = _SelectGroupHeadingState;
var _shouldRender2, _props48;
var _SelectHiddenInputState = class _SelectHiddenInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _shouldRender2, tag(user_derived(() => strict_equals(this.root.opts.name.current, "", false)), "SelectHiddenInputState.shouldRender"));
    __privateAdd(this, _props48, tag(
      user_derived(() => ({
        disabled: getDisabled(this.root.opts.disabled.current),
        required: getRequired(this.root.opts.required.current),
        name: this.root.opts.name.current,
        value: this.opts.value.current,
        onfocus: this.onfocus
      })),
      "SelectHiddenInputState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onfocus = this.onfocus.bind(this);
  }
  static create(opts) {
    return new _SelectHiddenInputState(opts, SelectRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender2));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender2), value);
  }
  onfocus(e) {
    var _a, _b;
    e.preventDefault();
    if (!this.root.isCombobox) {
      (_a = this.root.triggerNode) == null ? void 0 : _a.focus();
    } else {
      (_b = this.root.inputNode) == null ? void 0 : _b.focus();
    }
  }
  get props() {
    return get(__privateGet(this, _props48));
  }
  set props(value) {
    set(__privateGet(this, _props48), value);
  }
};
_shouldRender2 = new WeakMap();
_props48 = new WeakMap();
var SelectHiddenInputState = _SelectHiddenInputState;
var _prevScrollTop, _props49;
var _SelectViewportState = class _SelectViewportState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _prevScrollTop, tag(state(0), "SelectViewportState.prevScrollTop"));
    __privateAdd(this, _props49, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "presentation",
        [this.root.getBitsAttr("viewport")]: "",
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        ...this.attachment
      })),
      "SelectViewportState.props"
    ));
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref, (v) => this.content.viewportNode = v);
  }
  static create(opts) {
    return new _SelectViewportState(opts, SelectContentContext.get());
  }
  get prevScrollTop() {
    return get(__privateGet(this, _prevScrollTop));
  }
  set prevScrollTop(value) {
    set(__privateGet(this, _prevScrollTop), value, true);
  }
  get props() {
    return get(__privateGet(this, _props49));
  }
  set props(value) {
    set(__privateGet(this, _props49), value);
  }
};
_prevScrollTop = new WeakMap();
_props49 = new WeakMap();
var SelectViewportState = _SelectViewportState;
var _mounted2, _props50;
var SelectScrollButtonImplState = class {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "autoScrollTimer", null);
    __publicField(this, "userScrollTimer", -1);
    __publicField(this, "isUserScrolling", false);
    __publicField(this, "onAutoScroll", noop3);
    __privateAdd(this, _mounted2, tag(state(false), "SelectScrollButtonImplState.mounted"));
    __privateAdd(this, _props50, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-hidden": getAriaHidden(true),
        style: { flexShrink: 0 },
        onpointerdown: this.onpointerdown,
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        ...this.attachment
      })),
      "SelectScrollButtonImplState.props"
    ));
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref);
    watch([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = false;
        return;
      }
      if (this.isUserScrolling) return;
    });
    user_effect(() => {
      if (this.mounted) return;
      this.clearAutoScrollInterval();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  get mounted() {
    return get(__privateGet(this, _mounted2));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted2), value, true);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer);
    this.isUserScrolling = true;
    this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = false;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    if (strict_equals(this.autoScrollTimer, null)) return;
    this.content.domContext.clearTimeout(this.autoScrollTimer);
    this.autoScrollTimer = null;
  }
  onpointerdown(_) {
    if (strict_equals(this.autoScrollTimer, null, false)) return;
    const autoScroll = (tick2) => {
      this.onAutoScroll();
      this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(tick2 + 1), this.opts.delay.current(tick2));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(_) {
    this.clearAutoScrollInterval();
  }
  get props() {
    return get(__privateGet(this, _props50));
  }
  set props(value) {
    set(__privateGet(this, _props50), value);
  }
};
_mounted2 = new WeakMap();
_props50 = new WeakMap();
var _canScrollDown, _props51;
var _SelectScrollDownButtonState = class _SelectScrollDownButtonState {
  constructor(scrollButtonState) {
    __publicField(this, "scrollButtonState");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollDown, tag(state(false), "SelectScrollDownButtonState.canScrollDown"));
    __publicField(this, "scrollIntoViewTimer", null);
    /**
     * @param manual - if true, it means the function was invoked manually outside of an event
     * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
     */
    __publicField(this, "handleScroll", (manual = false) => {
      if (!manual) {
        this.scrollButtonState.handleUserScroll();
      }
      if (!this.content.viewportNode) return;
      const maxScroll = this.content.viewportNode.scrollHeight - this.content.viewportNode.clientHeight;
      const paddingTop = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10);
      this.canScrollDown = Math.ceil(this.content.viewportNode.scrollTop) < maxScroll - paddingTop;
    });
    __publicField(this, "handleAutoScroll", () => {
      const viewport = this.content.viewportNode;
      const selectedItem = this.root.highlightedNode;
      if (!viewport || !selectedItem) return;
      viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
    });
    __privateAdd(this, _props51, tag(
      user_derived(() => ({
        ...this.scrollButtonState.props,
        [this.root.getBitsAttr("scroll-down-button")]: ""
      })),
      "SelectScrollDownButtonState.props"
    ));
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.content.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.content.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.content.viewportNode, "scroll", () => this.handleScroll());
      }
    );
    watch(() => this.scrollButtonState.mounted, () => {
      if (!this.scrollButtonState.mounted) return;
      if (this.scrollIntoViewTimer) {
        clearTimeout(this.scrollIntoViewTimer);
      }
      this.scrollIntoViewTimer = afterSleep(5, () => {
        const activeItem = this.root.highlightedNode;
        activeItem == null ? void 0 : activeItem.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      });
    });
  }
  static create(opts) {
    return new _SelectScrollDownButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  get canScrollDown() {
    return get(__privateGet(this, _canScrollDown));
  }
  set canScrollDown(value) {
    set(__privateGet(this, _canScrollDown), value, true);
  }
  get props() {
    return get(__privateGet(this, _props51));
  }
  set props(value) {
    set(__privateGet(this, _props51), value);
  }
};
_canScrollDown = new WeakMap();
_props51 = new WeakMap();
var SelectScrollDownButtonState = _SelectScrollDownButtonState;
var _canScrollUp, _props52;
var _SelectScrollUpButtonState = class _SelectScrollUpButtonState {
  constructor(scrollButtonState) {
    __publicField(this, "scrollButtonState");
    __publicField(this, "content");
    __publicField(this, "root");
    __privateAdd(this, _canScrollUp, tag(state(false), "SelectScrollUpButtonState.canScrollUp"));
    /**
     * @param manual - if true, it means the function was invoked manually outside of an event
     * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
     */
    __publicField(this, "handleScroll", (manual = false) => {
      if (!manual) {
        this.scrollButtonState.handleUserScroll();
      }
      if (!this.content.viewportNode) return;
      const paddingTop = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10);
      this.canScrollUp = this.content.viewportNode.scrollTop - paddingTop > 0.1;
    });
    __publicField(this, "handleAutoScroll", () => {
      if (!this.content.viewportNode || !this.root.highlightedNode) return;
      this.content.viewportNode.scrollTop = this.content.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight;
    });
    __privateAdd(this, _props52, tag(
      user_derived(() => ({
        ...this.scrollButtonState.props,
        [this.root.getBitsAttr("scroll-up-button")]: ""
      })),
      "SelectScrollUpButtonState.props"
    ));
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.content.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.content.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.content.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  static create(opts) {
    return new _SelectScrollUpButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  get canScrollUp() {
    return get(__privateGet(this, _canScrollUp));
  }
  set canScrollUp(value) {
    set(__privateGet(this, _canScrollUp), value, true);
  }
  get props() {
    return get(__privateGet(this, _props52));
  }
  set props(value) {
    set(__privateGet(this, _props52), value);
  }
};
_canScrollUp = new WeakMap();
_props52 = new WeakMap();
var SelectScrollUpButtonState = _SelectScrollUpButtonState;

// node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte
Select_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte";
function Select_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_hidden_input);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15, "");
  const hiddenInputState = SelectHiddenInputState.create({ value: box.with(() => value()) });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("value", hidden_input_default, value);
        hidden_input_default(node_1, spread_props(() => hiddenInputState.props, {
          get autocomplete() {
            return $$props.autocomplete;
          },
          get value() {
            return value();
          },
          set value($$value) {
            value($$value);
          }
        }));
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (hiddenInputState.shouldRender) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_hidden_input = hmr(Select_hidden_input, () => Select_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_hidden_input[HMR].source;
    set(Select_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var select_hidden_input_default = Select_hidden_input;

// node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte
Combobox[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte";
var root3 = add_locations(from_html(`<!> <!>`, 1), Combobox[FILENAME], []);
function Combobox($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, true), inputValue = prop($$props, "inputValue", 7, "");
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    value(defaultValue);
  }
  watch.pre(() => value(), () => {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  });
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: true,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect()),
    inputValue: box.with(() => inputValue(), (v) => inputValue(v)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = root3();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Combobox, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => rootState.opts.value.current, (item) => item);
          each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
            var fragment_4 = comment();
            var node_5 = first_child(fragment_4);
            select_hidden_input_default(node_5, {
              get value() {
                return item;
              }
            });
            append($$anchor4, fragment_4);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_3, ($$render) => {
          if (rootState.opts.value.current.length) $$render(consequent);
        });
      }
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.opts.value.current as string}", () => rootState.opts.value, () => "current", 85, 21);
      select_hidden_input_default(node_6, {
        get value() {
          return rootState.opts.value.current;
        },
        set value($$value) {
          rootState.opts.value.current = $$value;
        }
      });
      append($$anchor2, fragment_5);
    };
    if_block(node_2, ($$render) => {
      if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox = hmr(Combobox, () => Combobox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox[HMR].source;
    set(Combobox[HMR].source, module.default[HMR].original);
  });
}
var combobox_default = Combobox;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/index.js
var components_exports = {};
__export(components_exports, {
  Anchor: () => floating_layer_anchor_default,
  Arrow: () => floating_layer_arrow_default,
  Content: () => floating_layer_content_default,
  ContentStatic: () => floating_layer_content_static_default,
  Root: () => floating_layer_default
});

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte
Floating_layer_anchor[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte";
function Floating_layer_anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_anchor);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingAnchorState.create(
    {
      id: box.with(() => $$props.id),
      virtualEl: box.with(() => $$props.virtualEl),
      ref: $$props.ref
    },
    tooltip()
  );
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_anchor = hmr(Floating_layer_anchor, () => Floating_layer_anchor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_anchor[HMR].source;
    set(Floating_layer_anchor[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_anchor_default = Floating_layer_anchor;

// node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte
Arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte";
var root_4 = add_locations(from_svg(`<svg viewBox="0 0 30 10" preserveAspectRatio="none" data-arrow=""><polygon points="0,0 30,0 15,10" fill="currentColor"></polygon></svg>`), Arrow[FILENAME], [[25, 3, [[26, 4]]]]);
var root_234 = add_locations(from_html(`<span><!></span>`), Arrow[FILENAME], [[21, 1]]);
function Arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow);
  let id = prop($$props, "id", 19, useId), width = prop($$props, "width", 3, 10), height = prop($$props, "height", 3, 5), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "width",
      "height"
    ],
    "restProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, { id: id() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_234();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var svg = root_4();
          template_effect(() => {
            set_attribute(svg, "width", width());
            set_attribute(svg, "height", height());
          });
          append($$anchor3, svg);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Arrow = hmr(Arrow, () => Arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Arrow[HMR].source;
    set(Arrow[HMR].source, module.default[HMR].original);
  });
}
var arrow_default = Arrow;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte
Floating_layer_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte";
function Floating_layer_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_arrow);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref"
    ],
    "restProps"
  );
  const arrowState = FloatingArrowState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, arrowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  arrow_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_arrow = hmr(Floating_layer_arrow, () => Floating_layer_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_arrow[HMR].source;
    set(Floating_layer_arrow[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_arrow_default = Floating_layer_arrow;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte
Floating_layer_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte";
function Floating_layer_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content);
  let side = prop($$props, "side", 3, "bottom"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), alignOffset = prop($$props, "alignOffset", 3, 0), arrowPadding = prop($$props, "arrowPadding", 3, 0), avoidCollisions = prop($$props, "avoidCollisions", 3, true), collisionBoundary = prop($$props, "collisionBoundary", 19, () => []), collisionPadding = prop($$props, "collisionPadding", 3, 0), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), onPlaced = prop($$props, "onPlaced", 3, () => {
  }), sticky = prop($$props, "sticky", 3, "partial"), updatePositionStrategy = prop($$props, "updatePositionStrategy", 3, "optimized"), strategy = prop($$props, "strategy", 3, "fixed"), dir = prop($$props, "dir", 3, "ltr"), style = prop($$props, "style", 19, () => ({})), wrapperId = prop($$props, "wrapperId", 19, useId), customAnchor = prop($$props, "customAnchor", 3, null), tooltip = prop($$props, "tooltip", 3, false);
  const contentState = FloatingContentState.create(
    {
      side: box.with(() => side()),
      sideOffset: box.with(() => sideOffset()),
      align: box.with(() => align()),
      alignOffset: box.with(() => alignOffset()),
      id: box.with(() => $$props.id),
      arrowPadding: box.with(() => arrowPadding()),
      avoidCollisions: box.with(() => avoidCollisions()),
      collisionBoundary: box.with(() => collisionBoundary()),
      collisionPadding: box.with(() => collisionPadding()),
      hideWhenDetached: box.with(() => hideWhenDetached()),
      onPlaced: box.with(() => onPlaced()),
      sticky: box.with(() => sticky()),
      updatePositionStrategy: box.with(() => updatePositionStrategy()),
      strategy: box.with(() => strategy()),
      dir: box.with(() => dir()),
      style: box.with(() => style()),
      enabled: box.with(() => $$props.enabled),
      wrapperId: box.with(() => wrapperId()),
      customAnchor: box.with(() => customAnchor())
    },
    tooltip()
  );
  const mergedProps = tag(user_derived(() => mergeProps(contentState.wrapperProps, { style: { pointerEvents: "auto" } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.content ?? noop, () => ({
    props: contentState.props,
    wrapperProps: get(mergedProps)
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content = hmr(Floating_layer_content, () => Floating_layer_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content[HMR].source;
    set(Floating_layer_content[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_default = Floating_layer_content;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte
Floating_layer_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte";
function Floating_layer_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content_static);
  onMount(() => {
    var _a;
    (_a = $$props.onPlaced) == null ? void 0 : _a.call($$props);
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.content ?? noop, () => ({ props: {}, wrapperProps: {} }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content_static = hmr(Floating_layer_content_static, () => Floating_layer_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content_static[HMR].source;
    set(Floating_layer_content_static[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_static_default = Floating_layer_content_static;

// node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte
Combobox_input[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte";
var root_34 = add_locations(from_html(`<input/>`), Combobox_input[FILENAME], [[39, 2]]);
function Combobox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_input);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), clearOnDeselect = prop($$props, "clearOnDeselect", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "defaultValue",
      "clearOnDeselect"
    ],
    "restProps"
  );
  const inputState = SelectInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    clearOnDeselect: box.with(() => clearOnDeselect())
  });
  if ($$props.defaultValue) {
    inputState.root.opts.inputValue.current = $$props.defaultValue;
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { value: inputState.root.opts.inputValue.current })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
    FloatingLayer_Anchor($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return inputState.opts.ref;
      },
      children: wrap_snippet(Combobox_input, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var input = root_34();
            remove_input_defaults(input);
            attribute_effect(input, () => ({ ...get(mergedProps) }));
            append($$anchor4, input);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_input = hmr(Combobox_input, () => Combobox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_input[HMR].source;
    set(Combobox_input[HMR].source, module.default[HMR].original);
  });
}
var combobox_input_default = Combobox_input;

// node_modules/bits-ui/dist/bits/separator/separator.svelte.js
var separatorAttrs = createBitsAttrs({ component: "separator", parts: ["root"] });
var _props53;
var _SeparatorRootState = class _SeparatorRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props53, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: this.opts.decorative.current ? "none" : "separator",
        "aria-orientation": getAriaOrientation(this.opts.orientation.current),
        "aria-hidden": getAriaHidden(this.opts.decorative.current),
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        [separatorAttrs.root]: "",
        ...this.attachment
      })),
      "SeparatorRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SeparatorRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props53));
  }
  set props(value) {
    set(__privateGet(this, _props53), value);
  }
};
_props53 = new WeakMap();
var SeparatorRootState = _SeparatorRootState;

// node_modules/bits-ui/dist/bits/separator/components/separator.svelte
Separator[FILENAME] = "node_modules/bits-ui/dist/bits/separator/components/separator.svelte";
var root_235 = add_locations(from_html(`<div><!></div>`), Separator[FILENAME], [[35, 1]]);
function Separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Separator);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), decorative = prop($$props, "decorative", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "decorative",
      "orientation"
    ],
    "restProps"
  );
  const rootState = SeparatorRootState.create({
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id()),
    decorative: box.with(() => decorative()),
    orientation: box.with(() => orientation())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_235();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Separator = hmr(Separator, () => Separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Separator[HMR].source;
    set(Separator[HMR].source, module.default[HMR].original);
  });
}
var separator_default = Separator;

// node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte
Combobox_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte";
var root_236 = add_locations(from_html(`<button><!></button>`), Combobox_trigger[FILENAME], [[30, 1]]);
function Combobox_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = SelectComboTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_236();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_trigger = hmr(Combobox_trigger, () => Combobox_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_trigger[HMR].source;
    set(Combobox_trigger[HMR].source, module.default[HMR].original);
  });
}
var combobox_trigger_default = Combobox_trigger;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte
Popper_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte";
function Popper_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_content);
  let isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "content",
      "isStatic",
      "onPlaced"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      floating_layer_content_static_default(node_1, {
        get content() {
          return $$props.content;
        },
        get onPlaced() {
          return $$props.onPlaced;
        }
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      floating_layer_content_default(node_2, spread_props(
        {
          get content() {
            return $$props.content;
          },
          get onPlaced() {
            return $$props.onPlaced;
          }
        },
        () => restProps
      ));
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (isStatic()) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_content = hmr(Popper_content, () => Popper_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_content[HMR].source;
    set(Popper_content[HMR].source, module.default[HMR].original);
  });
}
var popper_content_default = Popper_content;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte
Popper_layer_inner[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte";
var root_12 = add_locations(from_html(`<!> <!>`, 1), Popper_layer_inner[FILENAME], []);
function Popper_layer_inner($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_inner);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), tooltip = prop($$props, "tooltip", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled",
      "ref",
      "tooltip"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const content = wrap_snippet(Popper_layer_inner, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let floatingProps = () => $$arg0 == null ? void 0 : $$arg0().props;
      floatingProps();
      let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
      wrapperProps();
      var fragment_1 = root_12();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          scroll_lock_default(node_2, {
            get preventScroll() {
              return $$props.preventScroll;
            }
          });
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3, $$elseif) => {
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              scroll_lock_default(node_3, {
                get preventScroll() {
                  return $$props.preventScroll;
                }
              });
              append($$anchor4, fragment_3);
            };
            if_block(
              $$anchor3,
              ($$render) => {
                if (!$$props.forceMount) $$render(consequent_1);
              },
              $$elseif
            );
          }
        };
        if_block(node_1, ($$render) => {
          if ($$props.forceMount && $$props.enabled) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      var node_4 = sibling(node_1, 2);
      {
        const focusScope = wrap_snippet(Popper_layer_inner, function($$anchor3, $$arg02) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg02 == null ? void 0 : $$arg02().props;
          focusScopeProps();
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          escape_layer_default(node_5, {
            get onEscapeKeydown() {
              return $$props.onEscapeKeydown;
            },
            get escapeKeydownBehavior() {
              return $$props.escapeKeydownBehavior;
            },
            get enabled() {
              return $$props.enabled;
            },
            get ref() {
              return $$props.ref;
            },
            children: wrap_snippet(Popper_layer_inner, ($$anchor4, $$slotProps) => {
              var fragment_5 = comment();
              var node_6 = first_child(fragment_5);
              {
                const children = wrap_snippet(Popper_layer_inner, function($$anchor5, $$arg03) {
                  validate_snippet_args(...arguments);
                  let dismissibleProps = () => $$arg03 == null ? void 0 : $$arg03().props;
                  dismissibleProps();
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  text_selection_layer_default(node_7, {
                    get id() {
                      return $$props.id;
                    },
                    get preventOverflowTextSelection() {
                      return $$props.preventOverflowTextSelection;
                    },
                    get onPointerDown() {
                      return $$props.onPointerDown;
                    },
                    get onPointerUp() {
                      return $$props.onPointerUp;
                    },
                    get enabled() {
                      return $$props.enabled;
                    },
                    get ref() {
                      return $$props.ref;
                    },
                    children: wrap_snippet(Popper_layer_inner, ($$anchor6, $$slotProps2) => {
                      var fragment_7 = comment();
                      var node_8 = first_child(fragment_7);
                      var render_arg = derived_safe_equal(() => ({
                        props: mergeProps(restProps, floatingProps(), dismissibleProps(), focusScopeProps(), { style: { pointerEvents: "auto" } }),
                        wrapperProps: wrapperProps()
                      }));
                      snippet(node_8, () => $$props.popper ?? noop, () => get(render_arg));
                      append($$anchor6, fragment_7);
                    }),
                    $$slots: { default: true }
                  });
                  append($$anchor5, fragment_6);
                });
                dismissible_layer_default(node_6, {
                  get id() {
                    return $$props.id;
                  },
                  get onInteractOutside() {
                    return $$props.onInteractOutside;
                  },
                  get onFocusOutside() {
                    return $$props.onFocusOutside;
                  },
                  get interactOutsideBehavior() {
                    return interactOutsideBehavior();
                  },
                  isValidEvent: isValidEvent2(),
                  get enabled() {
                    return $$props.enabled;
                  },
                  get ref() {
                    return $$props.ref;
                  },
                  children,
                  $$slots: { default: true }
                });
              }
              append($$anchor4, fragment_5);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_4);
        });
        focus_scope_default(node_4, {
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get loop() {
            return $$props.loop;
          },
          get enabled() {
            return $$props.enabled;
          },
          get trapFocus() {
            return trapFocus();
          },
          get forceMount() {
            return $$props.forceMount;
          },
          get ref() {
            return $$props.ref;
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
      append($$anchor2, fragment_1);
    });
    popper_content_default(node, {
      get isStatic() {
        return isStatic();
      },
      get id() {
        return $$props.id;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      get enabled() {
        return $$props.enabled;
      },
      get tooltip() {
        return tooltip();
      },
      content,
      $$slots: { content: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_inner = hmr(Popper_layer_inner, () => Popper_layer_inner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_inner[HMR].source;
    set(Popper_layer_inner[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_inner_default = Popper_layer_inner;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte
Popper_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte";
function Popper_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "open",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "ref"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Popper_layer, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      popper_layer_inner_default(node_1, spread_props(
        {
          get popper() {
            return $$props.popper;
          },
          get onEscapeKeydown() {
            return $$props.onEscapeKeydown;
          },
          get escapeKeydownBehavior() {
            return $$props.escapeKeydownBehavior;
          },
          get preventOverflowTextSelection() {
            return $$props.preventOverflowTextSelection;
          },
          get id() {
            return $$props.id;
          },
          get onPointerDown() {
            return $$props.onPointerDown;
          },
          get onPointerUp() {
            return $$props.onPointerUp;
          },
          get side() {
            return $$props.side;
          },
          get sideOffset() {
            return $$props.sideOffset;
          },
          get align() {
            return $$props.align;
          },
          get alignOffset() {
            return $$props.alignOffset;
          },
          get arrowPadding() {
            return $$props.arrowPadding;
          },
          get avoidCollisions() {
            return $$props.avoidCollisions;
          },
          get collisionBoundary() {
            return $$props.collisionBoundary;
          },
          get collisionPadding() {
            return $$props.collisionPadding;
          },
          get sticky() {
            return $$props.sticky;
          },
          get hideWhenDetached() {
            return $$props.hideWhenDetached;
          },
          get updatePositionStrategy() {
            return $$props.updatePositionStrategy;
          },
          get strategy() {
            return $$props.strategy;
          },
          get dir() {
            return $$props.dir;
          },
          get preventScroll() {
            return $$props.preventScroll;
          },
          get wrapperId() {
            return $$props.wrapperId;
          },
          get style() {
            return $$props.style;
          },
          get onPlaced() {
            return $$props.onPlaced;
          },
          get customAnchor() {
            return customAnchor();
          },
          get isStatic() {
            return isStatic();
          },
          get enabled() {
            return $$props.open;
          },
          get onInteractOutside() {
            return $$props.onInteractOutside;
          },
          get onCloseAutoFocus() {
            return $$props.onCloseAutoFocus;
          },
          get onOpenAutoFocus() {
            return $$props.onOpenAutoFocus;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get loop() {
            return $$props.loop;
          },
          get trapFocus() {
            return trapFocus();
          },
          isValidEvent: isValidEvent2(),
          get onFocusOutside() {
            return $$props.onFocusOutside;
          },
          forceMount: false,
          get ref() {
            return $$props.ref;
          }
        },
        () => restProps
      ));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return $$props.open;
      },
      get ref() {
        return $$props.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer = hmr(Popper_layer, () => Popper_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer[HMR].source;
    set(Popper_layer[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_default = Popper_layer;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte
Popper_layer_force_mount[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte";
function Popper_layer_force_mount($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_force_mount);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  popper_layer_inner_default(node, spread_props(
    {
      get popper() {
        return $$props.popper;
      },
      get onEscapeKeydown() {
        return $$props.onEscapeKeydown;
      },
      get escapeKeydownBehavior() {
        return $$props.escapeKeydownBehavior;
      },
      get preventOverflowTextSelection() {
        return $$props.preventOverflowTextSelection;
      },
      get id() {
        return $$props.id;
      },
      get onPointerDown() {
        return $$props.onPointerDown;
      },
      get onPointerUp() {
        return $$props.onPointerUp;
      },
      get side() {
        return $$props.side;
      },
      get sideOffset() {
        return $$props.sideOffset;
      },
      get align() {
        return $$props.align;
      },
      get alignOffset() {
        return $$props.alignOffset;
      },
      get arrowPadding() {
        return $$props.arrowPadding;
      },
      get avoidCollisions() {
        return $$props.avoidCollisions;
      },
      get collisionBoundary() {
        return $$props.collisionBoundary;
      },
      get collisionPadding() {
        return $$props.collisionPadding;
      },
      get sticky() {
        return $$props.sticky;
      },
      get hideWhenDetached() {
        return $$props.hideWhenDetached;
      },
      get updatePositionStrategy() {
        return $$props.updatePositionStrategy;
      },
      get strategy() {
        return $$props.strategy;
      },
      get dir() {
        return $$props.dir;
      },
      get preventScroll() {
        return $$props.preventScroll;
      },
      get wrapperId() {
        return $$props.wrapperId;
      },
      get style() {
        return $$props.style;
      },
      get onPlaced() {
        return $$props.onPlaced;
      },
      get customAnchor() {
        return customAnchor();
      },
      get isStatic() {
        return isStatic();
      },
      get enabled() {
        return $$props.enabled;
      },
      get onInteractOutside() {
        return $$props.onInteractOutside;
      },
      get onCloseAutoFocus() {
        return $$props.onCloseAutoFocus;
      },
      get onOpenAutoFocus() {
        return $$props.onOpenAutoFocus;
      },
      get interactOutsideBehavior() {
        return interactOutsideBehavior();
      },
      get loop() {
        return $$props.loop;
      },
      get trapFocus() {
        return trapFocus();
      },
      isValidEvent: isValidEvent2(),
      get onFocusOutside() {
        return $$props.onFocusOutside;
      }
    },
    () => restProps,
    { forceMount: true }
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_force_mount = hmr(Popper_layer_force_mount, () => Popper_layer_force_mount[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_force_mount[HMR].source;
    set(Popper_layer_force_mount[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_force_mount_default = Popper_layer_force_mount;

// node_modules/bits-ui/dist/bits/select/components/select-content.svelte
Select_content[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content.svelte";
var root_42 = add_locations(from_html(`<div><div><!></div></div>`), Select_content[FILENAME], [[54, 4, [[55, 5]]]]);
var root_9 = add_locations(from_html(`<div><div><!></div></div>`), Select_content[FILENAME], [[78, 4, [[79, 5]]]]);
function Select_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), side = prop($$props, "side", 3, "bottom"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "side",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = SelectContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_42();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get side() {
            return side();
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get preventScroll() {
            return preventScroll();
          },
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Select_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_9();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get side() {
                return side();
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get preventScroll() {
                return preventScroll();
              },
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content = hmr(Select_content, () => Select_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content[HMR].source;
    set(Select_content[HMR].source, module.default[HMR].original);
  });
}
var select_content_default = Select_content;

// node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte
Select_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte";
var root_43 = add_locations(from_html(`<div><!></div>`), Select_content_static[FILENAME], [[53, 4]]);
var root_92 = add_locations(from_html(`<div><!></div>`), Select_content_static[FILENAME], [[75, 4]]);
function Select_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = SelectContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_43();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get preventScroll() {
            return preventScroll();
          },
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Select_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), { style: contentState.props.style }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_92();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get preventScroll() {
                return preventScroll();
              },
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content_static = hmr(Select_content_static, () => Select_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content_static[HMR].source;
    set(Select_content_static[HMR].source, module.default[HMR].original);
  });
}
var select_content_static_default = Select_content_static;

// node_modules/bits-ui/dist/bits/utilities/mounted.svelte
Mounted[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/mounted.svelte";
function Mounted($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mounted);
  let mounted = prop($$props, "mounted", 15, false), onMountedChange = prop($$props, "onMountedChange", 3, noop3);
  onMountEffect(() => {
    mounted(true);
    onMountedChange()(true);
    return () => {
      mounted(false);
      onMountedChange()(false);
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mounted = hmr(Mounted, () => Mounted[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mounted[HMR].source;
    set(Mounted[HMR].source, module.default[HMR].original);
  });
}
var mounted_default = Mounted;

// node_modules/bits-ui/dist/bits/select/components/select-item.svelte
Select_item[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-item.svelte";
var root_237 = add_locations(from_html(`<div><!></div>`), Select_item[FILENAME], [[43, 1]]);
var root4 = add_locations(from_html(`<!> <!>`, 1), Select_item[FILENAME], []);
function Select_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), label = prop($$props, "label", 19, () => $$props.value), disabled = prop($$props, "disabled", 3, false), onHighlight = prop($$props, "onHighlight", 3, noop3), onUnhighlight = prop($$props, "onUnhighlight", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "label",
      "disabled",
      "children",
      "child",
      "onHighlight",
      "onUnhighlight"
    ],
    "restProps"
  );
  const itemState = SelectItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled()),
    label: box.with(() => label()),
    onHighlight: box.with(() => onHighlight()),
    onUnhighlight: box.with(() => onUnhighlight())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = root4();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_237();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  validate_binding("bind:mounted={itemState.mounted}", () => itemState, () => "mounted", 48, 9);
  mounted_default(node_3, {
    get mounted() {
      return itemState.mounted;
    },
    set mounted($$value) {
      itemState.mounted = $$value;
    }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_item = hmr(Select_item, () => Select_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_item[HMR].source;
    set(Select_item[HMR].source, module.default[HMR].original);
  });
}
var select_item_default = Select_item;

// node_modules/bits-ui/dist/bits/select/components/select-group.svelte
Select_group[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group.svelte";
var root_238 = add_locations(from_html(`<div><!></div>`), Select_group[FILENAME], [[31, 1]]);
function Select_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = SelectGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_238();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group = hmr(Select_group, () => Select_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group[HMR].source;
    set(Select_group[HMR].source, module.default[HMR].original);
  });
}
var select_group_default = Select_group;

// node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte
Select_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte";
var root_239 = add_locations(from_html(`<div><!></div>`), Select_group_heading[FILENAME], [[30, 1]]);
function Select_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_group_heading);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  const groupHeadingState = SelectGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupHeadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_239();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group_heading = hmr(Select_group_heading, () => Select_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group_heading[HMR].source;
    set(Select_group_heading[HMR].source, module.default[HMR].original);
  });
}
var select_group_heading_default = Select_group_heading;

// node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte
Select_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte";
var root_240 = add_locations(from_html(`<div><!></div>`), Select_viewport[FILENAME], [[31, 1]]);
var $$css = {
  hash: "s-h2z5b8x4s9UG",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\n	[data-select-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n\n	[data-combobox-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n\n	[data-combobox-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n	[data-select-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LXZpZXdwb3J0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJzZWxlY3Qtdmlld3BvcnQuc3ZlbHRlIl19 */"
};
function Select_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_viewport);
  append_styles($$anchor, $$css);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const viewportState = SelectViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_240();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_viewport = hmr(Select_viewport, () => Select_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-h2z5b8x4s9UG");
    module.default[HMR].source = Select_viewport[HMR].source;
    set(Select_viewport[HMR].source, module.default[HMR].original);
  });
}
var select_viewport_default = Select_viewport;

// node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte
Select_scroll_down_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte";
var root_35 = add_locations(from_html(`<div><!></div>`), Select_scroll_down_button[FILENAME], [[36, 2]]);
var root_13 = add_locations(from_html(`<!> <!>`, 1), Select_scroll_down_button[FILENAME], []);
function Select_scroll_down_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_scroll_down_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "delay",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollButtonState = SelectScrollDownButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    delay: box.with(() => delay())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollButtonState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_13();
      var node_1 = first_child(fragment_1);
      validate_binding("bind:mounted={scrollButtonState.scrollButtonState.mounted}", () => scrollButtonState.scrollButtonState, () => "mounted", 32, 10);
      mounted_default(node_1, {
        get mounted() {
          return scrollButtonState.scrollButtonState.mounted;
        },
        set mounted($$value) {
          scrollButtonState.scrollButtonState.mounted = $$value;
        }
      });
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: restProps }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_35();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          snippet(node_4, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_2, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scrollButtonState.canScrollDown) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_down_button = hmr(Select_scroll_down_button, () => Select_scroll_down_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_down_button[HMR].source;
    set(Select_scroll_down_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_down_button_default = Select_scroll_down_button;

// node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte
Select_scroll_up_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte";
var root_36 = add_locations(from_html(`<div><!></div>`), Select_scroll_up_button[FILENAME], [[36, 2]]);
var root_14 = add_locations(from_html(`<!> <!>`, 1), Select_scroll_up_button[FILENAME], []);
function Select_scroll_up_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_scroll_up_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "delay",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollButtonState = SelectScrollUpButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    delay: box.with(() => delay())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollButtonState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_14();
      var node_1 = first_child(fragment_1);
      validate_binding("bind:mounted={scrollButtonState.scrollButtonState.mounted}", () => scrollButtonState.scrollButtonState, () => "mounted", 32, 10);
      mounted_default(node_1, {
        get mounted() {
          return scrollButtonState.scrollButtonState.mounted;
        },
        set mounted($$value) {
          scrollButtonState.scrollButtonState.mounted = $$value;
        }
      });
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.child, () => ({ props: restProps }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_36();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          snippet(node_4, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_2, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (scrollButtonState.canScrollUp) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_up_button = hmr(Select_scroll_up_button, () => Select_scroll_up_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_up_button[HMR].source;
    set(Select_scroll_up_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_up_button_default = Select_scroll_up_button;

// node_modules/bits-ui/dist/bits/command/exports.js
var exports_exports10 = {};
__export(exports_exports10, {
  Empty: () => command_empty_default,
  Group: () => command_group_default,
  GroupHeading: () => command_group_heading_default,
  GroupItems: () => command_group_items_default,
  Input: () => command_input_default,
  Item: () => command_item_default,
  LinkItem: () => command_link_item_default,
  List: () => command_list_default,
  Loading: () => command_loading_default,
  Root: () => command_default,
  Separator: () => command_separator_default,
  Viewport: () => command_viewport_default
});

// node_modules/bits-ui/dist/bits/command/utils.js
function findNextSibling(el, selector) {
  let sibling2 = el.nextElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling2 = el.previousElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.previousElementSibling;
  }
}

// node_modules/bits-ui/dist/internal/css-escape.js
function cssEscape(value) {
  if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
    return CSS.escape(value);
  }
  const length = value.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = value.charCodeAt(0);
  if (length === 1 && firstCodeUnit === 45)
    return "\\" + value;
  while (++index < length) {
    codeUnit = value.charCodeAt(index);
    if (codeUnit === 0) {
      result += "�";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      index === 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45
    ) {
      result += "\\" + codeUnit.toString(16) + " ";
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += value.charAt(index);
      continue;
    }
    result += "\\" + value.charAt(index);
  }
  return result;
}

// node_modules/bits-ui/dist/bits/command/command.svelte.js
var COMMAND_VALUE_ATTR = "data-value";
var commandAttrs = createBitsAttrs({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
});
var COMMAND_GROUP_SELECTOR = commandAttrs.selector("group");
var COMMAND_GROUP_ITEMS_SELECTOR = commandAttrs.selector("group-items");
var COMMAND_GROUP_HEADING_SELECTOR = commandAttrs.selector("group-heading");
var COMMAND_ITEM_SELECTOR = commandAttrs.selector("item");
var COMMAND_VALID_ITEM_SELECTOR = `${commandAttrs.selector("item")}:not([aria-disabled="true"])`;
var CommandRootContext = new Context("Command.Root");
var CommandListContext = new Context("Command.List");
var CommandGroupContainerContext = new Context("Command.Group");
var defaultState = {
  /** Value of the search query */
  search: "",
  /** Currently selected item value */
  value: "",
  filtered: {
    /** The count of all visible items. */
    count: 0,
    /** Map from visible item id to its search store. */
    items: /* @__PURE__ */ new Map(),
    /** Set of groups with at least one visible item. */
    groups: /* @__PURE__ */ new Set()
  }
};
var _updateScheduled, _isInitialMount, _key2, _viewportNode2, _inputNode2, _labelNode2, _commandState, __commandState, _CommandRootState_instances, snapshot_fn, scheduleUpdate_fn, score_fn, sort_fn, selectFirstItem_fn, filterItems_fn, getSelectedItem_fn, scrollSelectedIntoView_fn, itemIsFirstRowOfGroup_fn, last_fn, next_fn, down_fn, getColumn_fn, nextRowColumnOffset_fn, findNextNonDisabledItem_fn, calculateOffset_fn, up_fn, previousRowColumnOffset_fn, findNextNonDisabledItemDesc_fn, prev_fn, _props54;
var _CommandRootState = class _CommandRootState {
  constructor(opts) {
    __privateAdd(this, _CommandRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _updateScheduled, false);
    __privateAdd(this, _isInitialMount, true);
    __publicField(this, "sortAfterTick", false);
    __publicField(this, "sortAndFilterAfterTick", false);
    __publicField(this, "allItems", /* @__PURE__ */ new Set());
    __publicField(this, "allGroups", /* @__PURE__ */ new Map());
    __publicField(this, "allIds", /* @__PURE__ */ new Map());
    __privateAdd(this, _key2, tag(state(0), "CommandRootState.key"));
    __privateAdd(this, _viewportNode2, tag(state(null), "CommandRootState.viewportNode"));
    __privateAdd(this, _inputNode2, tag(state(null), "CommandRootState.inputNode"));
    __privateAdd(this, _labelNode2, tag(state(null), "CommandRootState.labelNode"));
    __privateAdd(this, _commandState, tag(state(defaultState), "CommandRootState.commandState"));
    __privateAdd(this, __commandState, tag(state(proxy(defaultState)), "CommandRootState._commandState"));
    __privateAdd(this, _props54, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "application",
        [commandAttrs.root]: "",
        tabindex: -1,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "CommandRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    const defaults = {
      ...this._commandState,
      value: this.opts.value.current ?? ""
    };
    this._commandState = defaults;
    this.commandState = defaults;
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return CommandRootContext.set(new _CommandRootState(opts));
  }
  get key() {
    return get(__privateGet(this, _key2));
  }
  set key(value) {
    set(__privateGet(this, _key2), value, true);
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode2));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode2), value, true);
  }
  get inputNode() {
    return get(__privateGet(this, _inputNode2));
  }
  set inputNode(value) {
    set(__privateGet(this, _inputNode2), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode2));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode2), value, true);
  }
  get commandState() {
    return get(__privateGet(this, _commandState));
  }
  set commandState(value) {
    set(__privateGet(this, _commandState), value);
  }
  get _commandState() {
    return get(__privateGet(this, __commandState));
  }
  set _commandState(value) {
    set(__privateGet(this, __commandState), value, true);
  }
  setState(key, value, preventScroll) {
    if (Object.is(this._commandState[key], value)) return;
    this._commandState[key] = value;
    if (strict_equals(key, "search")) {
      __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
      __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
    } else if (strict_equals(key, "value")) {
      if (!preventScroll) __privateMethod(this, _CommandRootState_instances, scrollSelectedIntoView_fn).call(this);
    }
    __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(value, opts) {
    if (strict_equals(value, this.opts.value.current, false) && strict_equals(value, "")) {
      afterTick(() => {
        this.key++;
      });
    }
    this.setState("value", value, opts);
    this.opts.value.current = value;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const validItems = Array.from(node.querySelectorAll(COMMAND_VALID_ITEM_SELECTOR)).filter((el) => !!el);
    return validItems;
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const visibleItems = Array.from(node.querySelectorAll(COMMAND_ITEM_SELECTOR)).filter((el) => !!el);
    return visibleItems;
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    var _a, _b, _c, _d;
    if (!this.isGrid) return [];
    const columns = this.opts.columns.current ?? 1;
    const items = this.getVisibleItems();
    const grid = [[]];
    let currentGroup = (_a = items[0]) == null ? void 0 : _a.getAttribute("data-group");
    let column = 0;
    let row = 0;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemGroup = item == null ? void 0 : item.getAttribute("data-group");
      if (strict_equals(currentGroup, itemGroup, false)) {
        currentGroup = itemGroup;
        column = 1;
        row++;
        grid.push([{ index: i, firstRowOfGroup: true, ref: item }]);
      } else {
        column++;
        if (column > columns) {
          row++;
          column = 1;
          grid.push([]);
        }
        (_d = grid[row]) == null ? void 0 : _d.push({
          index: i,
          firstRowOfGroup: ((_c = (_b = grid[row]) == null ? void 0 : _b[0]) == null ? void 0 : _c.firstRowOfGroup) ?? strict_equals(i, 0),
          ref: item
        });
      }
    }
    return grid;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(index) {
    const item = this.getValidItems()[index];
    if (!item) return;
    this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(change) {
    const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    const items = this.getValidItems();
    const index = items.findIndex((item) => strict_equals(item, selected));
    let newSelected = items[index + change];
    if (this.opts.loop.current) {
      newSelected = index + change < 0 ? items[items.length - 1] : strict_equals(index + change, items.length) ? items[0] : items[index + change];
    }
    if (newSelected) {
      this.setValue(newSelected.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    }
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(change) {
    const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    let group = selected == null ? void 0 : selected.closest(COMMAND_GROUP_SELECTOR);
    let item;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, COMMAND_GROUP_SELECTOR) : findPreviousSibling(group, COMMAND_GROUP_SELECTOR);
      item = group == null ? void 0 : group.querySelector(COMMAND_VALID_ITEM_SELECTOR);
    }
    if (item) {
      this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    } else {
      this.updateSelectedByItem(change);
    }
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(value, keywords) {
    var _a;
    if (!(value && strict_equals(value, (_a = this.allIds.get(value)) == null ? void 0 : _a.value))) {
      this.allIds.set(value, { value, keywords });
    }
    this._commandState.filtered.items.set(value, __privateMethod(this, _CommandRootState_instances, score_fn).call(this, value, keywords));
    if (!this.sortAfterTick) {
      this.sortAfterTick = true;
      afterTick(() => {
        __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
        this.sortAfterTick = false;
      });
    }
    return () => {
      this.allIds.delete(value);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(id, groupId) {
    this.allItems.add(id);
    if (groupId) {
      if (!this.allGroups.has(groupId)) {
        this.allGroups.set(groupId, /* @__PURE__ */ new Set([id]));
      } else {
        this.allGroups.get(groupId).add(id);
      }
    }
    if (!this.sortAndFilterAfterTick) {
      this.sortAndFilterAfterTick = true;
      afterTick(() => {
        __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
        __privateMethod(this, _CommandRootState_instances, sort_fn).call(this);
        this.sortAndFilterAfterTick = false;
      });
    }
    __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
    return () => {
      const selectedItem = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
      this.allIds.delete(id);
      this.allItems.delete(id);
      this.commandState.filtered.items.delete(id);
      __privateMethod(this, _CommandRootState_instances, filterItems_fn).call(this);
      if (strict_equals(selectedItem == null ? void 0 : selectedItem.getAttribute("id"), id)) {
        __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
      }
      __privateMethod(this, _CommandRootState_instances, scheduleUpdate_fn).call(this);
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(id) {
    if (!this.allGroups.has(id)) {
      this.allGroups.set(id, /* @__PURE__ */ new Set());
    }
    return () => {
      this.allIds.delete(id);
      this.allGroups.delete(id);
    };
  }
  get isGrid() {
    return strict_equals(this.opts.columns.current, null, false);
  }
  onkeydown(e) {
    const isVim = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case kbd_constants_exports.n:
      case kbd_constants_exports.j: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, down_fn).call(this, e);
          } else {
            __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.l: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.ARROW_DOWN:
        if (this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, down_fn).call(this, e);
        } else {
          __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (!this.isGrid) break;
        __privateMethod(this, _CommandRootState_instances, next_fn).call(this, e);
        break;
      case kbd_constants_exports.p:
      case kbd_constants_exports.k: {
        if (isVim) {
          if (this.isGrid) {
            __privateMethod(this, _CommandRootState_instances, up_fn).call(this, e);
          } else {
            __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
          }
        }
        break;
      }
      case kbd_constants_exports.h: {
        if (isVim && this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        }
        break;
      }
      case kbd_constants_exports.ARROW_UP:
        if (this.isGrid) {
          __privateMethod(this, _CommandRootState_instances, up_fn).call(this, e);
        } else {
          __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        }
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (!this.isGrid) break;
        __privateMethod(this, _CommandRootState_instances, prev_fn).call(this, e);
        break;
      case kbd_constants_exports.HOME:
        e.preventDefault();
        this.updateSelectedToIndex(0);
        break;
      case kbd_constants_exports.END:
        e.preventDefault();
        __privateMethod(this, _CommandRootState_instances, last_fn).call(this);
        break;
      case kbd_constants_exports.ENTER: {
        if (!e.isComposing && strict_equals(e.keyCode, 229, false)) {
          e.preventDefault();
          const item = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
          if (item) {
            item == null ? void 0 : item.click();
          }
        }
      }
    }
  }
  get props() {
    return get(__privateGet(this, _props54));
  }
  set props(value) {
    set(__privateGet(this, _props54), value);
  }
};
_updateScheduled = new WeakMap();
_isInitialMount = new WeakMap();
_key2 = new WeakMap();
_viewportNode2 = new WeakMap();
_inputNode2 = new WeakMap();
_labelNode2 = new WeakMap();
_commandState = new WeakMap();
__commandState = new WeakMap();
_CommandRootState_instances = new WeakSet();
snapshot_fn = function() {
  return snapshot(this._commandState);
};
scheduleUpdate_fn = function() {
  if (__privateGet(this, _updateScheduled)) return;
  __privateSet(this, _updateScheduled, true);
  afterTick(() => {
    var _a, _b;
    __privateSet(this, _updateScheduled, false);
    const currentState = __privateMethod(this, _CommandRootState_instances, snapshot_fn).call(this);
    const hasStateChanged = !Object.is(this.commandState, currentState);
    if (hasStateChanged) {
      this.commandState = currentState;
      (_b = (_a = this.opts.onStateChange) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a, currentState);
    }
  });
};
/**
 * Calculates score for an item based on search text and keywords.
 * Higher score = better match.
 *
 * @param value - Item's display text
 * @param keywords - Optional keywords to boost scoring
 * @returns Score from 0-1, where 0 = no match
 */
score_fn = function(value, keywords) {
  const filter = this.opts.filter.current ?? computeCommandScore;
  const score = value ? filter(value, this._commandState.search, keywords) : 0;
  return score;
};
/**
 * Sorts items and groups based on search scores.
 * Groups are sorted by their highest scoring item.
 * When no search active, selects first item.
 */
sort_fn = function() {
  var _a;
  if (!this._commandState.search || strict_equals(this.opts.shouldFilter.current, false)) {
    __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
    return;
  }
  const scores = this._commandState.filtered.items;
  const groups = [];
  for (const value of this._commandState.filtered.groups) {
    const items = this.allGroups.get(value);
    let max = 0;
    if (!items) {
      groups.push([value, max]);
      continue;
    }
    for (const item of items) {
      const score = scores.get(item);
      max = Math.max(score ?? 0, max);
    }
    groups.push([value, max]);
  }
  const listInsertionElement = this.viewportNode;
  const sorted = this.getValidItems().sort((a2, b) => {
    const valueA = a2.getAttribute("data-value");
    const valueB = b.getAttribute("data-value");
    const scoresA = scores.get(valueA) ?? 0;
    const scoresB = scores.get(valueB) ?? 0;
    return scoresB - scoresA;
  });
  for (const item of sorted) {
    const group = item.closest(COMMAND_GROUP_ITEMS_SELECTOR);
    if (group) {
      const itemToAppend = strict_equals(item.parentElement, group) ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
      if (itemToAppend) {
        group.appendChild(itemToAppend);
      }
    } else {
      const itemToAppend = strict_equals(item.parentElement, listInsertionElement) ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
      if (itemToAppend) {
        listInsertionElement == null ? void 0 : listInsertionElement.appendChild(itemToAppend);
      }
    }
  }
  const sortedGroups = groups.sort((a2, b) => b[1] - a2[1]);
  for (const group of sortedGroups) {
    const element2 = listInsertionElement == null ? void 0 : listInsertionElement.querySelector(`${COMMAND_GROUP_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(group[0])}"]`);
    (_a = element2 == null ? void 0 : element2.parentElement) == null ? void 0 : _a.appendChild(element2);
  }
  __privateMethod(this, _CommandRootState_instances, selectFirstItem_fn).call(this);
};
/**
 * Selects first non-disabled item on next tick.
 */
selectFirstItem_fn = function() {
  afterTick(() => {
    const item = this.getValidItems().find((item2) => strict_equals(item2.getAttribute("aria-disabled"), "true", false));
    const value = item == null ? void 0 : item.getAttribute(COMMAND_VALUE_ATTR);
    const shouldPreventScroll = __privateGet(this, _isInitialMount) && this.opts.disableInitialScroll.current;
    this.setValue(value ?? "", shouldPreventScroll);
    __privateSet(this, _isInitialMount, false);
  });
};
/**
 * Updates filtered items/groups based on search.
 * Recalculates scores and filtered count.
 */
filterItems_fn = function() {
  var _a, _b;
  if (!this._commandState.search || strict_equals(this.opts.shouldFilter.current, false)) {
    this._commandState.filtered.count = this.allItems.size;
    return;
  }
  this._commandState.filtered.groups = /* @__PURE__ */ new Set();
  let itemCount = 0;
  for (const id of this.allItems) {
    const value = ((_a = this.allIds.get(id)) == null ? void 0 : _a.value) ?? "";
    const keywords = ((_b = this.allIds.get(id)) == null ? void 0 : _b.keywords) ?? [];
    const rank = __privateMethod(this, _CommandRootState_instances, score_fn).call(this, value, keywords);
    this._commandState.filtered.items.set(id, rank);
    if (rank > 0) itemCount++;
  }
  for (const [groupId, group] of this.allGroups) {
    for (const itemId of group) {
      const currItem = this._commandState.filtered.items.get(itemId);
      if (currItem && currItem > 0) {
        this._commandState.filtered.groups.add(groupId);
        break;
      }
    }
  }
  this._commandState.filtered.count = itemCount;
};
/**
 * Gets currently selected command item.
 *
 * @returns Selected element or undefined
 */
getSelectedItem_fn = function() {
  const node = this.opts.ref.current;
  if (!node) return;
  const selectedNode = node.querySelector(`${COMMAND_VALID_ITEM_SELECTOR}[data-selected]`);
  if (!selectedNode) return;
  return selectedNode;
};
/**
 * Scrolls selected item into view.
 * Special handling for first items in groups.
 */
scrollSelectedIntoView_fn = function() {
  afterTick(() => {
    var _a, _b, _c, _d, _e;
    const item = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
    if (!item) return;
    const grandparent = (_a = item.parentElement) == null ? void 0 : _a.parentElement;
    if (!grandparent) return;
    if (this.isGrid) {
      const isFirstRowOfGroup = __privateMethod(this, _CommandRootState_instances, itemIsFirstRowOfGroup_fn).call(this, item);
      item.scrollIntoView({ block: "nearest" });
      if (isFirstRowOfGroup) {
        const closestGroupHeader = (_b = item == null ? void 0 : item.closest(COMMAND_GROUP_SELECTOR)) == null ? void 0 : _b.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
        closestGroupHeader == null ? void 0 : closestGroupHeader.scrollIntoView({ block: "nearest" });
        return;
      }
    } else {
      const firstChildOfParent = getFirstNonCommentChild(grandparent);
      if (firstChildOfParent && strict_equals((_c = firstChildOfParent.dataset) == null ? void 0 : _c.value, (_d = item.dataset) == null ? void 0 : _d.value)) {
        const closestGroupHeader = (_e = item == null ? void 0 : item.closest(COMMAND_GROUP_SELECTOR)) == null ? void 0 : _e.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
        closestGroupHeader == null ? void 0 : closestGroupHeader.scrollIntoView({ block: "nearest" });
        return;
      }
    }
    item.scrollIntoView({ block: "nearest" });
  });
};
itemIsFirstRowOfGroup_fn = function(item) {
  const grid = this.itemsGrid;
  if (strict_equals(grid.length, 0)) return false;
  for (let r = 0; r < grid.length; r++) {
    const row = grid[r];
    if (strict_equals(row, void 0)) continue;
    for (let c = 0; c < row.length; c++) {
      const column = row[c];
      if (strict_equals(column, void 0) || strict_equals(column.ref, item, false)) continue;
      return column.firstRowOfGroup;
    }
  }
  return false;
};
/**
 * Selects last valid item.
 */
last_fn = function() {
  return this.updateSelectedToIndex(this.getValidItems().length - 1);
};
/**
 * Handles next item selection:
 * - Meta: Jump to last
 * - Alt: Next group
 * - Default: Next item
 *
 * @param e - Keyboard event
 */
next_fn = function(e) {
  e.preventDefault();
  if (e.metaKey) {
    __privateMethod(this, _CommandRootState_instances, last_fn).call(this);
  } else if (e.altKey) {
    this.updateSelectedByGroup(1);
  } else {
    this.updateSelectedByItem(1);
  }
};
down_fn = function(e) {
  if (strict_equals(this.opts.columns.current, null)) return;
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedByGroup(1);
  } else {
    this.updateSelectedByItem(__privateMethod(this, _CommandRootState_instances, nextRowColumnOffset_fn).call(this, e));
  }
};
getColumn_fn = function(item, grid) {
  if (strict_equals(grid.length, 0)) return null;
  for (let r = 0; r < grid.length; r++) {
    const row = grid[r];
    if (strict_equals(row, void 0)) continue;
    for (let c = 0; c < row.length; c++) {
      const column = row[c];
      if (strict_equals(column, void 0) || strict_equals(column.ref, item, false)) continue;
      return { columnIndex: c, rowIndex: r };
    }
  }
  return null;
};
nextRowColumnOffset_fn = function(e) {
  const grid = this.itemsGrid;
  const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
  if (!selected) return 0;
  const column = __privateMethod(this, _CommandRootState_instances, getColumn_fn).call(this, selected, grid);
  if (!column) return 0;
  let newItem = null;
  const skipRows = e.altKey ? 1 : 0;
  if (e.altKey && strict_equals(column.rowIndex, grid.length - 2) && !this.opts.loop.current) {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: grid.length - 1,
      end: grid.length,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else if (strict_equals(column.rowIndex, grid.length - 1)) {
    if (!this.opts.loop.current) return 0;
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: 0 + skipRows,
      end: column.rowIndex,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
      start: column.rowIndex + 1 + skipRows,
      end: grid.length,
      expectedColumnIndex: column.columnIndex,
      grid
    });
    if (strict_equals(newItem, null) && this.opts.loop.current) {
      newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItem_fn).call(this, {
        start: 0,
        end: column.rowIndex,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    }
  }
  return __privateMethod(this, _CommandRootState_instances, calculateOffset_fn).call(this, selected, newItem);
};
/** Attempts to find the next non-disabled column that matches the expected column.
 *
 * @remarks
 * - Skips over disabled columns
 * - When a row is shorter than the expected column it defaults to the last item in the row
 *
 * @param param0
 * @returns
 */
findNextNonDisabledItem_fn = function({ start, end, grid, expectedColumnIndex }) {
  var _a;
  let newItem = null;
  for (let r = start; r < end; r++) {
    const row = grid[r];
    newItem = ((_a = row[expectedColumnIndex]) == null ? void 0 : _a.ref) ?? null;
    if (strict_equals(newItem, null, false) && itemIsDisabled(newItem)) {
      newItem = null;
      continue;
    }
    if (strict_equals(newItem, null)) {
      for (let i = row.length - 1; i >= 0; i--) {
        const item = row[row.length - 1];
        if (strict_equals(item, void 0) || itemIsDisabled(item.ref)) continue;
        newItem = item.ref;
        break;
      }
    }
    break;
  }
  return newItem;
};
calculateOffset_fn = function(selected, newSelected) {
  if (strict_equals(newSelected, null)) return 0;
  const items = this.getValidItems();
  const ogIndex = items.findIndex((item) => strict_equals(item, selected));
  const newIndex = items.findIndex((item) => strict_equals(item, newSelected));
  return newIndex - ogIndex;
};
up_fn = function(e) {
  if (strict_equals(this.opts.columns.current, null)) return;
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedByGroup(-1);
  } else {
    this.updateSelectedByItem(__privateMethod(this, _CommandRootState_instances, previousRowColumnOffset_fn).call(this, e));
  }
};
previousRowColumnOffset_fn = function(e) {
  const grid = this.itemsGrid;
  const selected = __privateMethod(this, _CommandRootState_instances, getSelectedItem_fn).call(this);
  if (strict_equals(selected, void 0)) return 0;
  const column = __privateMethod(this, _CommandRootState_instances, getColumn_fn).call(this, selected, grid);
  if (strict_equals(column, null)) return 0;
  let newItem = null;
  const skipRows = e.altKey ? 1 : 0;
  if (e.altKey && strict_equals(column.rowIndex, 1) && strict_equals(this.opts.loop.current, false)) {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: 0,
      end: 0,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else if (strict_equals(column.rowIndex, 0)) {
    if (strict_equals(this.opts.loop.current, false)) return 0;
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: grid.length - 1 - skipRows,
      end: column.rowIndex + 1,
      expectedColumnIndex: column.columnIndex,
      grid
    });
  } else {
    newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
      start: column.rowIndex - 1 - skipRows,
      end: 0,
      expectedColumnIndex: column.columnIndex,
      grid
    });
    if (strict_equals(newItem, null) && this.opts.loop.current) {
      newItem = __privateMethod(this, _CommandRootState_instances, findNextNonDisabledItemDesc_fn).call(this, {
        start: grid.length - 1,
        end: column.rowIndex + 1,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    }
  }
  return __privateMethod(this, _CommandRootState_instances, calculateOffset_fn).call(this, selected, newItem);
};
/**
 * Attempts to find the next non-disabled column that matches the expected column.
 *
 * @remarks
 * - Skips over disabled columns
 * - When a row is shorter than the expected column it defaults to the last item in the row
 */
findNextNonDisabledItemDesc_fn = function({ start, end, grid, expectedColumnIndex }) {
  var _a;
  let newItem = null;
  for (let r = start; r >= end; r--) {
    const row = grid[r];
    if (strict_equals(row, void 0)) continue;
    newItem = ((_a = row[expectedColumnIndex]) == null ? void 0 : _a.ref) ?? null;
    if (strict_equals(newItem, null, false) && itemIsDisabled(newItem)) {
      newItem = null;
      continue;
    }
    if (strict_equals(newItem, null)) {
      for (let i = row.length - 1; i >= 0; i--) {
        const item = row[row.length - 1];
        if (strict_equals(item, void 0) || itemIsDisabled(item.ref)) continue;
        newItem = item.ref;
        break;
      }
    }
    break;
  }
  return newItem;
};
/**
 * Handles previous item selection:
 * - Meta: Jump to first
 * - Alt: Previous group
 * - Default: Previous item
 *
 * @param e - Keyboard event
 */
prev_fn = function(e) {
  e.preventDefault();
  if (e.metaKey) {
    this.updateSelectedToIndex(0);
  } else if (e.altKey) {
    this.updateSelectedByGroup(-1);
  } else {
    this.updateSelectedByItem(-1);
  }
};
_props54 = new WeakMap();
var CommandRootState = _CommandRootState;
function itemIsDisabled(item) {
  return strict_equals(item.getAttribute("aria-disabled"), "true");
}
var _shouldRender3, _isInitialRender, _props55;
var _CommandEmptyState = class _CommandEmptyState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender3, tag(
      user_derived(() => {
        return strict_equals(this.root._commandState.filtered.count, 0) && strict_equals(__privateGet(this, _isInitialRender), false) || this.opts.forceMount.current;
      }),
      "CommandEmptyState.shouldRender"
    ));
    __privateAdd(this, _isInitialRender, true);
    __privateAdd(this, _props55, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "presentation",
        [commandAttrs.empty]: "",
        ...this.attachment
      })),
      "CommandEmptyState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_pre_effect(() => {
      __privateSet(this, _isInitialRender, false);
    });
  }
  static create(opts) {
    return new _CommandEmptyState(opts, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender3));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender3), value);
  }
  get props() {
    return get(__privateGet(this, _props55));
  }
  set props(value) {
    set(__privateGet(this, _props55), value);
  }
};
_shouldRender3 = new WeakMap();
_isInitialRender = new WeakMap();
_props55 = new WeakMap();
var CommandEmptyState = _CommandEmptyState;
var _shouldRender4, _headingNode, _trueValue, _props56;
var _CommandGroupContainerState = class _CommandGroupContainerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender4, tag(
      user_derived(() => {
        if (this.opts.forceMount.current) return true;
        if (strict_equals(this.root.opts.shouldFilter.current, false)) return true;
        if (!this.root.commandState.search) return true;
        return this.root._commandState.filtered.groups.has(this.trueValue);
      }),
      "CommandGroupContainerState.shouldRender"
    ));
    __privateAdd(this, _headingNode, tag(state(null), "CommandGroupContainerState.headingNode"));
    __privateAdd(this, _trueValue, tag(state(""), "CommandGroupContainerState.trueValue"));
    __privateAdd(this, _props56, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "presentation",
        hidden: this.shouldRender ? void 0 : true,
        "data-value": this.trueValue,
        [commandAttrs.group]: "",
        ...this.attachment
      })),
      "CommandGroupContainerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.trueValue = opts.value.current ?? opts.id.current;
    watch(() => this.trueValue, () => {
      return this.root.registerGroup(this.trueValue);
    });
    user_effect(() => {
      if (this.opts.value.current) {
        this.trueValue = this.opts.value.current;
        return this.root.registerValue(this.opts.value.current);
      } else if (this.headingNode && this.headingNode.textContent) {
        this.trueValue = this.headingNode.textContent.trim().toLowerCase();
        return this.root.registerValue(this.trueValue);
      } else {
        this.trueValue = `-----${this.opts.id.current}`;
        return this.root.registerValue(this.trueValue);
      }
    });
  }
  static create(opts) {
    return CommandGroupContainerContext.set(new _CommandGroupContainerState(opts, CommandRootContext.get()));
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender4));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender4), value);
  }
  get headingNode() {
    return get(__privateGet(this, _headingNode));
  }
  set headingNode(value) {
    set(__privateGet(this, _headingNode), value, true);
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue), value, true);
  }
  get props() {
    return get(__privateGet(this, _props56));
  }
  set props(value) {
    set(__privateGet(this, _props56), value);
  }
};
_shouldRender4 = new WeakMap();
_headingNode = new WeakMap();
_trueValue = new WeakMap();
_props56 = new WeakMap();
var CommandGroupContainerState = _CommandGroupContainerState;
var _props57;
var _CommandGroupHeadingState = class _CommandGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props57, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [commandAttrs["group-heading"]]: "",
        ...this.attachment
      })),
      "CommandGroupHeadingState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.headingNode = v);
  }
  static create(opts) {
    return new _CommandGroupHeadingState(opts, CommandGroupContainerContext.get());
  }
  get props() {
    return get(__privateGet(this, _props57));
  }
  set props(value) {
    set(__privateGet(this, _props57), value);
  }
};
_props57 = new WeakMap();
var CommandGroupHeadingState = _CommandGroupHeadingState;
var _props58;
var _CommandGroupItemsState = class _CommandGroupItemsState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props58, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          role: "group",
          [commandAttrs["group-items"]]: "",
          "aria-labelledby": ((_a = this.group.headingNode) == null ? void 0 : _a.id) ?? void 0,
          ...this.attachment
        };
      }),
      "CommandGroupItemsState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandGroupItemsState(opts, CommandGroupContainerContext.get());
  }
  get props() {
    return get(__privateGet(this, _props58));
  }
  set props(value) {
    set(__privateGet(this, _props58), value);
  }
};
_props58 = new WeakMap();
var CommandGroupItemsState = _CommandGroupItemsState;
var _selectedItemId, _props59;
var _CommandInputState = class _CommandInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _selectedItemId, tag(
      user_derived(() => {
        var _a;
        const item = (_a = this.root.viewportNode) == null ? void 0 : _a.querySelector(`${COMMAND_ITEM_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(this.root.opts.value.current)}"]`);
        if (strict_equals(item, void 0) || strict_equals(item, null)) return;
        return item.getAttribute("id") ?? void 0;
      }),
      "CommandInputState.#selectedItemId"
    ));
    __privateAdd(this, _props59, tag(
      user_derived(() => {
        var _a, _b;
        return {
          id: this.opts.id.current,
          type: "text",
          [commandAttrs.input]: "",
          autocomplete: "off",
          autocorrect: "off",
          spellcheck: false,
          "aria-autocomplete": "list",
          role: "combobox",
          "aria-expanded": getAriaExpanded(true),
          "aria-controls": ((_a = this.root.viewportNode) == null ? void 0 : _a.id) ?? void 0,
          "aria-labelledby": ((_b = this.root.labelNode) == null ? void 0 : _b.id) ?? void 0,
          "aria-activedescendant": get(__privateGet(this, _selectedItemId)),
          ...this.attachment
        };
      }),
      "CommandInputState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.inputNode = v);
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (node && this.opts.autofocus.current) {
        afterSleep(10, () => node.focus());
      }
    });
    watch(() => this.opts.value.current, () => {
      if (strict_equals(this.root.commandState.search, this.opts.value.current, false)) {
        this.root.setState("search", this.opts.value.current);
      }
    });
  }
  static create(opts) {
    return new _CommandInputState(opts, CommandRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props59));
  }
  set props(value) {
    set(__privateGet(this, _props59), value);
  }
};
_selectedItemId = new WeakMap();
_props59 = new WeakMap();
var CommandInputState = _CommandInputState;
var _group, _trueForceMount, _shouldRender5, _isSelected2, _trueValue2, _CommandItemState_instances, onSelect_fn, select_fn, _props60;
var _CommandItemState = class _CommandItemState {
  constructor(opts, root18) {
    __privateAdd(this, _CommandItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _group, null);
    __privateAdd(this, _trueForceMount, tag(
      user_derived(() => {
        var _a;
        return this.opts.forceMount.current || strict_equals((_a = __privateGet(this, _group)) == null ? void 0 : _a.opts.forceMount.current, true);
      }),
      "CommandItemState.#trueForceMount"
    ));
    __privateAdd(this, _shouldRender5, tag(
      user_derived(() => {
        this.opts.ref.current;
        if (get(__privateGet(this, _trueForceMount)) || strict_equals(this.root.opts.shouldFilter.current, false) || !this.root.commandState.search) {
          return true;
        }
        const currentScore = this.root.commandState.filtered.items.get(this.trueValue);
        if (strict_equals(currentScore, void 0)) return false;
        return currentScore > 0;
      }),
      "CommandItemState.shouldRender"
    ));
    __privateAdd(this, _isSelected2, tag(user_derived(() => strict_equals(this.root.opts.value.current, this.trueValue) && strict_equals(this.trueValue, "", false)), "CommandItemState.isSelected"));
    __privateAdd(this, _trueValue2, tag(state(""), "CommandItemState.trueValue"));
    __privateAdd(this, _props60, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          "aria-disabled": getAriaDisabled(this.opts.disabled.current),
          "aria-selected": getAriaSelected(this.isSelected),
          "data-disabled": getDataDisabled(this.opts.disabled.current),
          "data-selected": getDataSelected(this.isSelected),
          "data-value": this.trueValue,
          "data-group": (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue,
          [commandAttrs.item]: "",
          role: "option",
          onpointermove: this.onpointermove,
          onclick: this.onclick,
          ...this.attachment
        };
      }),
      "CommandItemState.props"
    ));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _group, CommandGroupContainerContext.getOr(null));
    this.trueValue = opts.value.current;
    this.attachment = attachRef(this.opts.ref);
    watch(
      [
        () => this.trueValue,
        () => {
          var _a;
          return (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue;
        },
        () => this.opts.forceMount.current
      ],
      () => {
        var _a;
        if (this.opts.forceMount.current) return;
        return this.root.registerItem(this.trueValue, (_a = __privateGet(this, _group)) == null ? void 0 : _a.trueValue);
      }
    );
    watch(
      [
        () => this.opts.value.current,
        () => this.opts.ref.current
      ],
      () => {
        var _a, _b;
        if (!this.opts.value.current && ((_a = this.opts.ref.current) == null ? void 0 : _a.textContent)) {
          this.trueValue = this.opts.ref.current.textContent.trim();
        }
        this.root.registerValue(this.trueValue, opts.keywords.current.map((kw) => kw.trim()));
        (_b = this.opts.ref.current) == null ? void 0 : _b.setAttribute(COMMAND_VALUE_ATTR, this.trueValue);
      }
    );
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    const group = CommandGroupContainerContext.getOr(null);
    return new _CommandItemState({ ...opts, group }, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender5));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender5), value);
  }
  get isSelected() {
    return get(__privateGet(this, _isSelected2));
  }
  set isSelected(value) {
    set(__privateGet(this, _isSelected2), value);
  }
  get trueValue() {
    return get(__privateGet(this, _trueValue2));
  }
  set trueValue(value) {
    set(__privateGet(this, _trueValue2), value, true);
  }
  onpointermove(_) {
    if (this.opts.disabled.current || this.root.opts.disablePointerSelection.current) return;
    __privateMethod(this, _CommandItemState_instances, select_fn).call(this);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _CommandItemState_instances, onSelect_fn).call(this);
  }
  get props() {
    return get(__privateGet(this, _props60));
  }
  set props(value) {
    set(__privateGet(this, _props60), value);
  }
};
_group = new WeakMap();
_trueForceMount = new WeakMap();
_shouldRender5 = new WeakMap();
_isSelected2 = new WeakMap();
_trueValue2 = new WeakMap();
_CommandItemState_instances = new WeakSet();
onSelect_fn = function() {
  var _a;
  if (this.opts.disabled.current) return;
  __privateMethod(this, _CommandItemState_instances, select_fn).call(this);
  (_a = this.opts.onSelect) == null ? void 0 : _a.current();
};
select_fn = function() {
  if (this.opts.disabled.current) return;
  this.root.setValue(this.trueValue, true);
};
_props60 = new WeakMap();
var CommandItemState = _CommandItemState;
var _props61;
var _CommandLoadingState = class _CommandLoadingState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props61, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "progressbar",
        "aria-valuenow": this.opts.progress.current,
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-label": "Loading...",
        [commandAttrs.loading]: "",
        ...this.attachment
      })),
      "CommandLoadingState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandLoadingState(opts);
  }
  get props() {
    return get(__privateGet(this, _props61));
  }
  set props(value) {
    set(__privateGet(this, _props61), value);
  }
};
_props61 = new WeakMap();
var CommandLoadingState = _CommandLoadingState;
var _shouldRender6, _props62;
var _CommandSeparatorState = class _CommandSeparatorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _shouldRender6, tag(user_derived(() => !this.root._commandState.search || this.opts.forceMount.current), "CommandSeparatorState.shouldRender"));
    __privateAdd(this, _props62, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        // role="separator" cannot belong to a role="listbox"
        "aria-hidden": "true",
        [commandAttrs.separator]: "",
        ...this.attachment
      })),
      "CommandSeparatorState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _CommandSeparatorState(opts, CommandRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender6));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender6), value);
  }
  get props() {
    return get(__privateGet(this, _props62));
  }
  set props(value) {
    set(__privateGet(this, _props62), value);
  }
};
_shouldRender6 = new WeakMap();
_props62 = new WeakMap();
var CommandSeparatorState = _CommandSeparatorState;
var _props63;
var _CommandListState = class _CommandListState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props63, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "listbox",
        "aria-label": this.opts.ariaLabel.current,
        [commandAttrs.list]: "",
        ...this.attachment
      })),
      "CommandListState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return CommandListContext.set(new _CommandListState(opts, CommandRootContext.get()));
  }
  get props() {
    return get(__privateGet(this, _props63));
  }
  set props(value) {
    set(__privateGet(this, _props63), value);
  }
};
_props63 = new WeakMap();
var CommandListState = _CommandListState;
var _props64;
var _CommandLabelState = class _CommandLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props64, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          [commandAttrs["input-label"]]: "",
          for: (_a = this.opts.for) == null ? void 0 : _a.current,
          style: srOnlyStyles,
          ...this.attachment
        };
      }),
      "CommandLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _CommandLabelState(opts, CommandRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props64));
  }
  set props(value) {
    set(__privateGet(this, _props64), value);
  }
};
_props64 = new WeakMap();
var CommandLabelState = _CommandLabelState;
var _props65;
var _CommandViewportState = class _CommandViewportState {
  constructor(opts, list) {
    __publicField(this, "opts");
    __publicField(this, "list");
    __publicField(this, "attachment");
    __privateAdd(this, _props65, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [commandAttrs.viewport]: "",
        ...this.attachment
      })),
      "CommandViewportState.props"
    ));
    this.opts = opts;
    this.list = list;
    this.attachment = attachRef(this.opts.ref, (v) => this.list.root.viewportNode = v);
    watch(
      [
        () => this.opts.ref.current,
        () => this.list.opts.ref.current
      ],
      ([node, listNode]) => {
        if (strict_equals(node, null) || strict_equals(listNode, null)) return;
        let aF;
        const observer = new ResizeObserver(() => {
          aF = requestAnimationFrame(() => {
            const height = node.offsetHeight;
            listNode.style.setProperty("--bits-command-list-height", `${height.toFixed(1)}px`);
          });
        });
        observer.observe(node);
        return () => {
          cancelAnimationFrame(aF);
          observer.unobserve(node);
        };
      }
    );
  }
  static create(opts) {
    return new _CommandViewportState(opts, CommandListContext.get());
  }
  get props() {
    return get(__privateGet(this, _props65));
  }
  set props(value) {
    set(__privateGet(this, _props65), value);
  }
};
_props65 = new WeakMap();
var CommandViewportState = _CommandViewportState;

// node_modules/bits-ui/dist/bits/command/components/_command-label.svelte
_command_label[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/_command-label.svelte";
var root5 = add_locations(from_html(`<label><!></label>`), _command_label[FILENAME], [[29, 0]]);
function _command_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, _command_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children"
    ],
    "restProps"
  );
  const labelState = CommandLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var label = root5();
  attribute_effect(label, () => ({ ...get(mergedProps) }));
  var node = child(label);
  snippet(node, () => $$props.children ?? noop);
  reset(label);
  append($$anchor, label);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  _command_label = hmr(_command_label, () => _command_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = _command_label[HMR].source;
    set(_command_label[HMR].source, module.default[HMR].original);
  });
}
var command_label_default = _command_label;

// node_modules/bits-ui/dist/bits/command/components/command.svelte
Command[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command.svelte";
var root_37 = add_locations(from_html(`<!> <!>`, 1), Command[FILENAME], []);
var root_44 = add_locations(from_html(`<div><!> <!></div>`), Command[FILENAME], [[133, 1]]);
function Command($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command);
  const Label2 = wrap_snippet(Command, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    command_label_default(node, {
      children: wrap_snippet(Command, ($$anchor3, $$slotProps) => {
        next();
        var text2 = text();
        template_effect(() => set_text(text2, label()));
        append($$anchor3, text2);
      }),
      $$slots: { default: true }
    });
    append($$anchor2, fragment);
  });
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), onStateChange = prop($$props, "onStateChange", 3, noop3), loop = prop($$props, "loop", 3, false), shouldFilter = prop($$props, "shouldFilter", 3, true), filter = prop($$props, "filter", 3, computeCommandScore), label = prop($$props, "label", 3, ""), vimBindings = prop($$props, "vimBindings", 3, true), disablePointerSelection = prop($$props, "disablePointerSelection", 3, false), disableInitialScroll = prop($$props, "disableInitialScroll", 3, false), columns = prop($$props, "columns", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "onStateChange",
      "loop",
      "shouldFilter",
      "filter",
      "label",
      "vimBindings",
      "disablePointerSelection",
      "disableInitialScroll",
      "columns",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = CommandRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    filter: box.with(() => filter()),
    shouldFilter: box.with(() => shouldFilter()),
    loop: box.with(() => loop()),
    value: box.with(() => value(), (v) => {
      if (strict_equals(value(), v, false)) {
        value(v);
        onValueChange()(v);
      }
    }),
    vimBindings: box.with(() => vimBindings()),
    disablePointerSelection: box.with(() => disablePointerSelection()),
    disableInitialScroll: box.with(() => disableInitialScroll()),
    onStateChange: box.with(() => onStateChange()),
    columns: box.with(() => columns())
  });
  const updateSelectedToIndex = (i) => rootState.updateSelectedToIndex(i);
  const updateSelectedByGroup = (c) => rootState.updateSelectedByGroup(c);
  const updateSelectedByItem = (c) => rootState.updateSelectedByItem(c);
  const getValidItems = () => rootState.getValidItems();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment_2 = comment();
  var node_1 = first_child(fragment_2);
  {
    var consequent = ($$anchor2) => {
      var fragment_3 = root_37();
      var node_2 = first_child(fragment_3);
      Label2(node_2);
      var node_3 = sibling(node_2, 2);
      snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_3);
    };
    var alternate = ($$anchor2) => {
      var div = root_44();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_4 = child(div);
      Label2(node_4);
      var node_5 = sibling(node_4, 2);
      snippet(node_5, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment_2);
  return pop({
    get updateSelectedToIndex() {
      return updateSelectedToIndex;
    },
    get updateSelectedByGroup() {
      return updateSelectedByGroup;
    },
    get updateSelectedByItem() {
      return updateSelectedByItem;
    },
    get getValidItems() {
      return getValidItems;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Command = hmr(Command, () => Command[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command[HMR].source;
    set(Command[HMR].source, module.default[HMR].original);
  });
}
var command_default = Command;

// node_modules/bits-ui/dist/bits/command/components/command-empty.svelte
Command_empty[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-empty.svelte";
var root_38 = add_locations(from_html(`<div><!></div>`), Command_empty[FILENAME], [[34, 2]]);
function Command_empty($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_empty);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const emptyState = CommandEmptyState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = tag(user_derived(() => mergeProps(emptyState.props, restProps)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_38();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (emptyState.shouldRender) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_empty = hmr(Command_empty, () => Command_empty[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_empty[HMR].source;
    set(Command_empty[HMR].source, module.default[HMR].original);
  });
}
var command_empty_default = Command_empty;

// node_modules/bits-ui/dist/bits/command/components/command-group.svelte
Command_group[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group.svelte";
var root_241 = add_locations(from_html(`<div><!></div>`), Command_group[FILENAME], [[35, 1]]);
function Command_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = CommandGroupContainerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount()),
    value: box.with(() => value())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_241();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group = hmr(Command_group, () => Command_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group[HMR].source;
    set(Command_group[HMR].source, module.default[HMR].original);
  });
}
var command_group_default = Command_group;

// node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte
Command_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte";
var root_242 = add_locations(from_html(`<div><!></div>`), Command_group_heading[FILENAME], [[31, 1]]);
function Command_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group_heading);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const headingState = CommandGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_242();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_heading = hmr(Command_group_heading, () => Command_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_heading[HMR].source;
    set(Command_group_heading[HMR].source, module.default[HMR].original);
  });
}
var command_group_heading_default = Command_group_heading;

// node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte
Command_group_items[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte";
var root_243 = add_locations(from_html(`<div><!></div>`), Command_group_items[FILENAME], [[32, 2]]);
var root6 = add_locations(from_html(`<div style="display: contents;"><!></div>`), Command_group_items[FILENAME], [[28, 0]]);
function Command_group_items($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group_items);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupItemsState = CommandGroupItemsState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupItemsState.props)), "mergedProps");
  var div = root6();
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_243();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div_1);
      append($$anchor2, div_1);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_items = hmr(Command_group_items, () => Command_group_items[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_items[HMR].source;
    set(Command_group_items[HMR].source, module.default[HMR].original);
  });
}
var command_group_items_default = Command_group_items;

// node_modules/bits-ui/dist/bits/command/components/command-input.svelte
Command_input[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-input.svelte";
var root_244 = add_locations(from_html(`<input/>`), Command_input[FILENAME], [[39, 1]]);
function Command_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_input);
  let value = prop($$props, "value", 15, ""), autofocus = prop($$props, "autofocus", 3, false), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "autofocus",
      "id",
      "ref",
      "child"
    ],
    "restProps"
  );
  const inputState = CommandInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
    }),
    autofocus: box.with(() => autofocus() ?? false)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_244();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps) }));
      bind_value(input, value);
      append($$anchor2, input);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_input = hmr(Command_input, () => Command_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_input[HMR].source;
    set(Command_input[HMR].source, module.default[HMR].original);
  });
}
var command_input_default = Command_input;

// node_modules/bits-ui/dist/bits/command/components/command-item.svelte
Command_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-item.svelte";
var root_45 = add_locations(from_html(`<div><!></div>`), Command_item[FILENAME], [[45, 4]]);
var root_15 = add_locations(from_html(`<div style="display: contents;" data-item-wrapper=""><!></div>`), Command_item[FILENAME], [[40, 1]]);
function Command_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const itemState = CommandItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_15();
    var node_1 = child(div);
    {
      var consequent_1 = ($$anchor3) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var div_1 = root_45();
            attribute_effect(div_1, () => ({ ...get(mergedProps) }));
            var node_4 = child(div_1);
            snippet(node_4, () => $$props.children ?? noop);
            reset(div_1);
            append($$anchor4, div_1);
          };
          if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      };
      if_block(node_1, ($$render) => {
        if (itemState.shouldRender) $$render(consequent_1);
      });
    }
    reset(div);
    template_effect(() => set_attribute(div, "data-value", itemState.trueValue));
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_item = hmr(Command_item, () => Command_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_item[HMR].source;
    set(Command_item[HMR].source, module.default[HMR].original);
  });
}
var command_item_default = Command_item;

// node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte
Command_link_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte";
var root_46 = add_locations(from_html(`<a><!></a>`), Command_link_item[FILENAME], [[45, 4]]);
var root_16 = add_locations(from_html(`<div style="display: contents;"><!></div>`), Command_link_item[FILENAME], [[40, 1]]);
function Command_link_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_link_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const itemState = CommandItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => itemState.root.key, ($$anchor2) => {
    var div = root_16();
    var node_1 = child(div);
    {
      var consequent_1 = ($$anchor3) => {
        var fragment_1 = comment();
        var node_2 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var a2 = root_46();
            attribute_effect(a2, () => ({ ...get(mergedProps) }));
            var node_4 = child(a2);
            snippet(node_4, () => $$props.children ?? noop);
            reset(a2);
            append($$anchor4, a2);
          };
          if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      };
      if_block(node_1, ($$render) => {
        if (itemState.shouldRender) $$render(consequent_1);
      });
    }
    reset(div);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_link_item = hmr(Command_link_item, () => Command_link_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_link_item[HMR].source;
    set(Command_link_item[HMR].source, module.default[HMR].original);
  });
}
var command_link_item_default = Command_link_item;

// node_modules/bits-ui/dist/bits/command/components/command-list.svelte
Command_list[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-list.svelte";
var root_39 = add_locations(from_html(`<div><!></div>`), Command_list[FILENAME], [[34, 2]]);
function Command_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "aria-label"
    ],
    "restProps"
  );
  const listState = CommandListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ariaLabel: box.with(() => $$props["aria-label"] ?? "Suggestions...")
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  key_block(node, () => strict_equals(listState.root._commandState.search, ""), ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    {
      var consequent = ($$anchor3) => {
        var fragment_2 = comment();
        var node_2 = first_child(fragment_2);
        snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
        append($$anchor3, fragment_2);
      };
      var alternate = ($$anchor3) => {
        var div = root_39();
        attribute_effect(div, () => ({ ...get(mergedProps) }));
        var node_3 = child(div);
        snippet(node_3, () => $$props.children ?? noop);
        reset(div);
        append($$anchor3, div);
      };
      if_block(node_1, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_list = hmr(Command_list, () => Command_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_list[HMR].source;
    set(Command_list[HMR].source, module.default[HMR].original);
  });
}
var command_list_default = Command_list;

// node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte
Command_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte";
var root_245 = add_locations(from_html(`<div><!></div>`), Command_viewport[FILENAME], [[31, 1]]);
function Command_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_viewport);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const listViewportState = CommandViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listViewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_245();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_viewport = hmr(Command_viewport, () => Command_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_viewport[HMR].source;
    set(Command_viewport[HMR].source, module.default[HMR].original);
  });
}
var command_viewport_default = Command_viewport;

// node_modules/bits-ui/dist/bits/command/components/command-loading.svelte
Command_loading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-loading.svelte";
var root_246 = add_locations(from_html(`<div><!></div>`), Command_loading[FILENAME], [[33, 1]]);
function Command_loading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_loading);
  let progress = prop($$props, "progress", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "progress",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const loadingState = CommandLoadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    progress: box.with(() => progress())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, loadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_246();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_loading = hmr(Command_loading, () => Command_loading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_loading[HMR].source;
    set(Command_loading[HMR].source, module.default[HMR].original);
  });
}
var command_loading_default = Command_loading;

// node_modules/bits-ui/dist/bits/command/components/command-separator.svelte
Command_separator[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-separator.svelte";
var root_310 = add_locations(from_html(`<div><!></div>`), Command_separator[FILENAME], [[34, 2]]);
function Command_separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_separator);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const separatorState = CommandSeparatorState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, separatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_310();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (separatorState.shouldRender) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_separator = hmr(Command_separator, () => Command_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_separator[HMR].source;
    set(Command_separator[HMR].source, module.default[HMR].original);
  });
}
var command_separator_default = Command_separator;

// node_modules/bits-ui/dist/bits/command/compute-command-score.js
var SCORE_CONTINUE_MATCH = 1;
var SCORE_SPACE_WORD_JUMP = 0.9;
var SCORE_NON_SPACE_WORD_JUMP = 0.8;
var SCORE_CHARACTER_JUMP = 0.17;
var SCORE_TRANSPOSITION = 0.1;
var PENALTY_SKIPPED = 0.999;
var PENALTY_CASE_MISMATCH = 0.9999;
var PENALTY_NOT_COMPLETE = 0.99;
var IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
var COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
var IS_SPACE_REGEXP = /[\s-]/;
var COUNT_SPACE_REGEXP = /[\s-]/g;
function computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length)
      return SCORE_CONTINUE_MATCH;
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0)
    return memoizedResults[memoizeKey];
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index >= 0) {
    score = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** wordBreaks.length;
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** spaceBreaks.length;
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= PENALTY_SKIPPED ** (index - stringIndex);
        }
      }
      if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index = lowerString.indexOf(abbreviationChar, index + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function computeCommandScore(command, search, commandKeywords) {
  command = commandKeywords && commandKeywords.length > 0 ? `${`${command} ${commandKeywords == null ? void 0 : commandKeywords.join(" ")}`}` : command;
  return computeCommandScoreInner(command, search, formatInput(command), formatInput(search), 0, 0, {});
}

// node_modules/bits-ui/dist/bits/context-menu/exports.js
var exports_exports11 = {};
__export(exports_exports11, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => context_menu_content_default,
  ContentStatic: () => context_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => context_menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => context_menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/utils.js
var SELECTION_KEYS3 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var FIRST_KEYS3 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS3 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS3 = [...FIRST_KEYS3, ...LAST_KEYS3];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd_constants_exports.ARROW_LEFT],
  rtl: [kbd_constants_exports.ARROW_RIGHT]
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/bits-ui/dist/internal/focus.js
function focus(element2, { select = false } = {}) {
  if (!element2 || !element2.focus)
    return;
  const doc = getDocument(element2);
  if (doc.activeElement === element2)
    return;
  const previouslyFocusedElement = doc.activeElement;
  element2.focus({ preventScroll: true });
  if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select) {
    element2.select();
  }
}
function focusFirst(candidates, { select = false } = {}, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement3() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableCandidates(container) {
  const nodes = [];
  const doc = getDocument(container);
  const walker = doc.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/bits-ui/dist/internal/tabbable.js
function getTabbableOptions() {
  return {
    getShadowRoot: true,
    displayCheck: (
      // JSDOM does not support the `tabbable` library. To solve this we can
      // check if `ResizeObserver` is a real function (not polyfilled), which
      // determines if the current environment is JSDOM-like.
      typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
    )
  };
}
function getTabbableFrom(currentNode, direction) {
  if (!isTabbable(currentNode, getTabbableOptions())) {
    return getTabbableFromFocusable(currentNode, direction);
  }
  const doc = getDocument(currentNode);
  const allTabbable = tabbable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allTabbable.reverse();
  const activeIndex = allTabbable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getTabbableFromFocusable(currentNode, direction) {
  const doc = getDocument(currentNode);
  if (!isFocusable(currentNode, getTabbableOptions()))
    return doc.body;
  const allFocusable = focusable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allFocusable.reverse();
  const activeIndex = allFocusable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextFocusableElements = allFocusable.slice(activeIndex + 1);
  return nextFocusableElements.find((node) => isTabbable(node, getTabbableOptions())) ?? doc.body;
}

// node_modules/bits-ui/dist/internal/grace-area.svelte.js
var _opts7, _enabled2, _isPointerInTransit, _pointerGraceArea, _GraceArea_instances, removeGraceArea_fn, createGraceArea_fn;
var GraceArea = class {
  constructor(opts) {
    __privateAdd(this, _GraceArea_instances);
    __privateAdd(this, _opts7);
    __privateAdd(this, _enabled2);
    __privateAdd(this, _isPointerInTransit);
    __privateAdd(this, _pointerGraceArea, tag(state(null), "GraceArea.#pointerGraceArea"));
    __privateSet(this, _opts7, opts);
    __privateSet(this, _enabled2, tag(user_derived(() => __privateGet(this, _opts7).enabled()), "GraceArea.#enabled"));
    __privateSet(this, _isPointerInTransit, boxAutoReset(false, {
      afterMs: opts.transitTimeout ?? 300,
      onChange: (value) => {
        var _a, _b;
        if (!get(__privateGet(this, _enabled2))) return;
        (_b = (_a = __privateGet(this, _opts7)).setIsPointerInTransit) == null ? void 0 : _b.call(_a, value);
      },
      getWindow: () => getWindow(__privateGet(this, _opts7).triggerNode())
    }));
    watch(
      [
        opts.triggerNode,
        opts.contentNode,
        opts.enabled
      ],
      ([triggerNode, contentNode, enabled]) => {
        if (!triggerNode || !contentNode || !enabled) return;
        const handleTriggerLeave = (e) => {
          __privateMethod(this, _GraceArea_instances, createGraceArea_fn).call(this, e, contentNode);
        };
        const handleContentLeave = (e) => {
          __privateMethod(this, _GraceArea_instances, createGraceArea_fn).call(this, e, triggerNode);
        };
        return executeCallbacks(on(triggerNode, "pointerleave", handleTriggerLeave), on(contentNode, "pointerleave", handleContentLeave));
      }
    );
    watch(() => get(__privateGet(this, _pointerGraceArea)), () => {
      const handleTrackPointerGrace = (e) => {
        var _a, _b;
        if (!get(__privateGet(this, _pointerGraceArea))) return;
        const target = e.target;
        if (!isElement2(target)) return;
        const pointerPosition = { x: e.clientX, y: e.clientY };
        const hasEnteredTarget = ((_a = opts.triggerNode()) == null ? void 0 : _a.contains(target)) || ((_b = opts.contentNode()) == null ? void 0 : _b.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, get(__privateGet(this, _pointerGraceArea)));
        if (hasEnteredTarget) {
          __privateMethod(this, _GraceArea_instances, removeGraceArea_fn).call(this);
        } else if (isPointerOutsideGraceArea) {
          __privateMethod(this, _GraceArea_instances, removeGraceArea_fn).call(this);
          opts.onPointerExit();
        }
      };
      const doc = getDocument(opts.triggerNode() ?? opts.contentNode());
      if (!doc) return;
      return on(doc, "pointermove", handleTrackPointerGrace);
    });
  }
};
_opts7 = new WeakMap();
_enabled2 = new WeakMap();
_isPointerInTransit = new WeakMap();
_pointerGraceArea = new WeakMap();
_GraceArea_instances = new WeakSet();
removeGraceArea_fn = function() {
  set(__privateGet(this, _pointerGraceArea), null);
  __privateGet(this, _isPointerInTransit).current = false;
};
createGraceArea_fn = function(e, hoverTarget) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget)) return;
  const exitPoint = { x: e.clientX, y: e.clientY };
  const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
  const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
  const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
  const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
  set(__privateGet(this, _pointerGraceArea), graceArea, true);
  __privateGet(this, _isPointerInTransit).current = true;
};
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const tipPadding = padding * 1.5;
  switch (exitSide) {
    case "top":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        },
        { x: exitPoint.x, y: exitPoint.y - tipPadding },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      ];
    case "bottom":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x, y: exitPoint.y + tipPadding },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        }
      ];
    case "left":
      return [
        {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x - tipPadding, y: exitPoint.y },
        {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        }
      ];
    case "right":
      return [
        {
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        },
        { x: exitPoint.x + tipPadding, y: exitPoint.y },
        {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        }
      ];
  }
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = strict_equals(yi > y, yj > y, false) && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (strict_equals(upperHull.length, 1) && strict_equals(lowerHull.length, 1) && strict_equals(upperHull[0].x, lowerHull[0].x) && strict_equals(upperHull[0].y, lowerHull[0].y)) return upperHull;
  else return upperHull.concat(lowerHull);
}

// node_modules/bits-ui/dist/bits/menu/menu.svelte.js
var CONTEXT_MENU_TRIGGER_ATTR = "data-context-menu-trigger";
var MenuRootContext = new Context("Menu.Root");
var MenuMenuContext = new Context("Menu.Root | Menu.Sub");
var MenuContentContext = new Context("Menu.Content");
var MenuGroupContext = new Context("Menu.Group | Menu.RadioGroup");
var MenuRadioGroupContext = new Context("Menu.RadioGroup");
var MenuCheckboxGroupContext = new Context("Menu.CheckboxGroup");
var MenuOpenEvent = new CustomEventDispatcher("bitsmenuopen", { bubbles: false, cancelable: true });
var menuAttrs = createBitsAttrs({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
var _ignoreCloseAutoFocus, _isPointerInTransit2;
var _MenuRootState = class _MenuRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "isUsingKeyboard", new IsUsingKeyboard());
    __privateAdd(this, _ignoreCloseAutoFocus, tag(state(false), "MenuRootState.ignoreCloseAutoFocus"));
    __privateAdd(this, _isPointerInTransit2, tag(state(false), "MenuRootState.isPointerInTransit"));
    __publicField(this, "getBitsAttr", (part) => {
      return menuAttrs.getAttr(part, this.opts.variant.current);
    });
    this.opts = opts;
  }
  static create(opts) {
    const root18 = new _MenuRootState(opts);
    return MenuRootContext.set(root18);
  }
  get ignoreCloseAutoFocus() {
    return get(__privateGet(this, _ignoreCloseAutoFocus));
  }
  set ignoreCloseAutoFocus(value) {
    set(__privateGet(this, _ignoreCloseAutoFocus), value, true);
  }
  get isPointerInTransit() {
    return get(__privateGet(this, _isPointerInTransit2));
  }
  set isPointerInTransit(value) {
    set(__privateGet(this, _isPointerInTransit2), value, true);
  }
};
_ignoreCloseAutoFocus = new WeakMap();
_isPointerInTransit2 = new WeakMap();
var MenuRootState = _MenuRootState;
var _contentNode4, _triggerNode3;
var _MenuMenuState = class _MenuMenuState {
  constructor(opts, root18, parentMenu) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "parentMenu");
    __publicField(this, "contentId", box.with(() => ""));
    __privateAdd(this, _contentNode4, tag(state(null), "MenuMenuState.contentNode"));
    __privateAdd(this, _triggerNode3, tag(state(null), "MenuMenuState.triggerNode"));
    this.opts = opts;
    this.root = root18;
    this.parentMenu = parentMenu;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    if (parentMenu) {
      watch(() => parentMenu.opts.open.current, () => {
        if (parentMenu.opts.open.current) return;
        this.opts.open.current = false;
      });
    }
  }
  static create(opts, root18) {
    return MenuMenuContext.set(new _MenuMenuState(opts, root18, null));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode4));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode4), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode3));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode3), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  onOpen() {
    this.opts.open.current = true;
  }
  onClose() {
    this.opts.open.current = false;
  }
};
_contentNode4 = new WeakMap();
_triggerNode3 = new WeakMap();
var MenuMenuState = _MenuMenuState;
var _search3, _timer, _handleTypeaheadSearch, _mounted3, _isSub, _MenuContentState_instances, getCandidateNodes_fn, isPointerMovingToSubmenu_fn, _snippetProps13, _props66;
var _MenuContentState = class _MenuContentState {
  constructor(opts, parentMenu) {
    __privateAdd(this, _MenuContentState_instances);
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _search3, tag(state(""), "MenuContentState.search"));
    __privateAdd(this, _timer, 0);
    __privateAdd(this, _handleTypeaheadSearch);
    __privateAdd(this, _mounted3, tag(state(false), "MenuContentState.mounted"));
    __privateAdd(this, _isSub);
    __publicField(this, "onCloseAutoFocus", (e) => {
      this.opts.onCloseAutoFocus.current(e);
      if (e.defaultPrevented || __privateGet(this, _isSub)) return;
      if (this.parentMenu.triggerNode && isTabbable(this.parentMenu.triggerNode)) {
        this.parentMenu.triggerNode.focus();
      }
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      if (e.defaultPrevented) return;
      e.preventDefault();
      const contentNode = this.parentMenu.contentNode;
      contentNode == null ? void 0 : contentNode.focus();
    });
    __privateAdd(this, _snippetProps13, tag(user_derived(() => ({ open: this.parentMenu.opts.open.current })), "MenuContentState.snippetProps"));
    __privateAdd(this, _props66, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "menu",
        "aria-orientation": getAriaOrientation("vertical"),
        [this.parentMenu.root.getBitsAttr("content")]: "",
        "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
        onkeydown: this.onkeydown,
        onblur: this.onblur,
        onfocus: this.onfocus,
        dir: this.parentMenu.root.opts.dir.current,
        style: { pointerEvents: "auto" },
        ...this.attachment
      })),
      "MenuContentState.props"
    ));
    __publicField(this, "popperProps", {
      onCloseAutoFocus: (e) => this.onCloseAutoFocus(e)
    });
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => {
      if (strict_equals(this.parentMenu.contentNode, v, false)) {
        this.parentMenu.contentNode = v;
      }
    });
    parentMenu.contentId = opts.id;
    __privateSet(this, _isSub, opts.isSub ?? false);
    this.onkeydown = this.onkeydown.bind(this);
    this.onblur = this.onblur.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.handleInteractOutside = this.handleInteractOutside.bind(this);
    new GraceArea({
      contentNode: () => this.parentMenu.contentNode,
      triggerNode: () => this.parentMenu.triggerNode,
      enabled: () => {
        var _a;
        return this.parentMenu.opts.open.current && Boolean((_a = this.parentMenu.triggerNode) == null ? void 0 : _a.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger")));
      },
      onPointerExit: () => {
        this.parentMenu.opts.open.current = false;
      },
      setIsPointerInTransit: (value) => {
        this.parentMenu.root.isPointerInTransit = value;
      }
    });
    __privateSet(this, _handleTypeaheadSearch, new DOMTypeahead({
      getActiveElement: () => this.domContext.getActiveElement(),
      getWindow: () => this.domContext.getWindow()
    }).handleTypeaheadSearch);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: box.with(() => this.parentMenu.contentNode),
      candidateAttr: this.parentMenu.root.getBitsAttr("item"),
      loop: this.opts.loop,
      orientation: box.with(() => "vertical")
    });
    watch(() => this.parentMenu.contentNode, (contentNode) => {
      if (!contentNode) return;
      const handler = () => {
        afterTick(() => {
          if (!this.parentMenu.root.isUsingKeyboard.current) return;
          this.rovingFocusGroup.focusFirstCandidate();
        });
      };
      return MenuOpenEvent.listen(contentNode, handler);
    });
    user_effect(() => {
      if (!this.parentMenu.opts.open.current) {
        this.domContext.getWindow().clearTimeout(__privateGet(this, _timer));
      }
    });
  }
  static create(opts) {
    return MenuContentContext.set(new _MenuContentState(opts, MenuMenuContext.get()));
  }
  get search() {
    return get(__privateGet(this, _search3));
  }
  set search(value) {
    set(__privateGet(this, _search3), value, true);
  }
  get mounted() {
    return get(__privateGet(this, _mounted3));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted3), value, true);
  }
  handleTabKeyDown(e) {
    let rootMenu = this.parentMenu;
    while (strict_equals(rootMenu.parentMenu, null, false)) {
      rootMenu = rootMenu.parentMenu;
    }
    if (!rootMenu.triggerNode) return;
    e.preventDefault();
    const nodeToFocus = getTabbableFrom(rootMenu.triggerNode, e.shiftKey ? "prev" : "next");
    if (nodeToFocus) {
      this.parentMenu.root.ignoreCloseAutoFocus = true;
      rootMenu.onClose();
      afterTick(() => {
        nodeToFocus.focus();
        afterTick(() => {
          this.parentMenu.root.ignoreCloseAutoFocus = false;
        });
      });
    } else {
      this.domContext.getDocument().body.focus();
    }
  }
  onkeydown(e) {
    var _a, _b;
    if (e.defaultPrevented) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.handleTabKeyDown(e);
      return;
    }
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(target) || !isHTMLElement2(currentTarget)) return;
    const isKeydownInside = strict_equals((_a = target.closest(`[${this.parentMenu.root.getBitsAttr("content")}]`)) == null ? void 0 : _a.id, this.parentMenu.contentId.current);
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = strict_equals(e.key.length, 1);
    const kbdFocusedEl = this.rovingFocusGroup.handleKeydown(target, e);
    if (kbdFocusedEl) return;
    if (strict_equals(e.code, "Space")) return;
    const candidateNodes = __privateMethod(this, _MenuContentState_instances, getCandidateNodes_fn).call(this);
    if (isKeydownInside) {
      if (!isModifierKey && isCharacterKey) {
        __privateGet(this, _handleTypeaheadSearch).call(this, e.key, candidateNodes);
      }
    }
    if (strict_equals((_b = e.target) == null ? void 0 : _b.id, this.parentMenu.contentId.current, false)) return;
    if (!FIRST_LAST_KEYS3.includes(e.key)) return;
    e.preventDefault();
    if (LAST_KEYS3.includes(e.key)) {
      candidateNodes.reverse();
    }
    focusFirst(candidateNodes, { select: false }, () => this.domContext.getActiveElement());
  }
  onblur(e) {
    var _a, _b;
    if (!isElement2(e.currentTarget)) return;
    if (!isElement2(e.target)) return;
    if (!((_b = (_a = e.currentTarget).contains) == null ? void 0 : _b.call(_a, e.target))) {
      this.domContext.getWindow().clearTimeout(__privateGet(this, _timer));
      this.search = "";
    }
  }
  onfocus(_) {
    if (!this.parentMenu.root.isUsingKeyboard.current) return;
    afterTick(() => this.rovingFocusGroup.focusFirstCandidate());
  }
  onItemEnter() {
    return __privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this);
  }
  onItemLeave(e) {
    if (e.currentTarget.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger"))) return;
    if (__privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this) || this.parentMenu.root.isUsingKeyboard.current) return;
    const contentNode = this.parentMenu.contentNode;
    contentNode == null ? void 0 : contentNode.focus();
    this.rovingFocusGroup.setCurrentTabStopId("");
  }
  onTriggerLeave() {
    if (__privateMethod(this, _MenuContentState_instances, isPointerMovingToSubmenu_fn).call(this)) return true;
    return false;
  }
  handleInteractOutside(e) {
    var _a;
    if (!isElementOrSVGElement(e.target)) return;
    const triggerId = (_a = this.parentMenu.triggerNode) == null ? void 0 : _a.id;
    if (strict_equals(e.target.id, triggerId)) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(`#${triggerId}`)) {
      e.preventDefault();
    }
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps13));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps13), value);
  }
  get props() {
    return get(__privateGet(this, _props66));
  }
  set props(value) {
    set(__privateGet(this, _props66), value);
  }
};
_search3 = new WeakMap();
_timer = new WeakMap();
_handleTypeaheadSearch = new WeakMap();
_mounted3 = new WeakMap();
_isSub = new WeakMap();
_MenuContentState_instances = new WeakSet();
getCandidateNodes_fn = function() {
  const node = this.parentMenu.contentNode;
  if (!node) return [];
  const candidates = Array.from(node.querySelectorAll(`[${this.parentMenu.root.getBitsAttr("item")}]:not([data-disabled])`));
  return candidates;
};
isPointerMovingToSubmenu_fn = function() {
  return this.parentMenu.root.isPointerInTransit;
};
_snippetProps13 = new WeakMap();
_props66 = new WeakMap();
var MenuContentState = _MenuContentState;
var _isFocused, _props67;
var MenuItemSharedState = class {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused, tag(state(false), "MenuItemSharedState.#isFocused"));
    __privateAdd(this, _props67, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        tabindex: -1,
        role: "menuitem",
        "aria-disabled": getAriaDisabled(this.opts.disabled.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-highlighted": get(__privateGet(this, _isFocused)) ? "" : void 0,
        [this.content.parentMenu.root.getBitsAttr("item")]: "",
        //
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.attachment
      })),
      "MenuItemSharedState.props"
    ));
    this.opts = opts;
    this.content = content;
    this.attachment = attachRef(this.opts.ref);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  onpointermove(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    if (this.opts.disabled.current) {
      this.content.onItemLeave(e);
    } else {
      const defaultPrevented = this.content.onItemEnter();
      if (defaultPrevented) return;
      const item = e.currentTarget;
      if (!isHTMLElement2(item)) return;
      item.focus();
    }
  }
  onpointerleave(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    this.content.onItemLeave(e);
  }
  onfocus(e) {
    afterTick(() => {
      if (e.defaultPrevented || this.opts.disabled.current) return;
      set(__privateGet(this, _isFocused), true);
    });
  }
  onblur(e) {
    afterTick(() => {
      if (e.defaultPrevented) return;
      set(__privateGet(this, _isFocused), false);
    });
  }
  get props() {
    return get(__privateGet(this, _props67));
  }
  set props(value) {
    set(__privateGet(this, _props67), value);
  }
};
_isFocused = new WeakMap();
_props67 = new WeakMap();
var _isPointerDown, _MenuItemState_instances, handleSelect_fn, _props68;
var _MenuItemState = class _MenuItemState {
  constructor(opts, item) {
    __privateAdd(this, _MenuItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "root");
    __privateAdd(this, _isPointerDown, false);
    __privateAdd(this, _props68, tag(
      user_derived(() => mergeProps(this.item.props, {
        onclick: this.onclick,
        onpointerdown: this.onpointerdown,
        onpointerup: this.onpointerup,
        onkeydown: this.onkeydown
      })),
      "MenuItemState.props"
    ));
    this.opts = opts;
    this.item = item;
    this.root = item.content.parentMenu.root;
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create(opts) {
    const item = new MenuItemSharedState(opts, MenuContentContext.get());
    return new _MenuItemState(opts, item);
  }
  onkeydown(e) {
    const isTypingAhead = strict_equals(this.item.content.search, "", false);
    if (this.item.opts.disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
    if (SELECTION_KEYS3.includes(e.key)) {
      if (!isHTMLElement2(e.currentTarget)) return;
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(_) {
    if (this.item.opts.disabled.current) return;
    __privateMethod(this, _MenuItemState_instances, handleSelect_fn).call(this);
  }
  onpointerup(e) {
    var _a;
    if (e.defaultPrevented) return;
    if (!__privateGet(this, _isPointerDown)) {
      if (!isHTMLElement2(e.currentTarget)) return;
      (_a = e.currentTarget) == null ? void 0 : _a.click();
    }
  }
  onpointerdown(_) {
    __privateSet(this, _isPointerDown, true);
  }
  get props() {
    return get(__privateGet(this, _props68));
  }
  set props(value) {
    set(__privateGet(this, _props68), value);
  }
};
_isPointerDown = new WeakMap();
_MenuItemState_instances = new WeakSet();
handleSelect_fn = function() {
  if (this.item.opts.disabled.current) return;
  const selectEvent = new CustomEvent("menuitemselect", { bubbles: true, cancelable: true });
  this.opts.onSelect.current(selectEvent);
  if (selectEvent.defaultPrevented) {
    this.item.content.parentMenu.root.isUsingKeyboard.current = false;
    return;
  }
  if (this.opts.closeOnSelect.current) {
    this.item.content.parentMenu.root.opts.onClose();
  }
};
_props68 = new WeakMap();
var MenuItemState = _MenuItemState;
var _openTimer, _MenuSubTriggerState_instances, clearOpenTimer_fn, _props69;
var _MenuSubTriggerState = class _MenuSubTriggerState {
  constructor(opts, item, content, submenu) {
    __privateAdd(this, _MenuSubTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "content");
    __publicField(this, "submenu");
    __publicField(this, "attachment");
    __privateAdd(this, _openTimer, null);
    __privateAdd(this, _props69, tag(
      user_derived(() => mergeProps(
        {
          "aria-haspopup": "menu",
          "aria-expanded": getAriaExpanded(this.submenu.opts.open.current),
          "data-state": getDataOpenClosed(this.submenu.opts.open.current),
          "aria-controls": this.submenu.opts.open.current ? this.submenu.contentId.current : void 0,
          [this.submenu.root.getBitsAttr("sub-trigger")]: "",
          onclick: this.onclick,
          onpointermove: this.onpointermove,
          onpointerleave: this.onpointerleave,
          onkeydown: this.onkeydown,
          ...this.attachment
        },
        this.item.props
      )),
      "MenuSubTriggerState.props"
    ));
    this.opts = opts;
    this.item = item;
    this.content = content;
    this.submenu = submenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.submenu.triggerNode = v);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    onDestroyEffect(() => {
      __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
    });
  }
  static create(opts) {
    const content = MenuContentContext.get();
    const item = new MenuItemSharedState(opts, content);
    const submenu = MenuMenuContext.get();
    return new _MenuSubTriggerState(opts, item, content, submenu);
  }
  onpointermove(e) {
    if (!isMouseEvent(e)) return;
    if (!this.item.opts.disabled.current && !this.submenu.opts.open.current && !__privateGet(this, _openTimer) && !this.content.parentMenu.root.isPointerInTransit) {
      __privateSet(this, _openTimer, this.content.domContext.setTimeout(
        () => {
          this.submenu.onOpen();
          __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
        },
        100
      ));
    }
  }
  onpointerleave(e) {
    if (!isMouseEvent(e)) return;
    __privateMethod(this, _MenuSubTriggerState_instances, clearOpenTimer_fn).call(this);
  }
  onkeydown(e) {
    const isTypingAhead = strict_equals(this.content.search, "", false);
    if (this.item.opts.disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
    if (SUB_OPEN_KEYS[this.submenu.root.opts.dir.current].includes(e.key)) {
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(e) {
    if (this.item.opts.disabled.current) return;
    if (!isHTMLElement2(e.currentTarget)) return;
    e.currentTarget.focus();
    const selectEvent = new CustomEvent("menusubtriggerselect", { bubbles: true, cancelable: true });
    this.opts.onSelect.current(selectEvent);
    if (!this.submenu.opts.open.current) {
      this.submenu.onOpen();
      afterTick(() => {
        const contentNode = this.submenu.contentNode;
        if (!contentNode) return;
        MenuOpenEvent.dispatch(contentNode);
      });
    }
  }
  get props() {
    return get(__privateGet(this, _props69));
  }
  set props(value) {
    set(__privateGet(this, _props69), value);
  }
};
_openTimer = new WeakMap();
_MenuSubTriggerState_instances = new WeakSet();
clearOpenTimer_fn = function() {
  if (strict_equals(__privateGet(this, _openTimer), null)) return;
  this.content.domContext.getWindow().clearTimeout(__privateGet(this, _openTimer));
  __privateSet(this, _openTimer, null);
};
_props69 = new WeakMap();
var MenuSubTriggerState = _MenuSubTriggerState;
var _snippetProps14, _props70;
var _MenuCheckboxItemState = class _MenuCheckboxItemState {
  constructor(opts, item, group = null) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "group");
    __privateAdd(this, _snippetProps14, tag(
      user_derived(() => ({
        checked: this.opts.checked.current,
        indeterminate: this.opts.indeterminate.current
      })),
      "MenuCheckboxItemState.snippetProps"
    ));
    __privateAdd(this, _props70, tag(
      user_derived(() => ({
        ...this.item.props,
        role: "menuitemcheckbox",
        "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
        "data-state": getCheckedState(this.opts.checked.current),
        [this.item.root.getBitsAttr("checkbox-item")]: ""
      })),
      "MenuCheckboxItemState.props"
    ));
    this.opts = opts;
    this.item = item;
    this.group = group;
    if (this.group) {
      watch(() => this.group.opts.value.current, (groupValues) => {
        this.opts.checked.current = groupValues.includes(this.opts.value.current);
      });
      watch(() => this.opts.checked.current, (checked) => {
        if (checked) {
          this.group.addValue(this.opts.value.current);
        } else {
          this.group.removeValue(this.opts.value.current);
        }
      });
    }
  }
  static create(opts, checkboxGroup) {
    const item = new MenuItemState(opts, new MenuItemSharedState(opts, MenuContentContext.get()));
    return new _MenuCheckboxItemState(opts, item, checkboxGroup);
  }
  toggleChecked() {
    if (this.opts.indeterminate.current) {
      this.opts.indeterminate.current = false;
      this.opts.checked.current = true;
    } else {
      this.opts.checked.current = !this.opts.checked.current;
    }
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps14));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps14), value);
  }
  get props() {
    return get(__privateGet(this, _props70));
  }
  set props(value) {
    set(__privateGet(this, _props70), value);
  }
};
_snippetProps14 = new WeakMap();
_props70 = new WeakMap();
var MenuCheckboxItemState = _MenuCheckboxItemState;
var _groupHeadingId, _props71;
var _MenuGroupState = class _MenuGroupState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId, tag(state(void 0), "MenuGroupState.groupHeadingId"));
    __privateAdd(this, _props71, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        "aria-labelledby": this.groupHeadingId,
        [this.root.getBitsAttr("group")]: "",
        ...this.attachment
      })),
      "MenuGroupState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuGroupContext.set(new _MenuGroupState(opts, MenuRootContext.get()));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId), value, true);
  }
  get props() {
    return get(__privateGet(this, _props71));
  }
  set props(value) {
    set(__privateGet(this, _props71), value);
  }
};
_groupHeadingId = new WeakMap();
_props71 = new WeakMap();
var MenuGroupState = _MenuGroupState;
var _props72;
var _MenuGroupHeadingState = class _MenuGroupHeadingState {
  constructor(opts, group) {
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _props72, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        [this.group.root.getBitsAttr("group-heading")]: "",
        ...this.attachment
      })),
      "MenuGroupHeadingState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.groupHeadingId = v == null ? void 0 : v.id);
  }
  static create(opts) {
    const checkboxGroup = MenuCheckboxGroupContext.getOr(null);
    if (checkboxGroup) return new _MenuGroupHeadingState(opts, checkboxGroup);
    const radioGroup = MenuRadioGroupContext.getOr(null);
    if (radioGroup) return new _MenuGroupHeadingState(opts, radioGroup);
    return new _MenuGroupHeadingState(opts, MenuGroupContext.get());
  }
  get props() {
    return get(__privateGet(this, _props72));
  }
  set props(value) {
    set(__privateGet(this, _props72), value);
  }
};
_props72 = new WeakMap();
var MenuGroupHeadingState = _MenuGroupHeadingState;
var _props73;
var _MenuSeparatorState = class _MenuSeparatorState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props73, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        [this.root.getBitsAttr("separator")]: "",
        ...this.attachment
      })),
      "MenuSeparatorState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _MenuSeparatorState(opts, MenuRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props73));
  }
  set props(value) {
    set(__privateGet(this, _props73), value);
  }
};
_props73 = new WeakMap();
var MenuSeparatorState = _MenuSeparatorState;
var _props74;
var _MenuArrowState = class _MenuArrowState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _props74, tag(user_derived(() => ({ [this.root.getBitsAttr("arrow")]: "" })), "MenuArrowState.props"));
    this.root = root18;
  }
  static create() {
    return new _MenuArrowState(MenuRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props74));
  }
  set props(value) {
    set(__privateGet(this, _props74), value);
  }
};
_props74 = new WeakMap();
var MenuArrowState = _MenuArrowState;
var _groupHeadingId2, _props75;
var _MenuRadioGroupState = class _MenuRadioGroupState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId2, tag(state(null), "MenuRadioGroupState.groupHeadingId"));
    __publicField(this, "root");
    __privateAdd(this, _props75, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("radio-group")]: "",
        role: "group",
        "aria-labelledby": this.groupHeadingId,
        ...this.attachment
      })),
      "MenuRadioGroupState.props"
    ));
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuGroupContext.set(MenuRadioGroupContext.set(new _MenuRadioGroupState(opts, MenuContentContext.get())));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId2));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId2), value, true);
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  get props() {
    return get(__privateGet(this, _props75));
  }
  set props(value) {
    set(__privateGet(this, _props75), value);
  }
};
_groupHeadingId2 = new WeakMap();
_props75 = new WeakMap();
var MenuRadioGroupState = _MenuRadioGroupState;
var _isChecked, _props76;
var _MenuRadioItemState = class _MenuRadioItemState {
  constructor(opts, item, group) {
    __publicField(this, "opts");
    __publicField(this, "item");
    __publicField(this, "group");
    __publicField(this, "attachment");
    __privateAdd(this, _isChecked, tag(user_derived(() => strict_equals(this.group.opts.value.current, this.opts.value.current)), "MenuRadioItemState.isChecked"));
    __privateAdd(this, _props76, tag(
      user_derived(() => ({
        [this.group.root.getBitsAttr("radio-item")]: "",
        ...this.item.props,
        role: "menuitemradio",
        "aria-checked": getAriaChecked(this.isChecked, false),
        "data-state": getCheckedState(this.isChecked),
        ...this.attachment
      })),
      "MenuRadioItemState.props"
    ));
    this.opts = opts;
    this.item = item;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    const radioGroup = MenuRadioGroupContext.get();
    const sharedItem = new MenuItemSharedState(opts, radioGroup.content);
    const item = new MenuItemState(opts, sharedItem);
    return new _MenuRadioItemState(opts, item, radioGroup);
  }
  get isChecked() {
    return get(__privateGet(this, _isChecked));
  }
  set isChecked(value) {
    set(__privateGet(this, _isChecked), value);
  }
  selectValue() {
    this.group.setValue(this.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props76));
  }
  set props(value) {
    set(__privateGet(this, _props76), value);
  }
};
_isChecked = new WeakMap();
_props76 = new WeakMap();
var MenuRadioItemState = _MenuRadioItemState;
var _ariaControls, _props77;
var _DropdownMenuTriggerState = class _DropdownMenuTriggerState {
  constructor(opts, parentMenu) {
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "attachment");
    __publicField(this, "onpointerdown", (e) => {
      if (this.opts.disabled.current) return;
      if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
      if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
        this.parentMenu.toggleOpen();
        if (!this.parentMenu.opts.open.current) e.preventDefault();
      }
    });
    __publicField(this, "onpointerup", (e) => {
      if (this.opts.disabled.current) return;
      if (strict_equals(e.pointerType, "touch")) {
        e.preventDefault();
        this.parentMenu.toggleOpen();
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.opts.disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
        this.parentMenu.toggleOpen();
        e.preventDefault();
        return;
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        this.parentMenu.onOpen();
        e.preventDefault();
      }
    });
    __privateAdd(this, _ariaControls, tag(
      user_derived(() => {
        if (this.parentMenu.opts.open.current && this.parentMenu.contentId.current) return this.parentMenu.contentId.current;
        return void 0;
      }),
      "DropdownMenuTriggerState.#ariaControls"
    ));
    __privateAdd(this, _props77, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: this.opts.disabled.current,
        "aria-haspopup": "menu",
        "aria-expanded": getAriaExpanded(this.parentMenu.opts.open.current),
        "aria-controls": get(__privateGet(this, _ariaControls)),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
        [this.parentMenu.root.getBitsAttr("trigger")]: "",
        //
        onpointerdown: this.onpointerdown,
        onpointerup: this.onpointerup,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "DropdownMenuTriggerState.props"
    ));
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
  }
  static create(opts) {
    return new _DropdownMenuTriggerState(opts, MenuMenuContext.get());
  }
  get props() {
    return get(__privateGet(this, _props77));
  }
  set props(value) {
    set(__privateGet(this, _props77), value);
  }
};
_ariaControls = new WeakMap();
_props77 = new WeakMap();
var DropdownMenuTriggerState = _DropdownMenuTriggerState;
var _point, _longPressTimer, _ContextMenuTriggerState_instances, clearLongPressTimer_fn, handleOpen_fn2, _props78;
var _ContextMenuTriggerState = class _ContextMenuTriggerState {
  constructor(opts, parentMenu) {
    __privateAdd(this, _ContextMenuTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "parentMenu");
    __publicField(this, "attachment");
    __privateAdd(this, _point, tag(state(proxy({ x: 0, y: 0 })), "ContextMenuTriggerState.#point"));
    __publicField(this, "virtualElement", box({
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...get(__privateGet(this, _point))
      })
    }));
    __privateAdd(this, _longPressTimer, null);
    __privateAdd(this, _props78, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: this.opts.disabled.current,
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
        [CONTEXT_MENU_TRIGGER_ATTR]: "",
        tabindex: -1,
        //
        onpointerdown: this.onpointerdown,
        onpointermove: this.onpointermove,
        onpointercancel: this.onpointercancel,
        onpointerup: this.onpointerup,
        oncontextmenu: this.oncontextmenu,
        ...this.attachment
      })),
      "ContextMenuTriggerState.props"
    ));
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
    this.oncontextmenu = this.oncontextmenu.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointercancel = this.onpointercancel.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    watch(() => get(__privateGet(this, _point)), (point) => {
      this.virtualElement.current = {
        getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...point })
      };
    });
    watch(() => this.opts.disabled.current, (isDisabled) => {
      if (isDisabled) {
        __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
      }
    });
    onDestroyEffect(() => __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this));
  }
  static create(opts) {
    return new _ContextMenuTriggerState(opts, MenuMenuContext.get());
  }
  oncontextmenu(e) {
    var _a;
    if (this.opts.disabled.current) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
    __privateMethod(this, _ContextMenuTriggerState_instances, handleOpen_fn2).call(this, e);
    e.preventDefault();
    (_a = this.parentMenu.contentNode) == null ? void 0 : _a.focus();
  }
  onpointerdown(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
    __privateSet(this, _longPressTimer, getWindow(this.opts.ref.current).setTimeout(() => __privateMethod(this, _ContextMenuTriggerState_instances, handleOpen_fn2).call(this, e), 700));
  }
  onpointermove(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  onpointercancel(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  onpointerup(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    __privateMethod(this, _ContextMenuTriggerState_instances, clearLongPressTimer_fn).call(this);
  }
  get props() {
    return get(__privateGet(this, _props78));
  }
  set props(value) {
    set(__privateGet(this, _props78), value);
  }
};
_point = new WeakMap();
_longPressTimer = new WeakMap();
_ContextMenuTriggerState_instances = new WeakSet();
clearLongPressTimer_fn = function() {
  if (strict_equals(__privateGet(this, _longPressTimer), null)) return;
  getWindow(this.opts.ref.current).clearTimeout(__privateGet(this, _longPressTimer));
};
handleOpen_fn2 = function(e) {
  set(__privateGet(this, _point), { x: e.clientX, y: e.clientY }, true);
  this.parentMenu.onOpen();
};
_props78 = new WeakMap();
var ContextMenuTriggerState = _ContextMenuTriggerState;
var _groupHeadingId3, _props79;
var _MenuCheckboxGroupState = class _MenuCheckboxGroupState {
  constructor(opts, content) {
    __publicField(this, "opts");
    __publicField(this, "content");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _groupHeadingId3, tag(state(null), "MenuCheckboxGroupState.groupHeadingId"));
    __privateAdd(this, _props79, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [this.root.getBitsAttr("checkbox-group")]: "",
        role: "group",
        "aria-labelledby": this.groupHeadingId,
        ...this.attachment
      })),
      "MenuCheckboxGroupState.props"
    ));
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return MenuCheckboxGroupContext.set(new _MenuCheckboxGroupState(opts, MenuContentContext.get()));
  }
  get groupHeadingId() {
    return get(__privateGet(this, _groupHeadingId3));
  }
  set groupHeadingId(value) {
    set(__privateGet(this, _groupHeadingId3), value, true);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [
        ...snapshot(this.opts.value.current),
        checkboxValue
      ];
      this.opts.value.current = newValue;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (strict_equals(index, -1)) return;
    const newValue = this.opts.value.current.filter((v) => strict_equals(v, checkboxValue, false));
    this.opts.value.current = newValue;
    this.opts.onValueChange.current(newValue);
  }
  get props() {
    return get(__privateGet(this, _props79));
  }
  set props(value) {
    set(__privateGet(this, _props79), value);
  }
};
_groupHeadingId3 = new WeakMap();
_props79 = new WeakMap();
var MenuCheckboxGroupState = _MenuCheckboxGroupState;
var MenuSubmenuState = class {
  static create(opts) {
    const menu = MenuMenuContext.get();
    return MenuMenuContext.set(new MenuMenuState(opts, menu.root, menu));
  }
};

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte
Context_menu[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte";
function Context_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  const root18 = MenuRootState.create({
    variant: box.with(() => "context-menu"),
    dir: box.with(() => dir()),
    onClose: () => {
      var _a;
      open(false);
      (_a = onOpenChange()) == null ? void 0 : _a(false);
    }
  });
  MenuMenuState.create(
    {
      open: box.with(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: box.with(() => onOpenChangeComplete())
    },
    root18
  );
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Context_menu, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu = hmr(Context_menu, () => Context_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu[HMR].source;
    set(Context_menu[HMR].source, module.default[HMR].original);
  });
}
var context_menu_default = Context_menu;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte
Menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte";
function Menu_sub($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  MenuSubmenuState.create({
    open: box.with(() => open(), (v) => {
      var _a;
      open(v);
      (_a = onOpenChange()) == null ? void 0 : _a(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Menu_sub, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub = hmr(Menu_sub, () => Menu_sub[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub[HMR].source;
    set(Menu_sub[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_default = Menu_sub;

// node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte
Menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte";
var root_247 = add_locations(from_html(`<div><!></div>`), Menu_item[FILENAME], [[38, 1]]);
function Menu_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_item);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "onSelect",
      "closeOnSelect"
    ],
    "restProps"
  );
  const itemState = MenuItemState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_247();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_item = hmr(Menu_item, () => Menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_item[HMR].source;
    set(Menu_item[HMR].source, module.default[HMR].original);
  });
}
var menu_item_default = Menu_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte
Menu_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte";
var root_248 = add_locations(from_html(`<div><!></div>`), Menu_group[FILENAME], [[30, 1]]);
function Menu_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_group);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupState = MenuGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_248();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group = hmr(Menu_group, () => Menu_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group[HMR].source;
    set(Menu_group[HMR].source, module.default[HMR].original);
  });
}
var menu_group_default = Menu_group;

// node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte
Menu_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte";
var root_249 = add_locations(from_html(`<div><!></div>`), Menu_group_heading[FILENAME], [[30, 1]]);
function Menu_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_group_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupHeadingState = MenuGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupHeadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_249();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group_heading = hmr(Menu_group_heading, () => Menu_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group_heading[HMR].source;
    set(Menu_group_heading[HMR].source, module.default[HMR].original);
  });
}
var menu_group_heading_default = Menu_group_heading;

// node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte
Menu_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte";
function Menu_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  const arrowState = MenuArrowState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, arrowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    floating_layer_arrow_default(node, spread_props(() => get(mergedProps), {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_arrow = hmr(Menu_arrow, () => Menu_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_arrow[HMR].source;
    set(Menu_arrow[HMR].source, module.default[HMR].original);
  });
}
var menu_arrow_default = Menu_arrow;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte
Context_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte";
var root_47 = add_locations(from_html(`<div><div><!></div></div>`), Context_menu_content[FILENAME], [[97, 4, [[98, 5]]]]);
var root_93 = add_locations(from_html(`<div><div><!></div></div>`), Context_menu_content[FILENAME], [[130, 4, [[131, 5]]]]);
function Context_menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount",
      "trapFocus"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_47();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          get onOpenAutoFocus() {
            return onOpenAutoFocus();
          },
          isValidEvent: isValidEvent2,
          get trapFocus() {
            return trapFocus();
          },
          get loop() {
            return loop();
          },
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Context_menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_93();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              side: "right",
              sideOffset: 2,
              align: "start",
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              get onOpenAutoFocus() {
                return onOpenAutoFocus();
              },
              isValidEvent: isValidEvent2,
              get trapFocus() {
                return trapFocus();
              },
              get loop() {
                return loop();
              },
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content = hmr(Context_menu_content, () => Context_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content[HMR].source;
    set(Context_menu_content[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_default = Context_menu_content;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte
Context_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte";
var root_48 = add_locations(from_html(`<div><!></div>`), Context_menu_content_static[FILENAME], [[90, 4]]);
var root_94 = add_locations(from_html(`<div><!></div>`), Context_menu_content_static[FILENAME], [[122, 4]]);
function Context_menu_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onCloseAutoFocus",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("context-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_48();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          side: "right",
          sideOffset: 2,
          align: "start",
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          get preventScroll() {
            return preventScroll();
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          isValidEvent: isValidEvent2,
          trapFocus: true,
          get loop() {
            return loop();
          },
          get forceMount() {
            return forceMount();
          },
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Context_menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("context-menu")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_94();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              side: "right",
              sideOffset: 2,
              align: "start",
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              get preventScroll() {
                return preventScroll();
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              isValidEvent: isValidEvent2,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content_static = hmr(Context_menu_content_static, () => Context_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content_static[HMR].source;
    set(Context_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_static_default = Context_menu_content_static;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte
Context_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte";
var root_311 = add_locations(from_html(`<div><!></div>`), Context_menu_trigger[FILENAME], [[35, 2]]);
function Context_menu_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = ContextMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { style: { pointerEvents: "auto" } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
    FloatingLayer_Anchor($$anchor2, {
      get id() {
        return id();
      },
      get virtualEl() {
        return triggerState.virtualElement;
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Context_menu_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var div = root_311();
            attribute_effect(div, () => ({ ...get(mergedProps) }));
            var node_3 = child(div);
            snippet(node_3, () => $$props.children ?? noop);
            reset(div);
            append($$anchor4, div);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_trigger = hmr(Context_menu_trigger, () => Context_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_trigger[HMR].source;
    set(Context_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var context_menu_trigger_default = Context_menu_trigger;

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte
Menu_radio_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte";
var root_250 = add_locations(from_html(`<div><!></div>`), Menu_radio_item[FILENAME], [[46, 1]]);
function Menu_radio_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_radio_item);
  let ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "onSelect",
      "id",
      "disabled",
      "closeOnSelect"
    ],
    "restProps"
  );
  const radioItemState = MenuRadioItemState.create({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => handleSelect),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    radioItemState.selectValue();
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, radioItemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        checked: radioItemState.isChecked
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_250();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ checked: radioItemState.isChecked }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_item = hmr(Menu_radio_item, () => Menu_radio_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_item[HMR].source;
    set(Menu_radio_item[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_item_default = Menu_radio_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte
Menu_separator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte";
var root_251 = add_locations(from_html(`<div><!></div>`), Menu_separator[FILENAME], [[31, 1]]);
function Menu_separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_separator);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const separatorState = MenuSeparatorState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, separatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_251();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_separator = hmr(Menu_separator, () => Menu_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_separator[HMR].source;
    set(Menu_separator[HMR].source, module.default[HMR].original);
  });
}
var menu_separator_default = Menu_separator;

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte
Menu_radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte";
var root_252 = add_locations(from_html(`<div><!></div>`), Menu_radio_group[FILENAME], [[41, 1]]);
function Menu_radio_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_radio_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "onValueChange"
    ],
    "restProps"
  );
  const radioGroupState = MenuRadioGroupState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, radioGroupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_252();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_group = hmr(Menu_radio_group, () => Menu_radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_group[HMR].source;
    set(Menu_radio_group[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_group_default = Menu_radio_group;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte
Menu_sub_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte";
var root_49 = add_locations(from_html(`<div><div><!></div></div>`), Menu_sub_content[FILENAME], [[136, 4, [[137, 5]]]]);
var root_95 = add_locations(from_html(`<div><div><!></div></div>`), Menu_sub_content[FILENAME], [[171, 4, [[172, 5]]]]);
function Menu_sub_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), side = prop($$props, "side", 3, "right"), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "side",
      "trapFocus"
    ],
    "restProps"
  );
  const subContentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isSub: true,
    onCloseAutoFocus: box.with(() => handleCloseAutoFocus)
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = tag(user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content")), "dataAttr");
  const mergedProps = tag(
    user_derived(() => mergeProps(restProps, subContentState.props, {
      side: side(),
      onkeydown,
      [get(dataAttr)]: ""
    })),
    "mergedProps"
  );
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    if (subContentState.parentMenu.root.isUsingKeyboard && subContentState.parentMenu.contentNode) {
      MenuOpenEvent.dispatch(subContentState.parentMenu.contentNode);
    }
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (strict_equals(e.target.id, (_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...subContentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_49();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get ref() {
            return subContentState.opts.ref;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          get trapFocus() {
            return trapFocus();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Menu_sub_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...subContentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_95();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), {
              get ref() {
                return subContentState.opts.ref;
              },
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get open() {
                return subContentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              get trapFocus() {
                return trapFocus();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content = hmr(Menu_sub_content, () => Menu_sub_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content[HMR].source;
    set(Menu_sub_content[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_default = Menu_sub_content;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte
Menu_sub_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte";
var root_410 = add_locations(from_html(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[131, 4]]);
var root_96 = add_locations(from_html(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[161, 4]]);
function Menu_sub_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "trapFocus"
    ],
    "restProps"
  );
  const subContentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => handleCloseAutoFocus),
    isSub: true
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode == null ? void 0 : triggerNode.focus();
      e.preventDefault();
    }
  }
  const dataAttr = tag(user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content")), "dataAttr");
  const mergedProps = tag(user_derived(() => mergeProps(restProps, subContentState.props, { onkeydown, [get(dataAttr)]: "" })), "mergedProps");
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    afterTick(() => {
      e.preventDefault();
      if (subContentState.parentMenu.root.isUsingKeyboard) {
        const subContentEl = subContentState.parentMenu.contentNode;
        subContentEl == null ? void 0 : subContentEl.focus();
      }
    });
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    var _a;
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (strict_equals(e.target.id, (_a = subContentState.parentMenu.triggerNode) == null ? void 0 : _a.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...subContentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_410();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
          get ref() {
            return subContentState.opts.ref;
          },
          get interactOutsideBehavior() {
            return interactOutsideBehavior();
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          onOpenAutoFocus: handleOpenAutoFocus,
          get enabled() {
            return subContentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          onFocusOutside: handleOnFocusOutside,
          preventScroll: false,
          get loop() {
            return loop();
          },
          get trapFocus() {
            return trapFocus();
          },
          isStatic: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Menu_sub_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...subContentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_96();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), {
              get ref() {
                return subContentState.opts.ref;
              },
              get interactOutsideBehavior() {
                return interactOutsideBehavior();
              },
              get escapeKeydownBehavior() {
                return escapeKeydownBehavior();
              },
              onCloseAutoFocus: handleCloseAutoFocus,
              onOpenAutoFocus: handleOpenAutoFocus,
              get open() {
                return subContentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              onFocusOutside: handleOnFocusOutside,
              preventScroll: false,
              get loop() {
                return loop();
              },
              get trapFocus() {
                return trapFocus();
              },
              isStatic: true,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content_static = hmr(Menu_sub_content_static, () => Menu_sub_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content_static[HMR].source;
    set(Menu_sub_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_static_default = Menu_sub_content_static;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte
Menu_sub_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte";
var root_312 = add_locations(from_html(`<div><!></div>`), Menu_sub_trigger[FILENAME], [[38, 2]]);
function Menu_sub_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "ref",
      "children",
      "child",
      "onSelect"
    ],
    "restProps"
  );
  const subTriggerState = MenuSubTriggerState.create({
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, subTriggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    get ref() {
      return subTriggerState.opts.ref;
    },
    children: wrap_snippet(Menu_sub_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_312();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_trigger = hmr(Menu_sub_trigger, () => Menu_sub_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_trigger[HMR].source;
    set(Menu_sub_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_trigger_default = Menu_sub_trigger;

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte
Menu_checkbox_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte";
var root_253 = add_locations(from_html(`<div><!></div>`), Menu_checkbox_item[FILENAME], [[91, 1]]);
function Menu_checkbox_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_checkbox_item);
  let ref = prop($$props, "ref", 15, null), checked = prop($$props, "checked", 15, false), id = prop($$props, "id", 19, () => createId(uid)), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), indeterminate = prop($$props, "indeterminate", 15, false), onIndeterminateChange = prop($$props, "onIndeterminateChange", 3, noop3), value = prop($$props, "value", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "checked",
      "id",
      "onCheckedChange",
      "disabled",
      "onSelect",
      "closeOnSelect",
      "indeterminate",
      "onIndeterminateChange",
      "value"
    ],
    "restProps"
  );
  const group = MenuCheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const checkboxItemState = MenuCheckboxItemState.create(
    {
      checked: box.with(() => checked(), (v) => {
        checked(v);
        onCheckedChange()(v);
      }),
      id: box.with(() => id()),
      disabled: box.with(() => disabled()),
      onSelect: box.with(() => handleSelect),
      ref: box.with(() => ref(), (v) => ref(v)),
      closeOnSelect: box.with(() => closeOnSelect()),
      indeterminate: box.with(() => indeterminate(), (v) => {
        indeterminate(v);
        onIndeterminateChange()(v);
      }),
      value: box.with(() => value())
    },
    group
  );
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    checkboxItemState.toggleChecked();
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, checkboxItemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        checked: checked(),
        indeterminate: indeterminate(),
        props: get(mergedProps)
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_253();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({
        checked: checked(),
        indeterminate: indeterminate()
      }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_checkbox_item = hmr(Menu_checkbox_item, () => Menu_checkbox_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_checkbox_item[HMR].source;
    set(Menu_checkbox_item[HMR].source, module.default[HMR].original);
  });
}
var menu_checkbox_item_default = Menu_checkbox_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-group.svelte
Menu_checkbox_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-group.svelte";
var root_254 = add_locations(from_html(`<div><!></div>`), Menu_checkbox_group[FILENAME], [[42, 1]]);
function Menu_checkbox_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_checkbox_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 31, () => tag_proxy(proxy([]), "value")), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "onValueChange"
    ],
    "restProps"
  );
  const checkboxGroupState = MenuCheckboxGroupState.create({
    value: box.with(() => snapshot(value()), (v) => {
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: box.with(() => onValueChange()),
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, checkboxGroupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_254();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_checkbox_group = hmr(Menu_checkbox_group, () => Menu_checkbox_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_checkbox_group[HMR].source;
    set(Menu_checkbox_group[HMR].source, module.default[HMR].original);
  });
}
var menu_checkbox_group_default = Menu_checkbox_group;

// node_modules/bits-ui/dist/bits/date-field/exports.js
var exports_exports12 = {};
__export(exports_exports12, {
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  Root: () => date_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-field/date-field.svelte.js
var dateFieldAttrs = createBitsAttrs({
  component: "date-field",
  parts: ["input", "label", "segment"]
});
var SEGMENT_CONFIGS = {
  day: {
    min: 1,
    max: (root18) => {
      const segmentMonthValue = root18.segmentValues.month;
      const placeholder = root18.value.current ?? root18.placeholder.current;
      return segmentMonthValue ? getDaysInMonth(placeholder.set({ month: Number.parseInt(segmentMonthValue) })) : getDaysInMonth(placeholder);
    },
    cycle: 1,
    padZero: true
  },
  month: {
    min: 1,
    max: 12,
    cycle: 1,
    padZero: true,
    getAnnouncement: (month, root18) => `${month} - ${root18.formatter.fullMonth(toDate(root18.placeholder.current.set({ month })))}`
  },
  year: { min: 1, max: 9999, cycle: 1, padZero: false },
  hour: {
    min: (root18) => strict_equals(root18.hourCycle.current, 12) ? 1 : 0,
    max: (root18) => {
      if (strict_equals(root18.hourCycle.current, 24)) return 23;
      if ("dayPeriod" in root18.segmentValues && strict_equals(root18.segmentValues.dayPeriod, null, false)) return 12;
      return 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  second: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  }
};
var DateFieldRootContext = new Context("DateField.Root");
var _segmentValues, _readonlySegmentsSet, _fieldNode, _labelNode3, _descriptionNode2, _validationNode, _dayPeriodNode, _name2, _DateFieldRootState_instances, clearUpdating_fn, _validationStatus, _isInvalid2, _inferredGranularity, _dateRef, _allSegmentContent, _segmentContents, getLabelledBy_fn;
var _DateFieldRootState = class _DateFieldRootState {
  constructor(props, rangeRoot) {
    __privateAdd(this, _DateFieldRootState_instances);
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "readonlySegments");
    __publicField(this, "hourCycle");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "isInvalidProp");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __publicField(this, "initialSegments");
    __privateAdd(this, _segmentValues, tag(state(), "DateFieldRootState.segmentValues"));
    __publicField(this, "announcer");
    __privateAdd(this, _readonlySegmentsSet, tag(user_derived(() => new Set(this.readonlySegments.current)), "DateFieldRootState.readonlySegmentsSet"));
    __publicField(this, "segmentStates", initSegmentStates());
    __privateAdd(this, _fieldNode, tag(state(null), "DateFieldRootState.#fieldNode"));
    __privateAdd(this, _labelNode3, tag(state(null), "DateFieldRootState.#labelNode"));
    __privateAdd(this, _descriptionNode2, tag(state(null), "DateFieldRootState.descriptionNode"));
    __privateAdd(this, _validationNode, tag(state(null), "DateFieldRootState.validationNode"));
    __publicField(this, "states", initSegmentStates());
    __privateAdd(this, _dayPeriodNode, tag(state(null), "DateFieldRootState.dayPeriodNode"));
    __publicField(this, "rangeRoot");
    __privateAdd(this, _name2, tag(state(""), "DateFieldRootState.name"));
    __publicField(this, "domContext", new DOMContext(() => null));
    __privateAdd(this, _validationStatus, tag(
      user_derived(() => {
        var _a, _b;
        const value = this.value.current;
        if (!value) return false;
        const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, value);
        if (msg) {
          return { reason: "custom", message: msg };
        }
        const minValue = this.minValue.current;
        if (minValue && isBefore(value, minValue)) {
          return { reason: "min" };
        }
        const maxValue = this.maxValue.current;
        if (maxValue && isBefore(maxValue, value)) {
          return { reason: "max" };
        }
        return false;
      }),
      "DateFieldRootState.validationStatus"
    ));
    __privateAdd(this, _isInvalid2, tag(
      user_derived(() => {
        if (strict_equals(this.validationStatus, false)) return false;
        if (this.isInvalidProp.current) return true;
        return true;
      }),
      "DateFieldRootState.isInvalid"
    ));
    __privateAdd(this, _inferredGranularity, tag(
      user_derived(() => {
        const granularity = this.granularity.current;
        if (granularity) return granularity;
        const inferred = inferGranularity(this.placeholder.current, this.granularity.current);
        return inferred;
      }),
      "DateFieldRootState.inferredGranularity"
    ));
    __privateAdd(this, _dateRef, tag(user_derived(() => this.value.current ?? this.placeholder.current), "DateFieldRootState.dateRef"));
    __privateAdd(this, _allSegmentContent, tag(
      user_derived(() => createContent({
        segmentValues: this.segmentValues,
        formatter: this.formatter,
        locale: this.locale.current,
        granularity: this.inferredGranularity,
        dateRef: this.dateRef,
        hideTimeZone: this.hideTimeZone.current,
        hourCycle: this.hourCycle.current
      })),
      "DateFieldRootState.allSegmentContent"
    ));
    __privateAdd(this, _segmentContents, tag(user_derived(() => this.allSegmentContent.arr), "DateFieldRootState.segmentContents"));
    __publicField(this, "sharedSegmentAttrs", {
      role: "spinbutton",
      contenteditable: "true",
      tabindex: 0,
      spellcheck: false,
      inputmode: "numeric",
      autocorrect: "off",
      enterkeyhint: "next",
      style: { caretColor: "transparent" }
    });
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? box(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycle = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createFormatter({
      initialLocale: this.locale.current,
      monthFormat: box.with(() => "long"),
      yearFormat: box.with(() => "numeric")
    });
    this.initialSegments = initializeSegmentValues(this.inferredGranularity);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = initializeSegmentValues(this.inferredGranularity);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      if (rangeRoot) return;
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: this.value.current,
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && strict_equals(placeholder, this.value.current, false)) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      __privateMethod(this, _DateFieldRootState_instances, clearUpdating_fn).call(this);
    });
    user_effect(() => {
      if (strict_equals(this.value.current, void 0)) {
        this.segmentValues = initializeSegmentValues(this.inferredGranularity);
      }
    });
    watch(() => this.validationStatus, () => {
      var _a, _b;
      if (strict_equals(this.validationStatus, false, false)) {
        (_b = (_a = this.onInvalid).current) == null ? void 0 : _b.call(_a, this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  static create(opts, rangeRoot) {
    return DateFieldRootContext.set(new _DateFieldRootState(opts, rangeRoot));
  }
  get segmentValues() {
    return get(__privateGet(this, _segmentValues));
  }
  set segmentValues(value) {
    set(__privateGet(this, _segmentValues), value, true);
  }
  get readonlySegmentsSet() {
    return get(__privateGet(this, _readonlySegmentsSet));
  }
  set readonlySegmentsSet(value) {
    set(__privateGet(this, _readonlySegmentsSet), value);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode2));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode2), value, true);
  }
  get validationNode() {
    return get(__privateGet(this, _validationNode));
  }
  set validationNode(value) {
    set(__privateGet(this, _validationNode), value, true);
  }
  get dayPeriodNode() {
    return get(__privateGet(this, _dayPeriodNode));
  }
  set dayPeriodNode(value) {
    set(__privateGet(this, _dayPeriodNode), value, true);
  }
  get name() {
    return get(__privateGet(this, _name2));
  }
  set name(value) {
    set(__privateGet(this, _name2), value, true);
  }
  setName(name) {
    this.name = name;
  }
  /**
   * Sets the field node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#fieldNode` private to prevent accidental usage of the incorrect field node.
   */
  setFieldNode(node) {
    set(__privateGet(this, _fieldNode), node, true);
  }
  /**
   * Gets the correct field node for the date field regardless of whether it's being
   * used in a standalone context or within a `DateRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _fieldNode));
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  /**
   * Sets the label node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#labelNode` private to prevent accidental usage of the incorrect label node.
   */
  setLabelNode(node) {
    set(__privateGet(this, _labelNode3), node, true);
  }
  /**
   * Gets the correct label node for the date field regardless of whether it's being used in
   * a standalone context or within a `DateRangeField` component.
   */
  getLabelNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _labelNode3));
    }
    return this.rangeRoot.labelNode;
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const dateValues = DATE_SEGMENT_PARTS.map((part) => {
      const partValue = value[part];
      if (strict_equals(part, "month")) {
        if (this.states.month.updating) {
          return [part, this.states.month.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "day")) {
        if (this.states.day.updating) {
          return [part, this.states.day.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "year")) {
        if (this.states.year.updating) {
          return [part, this.states.year.updating];
        }
        const valueDigits = `${partValue}`.length;
        const diff = 4 - valueDigits;
        if (diff > 0) {
          return [part, `${"0".repeat(diff)}${partValue}`];
        }
      }
      return [part, `${partValue}`];
    });
    if ("hour" in value) {
      const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
        if (strict_equals(part, "dayPeriod")) {
          if (this.states.dayPeriod.updating) {
            return [part, this.states.dayPeriod.updating];
          } else {
            return [
              part,
              this.formatter.dayPeriod(toDate(value))
            ];
          }
        } else if (strict_equals(part, "hour")) {
          if (this.states.hour.updating) {
            return [part, this.states.hour.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
          if (strict_equals(value[part], 0)) {
            if (this.dayPeriodNode) {
              return [part, "12"];
            }
          }
        } else if (strict_equals(part, "minute")) {
          if (this.states.minute.updating) {
            return [part, this.states.minute.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        } else if (strict_equals(part, "second")) {
          if (this.states.second.updating) {
            return [part, this.states.second.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        }
        return [part, `${value[part]}`];
      });
      const mergedSegmentValues = [...dateValues, ...timeValues];
      this.segmentValues = Object.fromEntries(mergedSegmentValues);
      __privateMethod(this, _DateFieldRootState_instances, clearUpdating_fn).call(this);
      return;
    }
    this.segmentValues = Object.fromEntries(dateValues);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid2));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid2), value);
  }
  get inferredGranularity() {
    return get(__privateGet(this, _inferredGranularity));
  }
  set inferredGranularity(value) {
    set(__privateGet(this, _inferredGranularity), value);
  }
  get dateRef() {
    return get(__privateGet(this, _dateRef));
  }
  set dateRef(value) {
    set(__privateGet(this, _dateRef), value);
  }
  get allSegmentContent() {
    return get(__privateGet(this, _allSegmentContent));
  }
  set allSegmentContent(value) {
    set(__privateGet(this, _allSegmentContent), value);
  }
  get segmentContents() {
    return get(__privateGet(this, _segmentContents));
  }
  set segmentContents(value) {
    set(__privateGet(this, _segmentContents), value);
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    const dateRef = this.placeholder.current;
    if (isDateAndTimeSegmentObj(prev2)) {
      const pVal = prev2[part];
      const castCb = cb;
      if (strict_equals(part, "month")) {
        const next3 = castCb(pVal);
        this.states.month.updating = next3;
        if (strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
          const date = dateRef.set({ month: Number.parseInt(next3) });
          const daysInMonth = getDaysInMonth(toDate(date));
          const prevDay = Number.parseInt(prev2.day);
          if (prevDay > daysInMonth) {
            prev2.day = `${daysInMonth}`;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "dayPeriod")) {
        const next3 = castCb(pVal);
        this.states.dayPeriod.updating = next3;
        const date = this.value.current;
        if (date && "hour" in date) {
          const trueHour = date.hour;
          if (strict_equals(next3, "AM")) {
            if (trueHour >= 12) {
              prev2.hour = `${trueHour - 12}`;
            }
          } else if (strict_equals(next3, "PM")) {
            if (trueHour < 12) {
              prev2.hour = `${trueHour + 12}`;
            }
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "hour")) {
        const next3 = castCb(pVal);
        this.states.hour.updating = next3;
        if (strict_equals(next3, null, false) && strict_equals(prev2.dayPeriod, null, false)) {
          const dayPeriod = this.formatter.dayPeriod(toDate(dateRef.set({ hour: Number.parseInt(next3) })), this.hourCycle.current);
          if (strict_equals(dayPeriod, "AM") || strict_equals(dayPeriod, "PM")) {
            prev2.dayPeriod = dayPeriod;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "minute")) {
        const next3 = castCb(pVal);
        this.states.minute.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "second")) {
        const next3 = castCb(pVal);
        this.states.second.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "year")) {
        const next3 = castCb(pVal);
        this.states.year.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "day")) {
        const next3 = castCb(pVal);
        this.states.day.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else {
        const next3 = castCb(pVal);
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    } else if (isDateSegmentPart(part)) {
      const pVal = prev2[part];
      const castCb = cb;
      const next3 = castCb(pVal);
      if (strict_equals(part, "month") && strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
        this.states.month.updating = next3;
        const date = dateRef.set({ month: Number.parseInt(next3) });
        const daysInMonth = getDaysInMonth(toDate(date));
        if (Number.parseInt(prev2.day) > daysInMonth) {
          prev2.day = `${daysInMonth}`;
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "year")) {
        const next4 = castCb(pVal);
        this.states.year.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else if (strict_equals(part, "day")) {
        const next4 = castCb(pVal);
        this.states.day.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else {
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    }
    this.segmentValues = newSegmentValues;
    if (areAllSegmentsFilled(newSegmentValues, get(__privateGet(this, _fieldNode)))) {
      this.setValue(getValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(__privateGet(this, _fieldNode)),
        dateRef: this.placeholder.current
      }));
    } else {
      this.setValue(void 0);
      this.segmentValues = newSegmentValues;
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    var _a, _b;
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": getAriaInvalid(this.isInvalid),
      "aria-disabled": getAriaDisabled(this.disabled.current),
      "aria-readonly": getAriaReadonly(this.readonly.current || inReadonlySegments),
      "data-invalid": getDataInvalid(this.isInvalid),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-readonly": getDataReadonly(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`,
      [dateFieldAttrs.segment]: ""
    };
    if (strict_equals(part, "literal")) return defaultAttrs;
    const descriptionId = (_a = this.descriptionNode) == null ? void 0 : _a.id;
    const hasDescription = isFirstSegment(segmentId, get(__privateGet(this, _fieldNode))) && descriptionId;
    const errorMsgId = (_b = this.errorMessageId) == null ? void 0 : _b.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": __privateMethod(this, _DateFieldRootState_instances, getLabelledBy_fn).call(this, segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
_segmentValues = new WeakMap();
_readonlySegmentsSet = new WeakMap();
_fieldNode = new WeakMap();
_labelNode3 = new WeakMap();
_descriptionNode2 = new WeakMap();
_validationNode = new WeakMap();
_dayPeriodNode = new WeakMap();
_name2 = new WeakMap();
_DateFieldRootState_instances = new WeakSet();
clearUpdating_fn = function() {
  this.states.day.updating = null;
  this.states.month.updating = null;
  this.states.year.updating = null;
  this.states.hour.updating = null;
  this.states.minute.updating = null;
  this.states.dayPeriod.updating = null;
};
_validationStatus = new WeakMap();
_isInvalid2 = new WeakMap();
_inferredGranularity = new WeakMap();
_dateRef = new WeakMap();
_allSegmentContent = new WeakMap();
_segmentContents = new WeakMap();
getLabelledBy_fn = function(segmentId) {
  var _a;
  return `${segmentId} ${((_a = this.getLabelNode()) == null ? void 0 : _a.id) ?? ""}`;
};
var DateFieldRootState = _DateFieldRootState;
var _ariaDescribedBy, _props80;
var _DateFieldInputState = class _DateFieldInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _ariaDescribedBy, tag(
      user_derived(() => {
        if (!isBrowser) return void 0;
        const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
        if (!doesDescriptionExist) return void 0;
        return this.root.descriptionId;
      }),
      "DateFieldInputState.#ariaDescribedBy"
    ));
    __privateAdd(this, _props80, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          role: "group",
          "aria-labelledby": ((_a = this.root.getLabelNode()) == null ? void 0 : _a.id) ?? void 0,
          "aria-describedby": get(__privateGet(this, _ariaDescribedBy)),
          "aria-disabled": getAriaDisabled(this.root.disabled.current),
          "data-invalid": this.root.isInvalid ? "" : void 0,
          "data-disabled": getDataDisabled(this.root.disabled.current),
          [dateFieldAttrs.input]: "",
          ...this.attachment
        };
      }),
      "DateFieldInputState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.root.domContext = this.domContext;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    watch(() => this.opts.name.current, (v) => {
      this.root.setName(v);
    });
  }
  static create(opts) {
    return new _DateFieldInputState(opts, DateFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props80));
  }
  set props(value) {
    set(__privateGet(this, _props80), value);
  }
};
_ariaDescribedBy = new WeakMap();
_props80 = new WeakMap();
var DateFieldInputState = _DateFieldInputState;
var _shouldRender7, _isoValue, _props81;
var _DateFieldHiddenInputState = class _DateFieldHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender7, tag(user_derived(() => strict_equals(this.root.name, "", false)), "DateFieldHiddenInputState.shouldRender"));
    __privateAdd(this, _isoValue, tag(user_derived(() => this.root.value.current ? this.root.value.current.toString() : ""), "DateFieldHiddenInputState.isoValue"));
    __privateAdd(this, _props81, tag(
      user_derived(() => {
        return {
          name: this.root.name,
          value: this.isoValue,
          required: this.root.required.current
        };
      }),
      "DateFieldHiddenInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _DateFieldHiddenInputState(DateFieldRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender7));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender7), value);
  }
  get isoValue() {
    return get(__privateGet(this, _isoValue));
  }
  set isoValue(value) {
    set(__privateGet(this, _isoValue), value);
  }
  get props() {
    return get(__privateGet(this, _props81));
  }
  set props(value) {
    set(__privateGet(this, _props81), value);
  }
};
_shouldRender7 = new WeakMap();
_isoValue = new WeakMap();
_props81 = new WeakMap();
var DateFieldHiddenInputState = _DateFieldHiddenInputState;
var _props82;
var _DateFieldLabelState = class _DateFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props82, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-invalid": getDataInvalid(this.root.isInvalid),
        "data-disabled": getDataDisabled(this.root.disabled.current),
        [dateFieldAttrs.label]: "",
        onclick: this.onclick,
        ...this.attachment
      })),
      "DateFieldLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
  }
  static create(opts) {
    return new _DateFieldLabelState(opts, DateFieldRootContext.get());
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  get props() {
    return get(__privateGet(this, _props82));
  }
  set props(value) {
    set(__privateGet(this, _props82), value);
  }
};
_props82 = new WeakMap();
var DateFieldLabelState = _DateFieldLabelState;
var _BaseNumericSegmentState_instances, getMax_fn, getMin_fn, getAnnouncement_fn, formatValue_fn, handleArrowUp_fn, handleArrowDown_fn, handleNumberKey_fn, handleBackspace_fn, _props83;
var BaseNumericSegmentState = class {
  constructor(opts, root18, part, config) {
    __privateAdd(this, _BaseNumericSegmentState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "announcer");
    __publicField(this, "part");
    __publicField(this, "config");
    __publicField(this, "attachment");
    __privateAdd(this, _props83, tag(
      user_derived(() => {
        return {
          ...this.root.sharedSegmentAttrs,
          id: this.opts.id.current,
          ...this.getSegmentProps(),
          onkeydown: this.onkeydown,
          onfocusout: this.onfocusout,
          onclick: this.root.handleSegmentClick,
          ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
          ...this.attachment
        };
      }),
      "BaseNumericSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if ((strict_equals(this.part, "hour") || strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && !(this.part in placeholder)) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleArrowUp_fn).call(this, placeholder);
      return;
    }
    if (isArrowDown(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleArrowDown_fn).call(this, placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleNumberKey_fn).call(this, e);
      return;
    }
    if (isBackspace(e.key)) {
      __privateMethod(this, _BaseNumericSegmentState_instances, handleBackspace_fn).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = strict_equals(segmentValues[this.part], null);
    let date = placeholder;
    if (segmentValues[this.part]) {
      date = placeholder.set({
        [this.part]: Number.parseInt(segmentValues[this.part])
      });
    }
    const valueNow = date[this.part];
    const valueMin = __privateMethod(this, _BaseNumericSegmentState_instances, getMin_fn).call(this);
    const valueMax = __privateMethod(this, _BaseNumericSegmentState_instances, getMax_fn).call(this);
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (strict_equals(this.part, "hour") && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  get props() {
    return get(__privateGet(this, _props83));
  }
  set props(value) {
    set(__privateGet(this, _props83), value);
  }
};
_BaseNumericSegmentState_instances = new WeakSet();
getMax_fn = function() {
  return strict_equals(typeof this.config.max, "function") ? this.config.max(this.root) : this.config.max;
};
getMin_fn = function() {
  return strict_equals(typeof this.config.min, "function") ? this.config.min(this.root) : this.config.min;
};
getAnnouncement_fn = function(value) {
  if (this.config.getAnnouncement) {
    return this.config.getAnnouncement(value, this.root);
  }
  return value;
};
formatValue_fn = function(value, forDisplay = true) {
  const str = String(value);
  if (forDisplay && this.config.padZero && strict_equals(str.length, 1)) {
    return `0${value}`;
  }
  return str;
};
handleArrowUp_fn = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      const next4 = placeholder[this.part];
      this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next4));
      return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, this.config.cycle)[this.part];
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next3);
  });
};
handleArrowDown_fn = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      const next4 = placeholder[this.part];
      this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next4));
      return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return __privateMethod(this, _BaseNumericSegmentState_instances, formatValue_fn).call(this, next3);
  });
};
handleNumberKey_fn = function(e) {
  const num = Number.parseInt(e.key);
  let moveToNext = false;
  const max = __privateMethod(this, _BaseNumericSegmentState_instances, getMax_fn).call(this);
  const maxStart = Math.floor(max / 10);
  const numIsZero = strict_equals(num, 0);
  const stateKey = this.part;
  this.root.updateSegment(this.part, (prev2) => {
    if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
      prev2 = null;
      this.root.states[stateKey].hasLeftFocus = false;
    }
    if (strict_equals(prev2, null)) {
      if (numIsZero) {
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = true;
        }
        this.announcer.announce("0");
        return "0";
      }
      if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
        moveToNext = true;
      }
      if (stateKey in this.root.states) {
        this.root.states[stateKey].lastKeyZero = false;
      }
      if (moveToNext && strict_equals(String(num).length, 1)) {
        this.announcer.announce(num);
        return `0${num}`;
      }
      return `${num}`;
    }
    if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
      if (strict_equals(num, 0, false)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `0${num}`;
      }
      if (strict_equals(this.part, "hour") && strict_equals(num, 0) && strict_equals(this.root.hourCycle.current, 24)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `00`;
      }
      if ((strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && strict_equals(num, 0)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return "00";
      }
      return prev2;
    }
    const total = Number.parseInt(prev2 + num.toString());
    if (total > max) {
      moveToNext = true;
      return `0${num}`;
    }
    moveToNext = true;
    return `${total}`;
  });
  if (moveToNext) {
    moveToNextSegment(e, this.root.getFieldNode());
  }
};
handleBackspace_fn = function(e) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  let moveToPrev = false;
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (strict_equals(str.length, 1)) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = Number.parseInt(str.slice(0, -1));
    this.announcer.announce(__privateMethod(this, _BaseNumericSegmentState_instances, getAnnouncement_fn).call(this, next3));
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevSegment(e, this.root.getFieldNode());
  }
};
_props83 = new WeakMap();
var _pressedKeys, _backspaceCount, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn, incrementBackspaceCount_fn, handleYearNumberKey_fn, handleYearBackspace_fn;
var DateFieldYearSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "year", SEGMENT_CONFIGS.year);
    __privateAdd(this, _DateFieldYearSegmentState_instances);
    __privateAdd(this, _pressedKeys, []);
    __privateAdd(this, _backspaceCount, 0);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
      super.onkeydown(e);
      return;
    }
    if (isArrowDown(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
      super.onkeydown(e);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, handleYearNumberKey_fn).call(this, e);
      return;
    }
    if (isBackspace(e.key)) {
      __privateMethod(this, _DateFieldYearSegmentState_instances, handleYearBackspace_fn).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    this.root.states.year.hasLeftFocus = true;
    __privateSet(this, _pressedKeys, []);
    __privateMethod(this, _DateFieldYearSegmentState_instances, resetBackspaceCount_fn).call(this);
    this.root.updateSegment("year", (prev2) => {
      if (prev2 && strict_equals(prev2.length, 4, false)) {
        return prependYearZeros(Number.parseInt(prev2));
      }
      return prev2;
    });
  }
};
_pressedKeys = new WeakMap();
_backspaceCount = new WeakMap();
_DateFieldYearSegmentState_instances = new WeakSet();
resetBackspaceCount_fn = function() {
  __privateSet(this, _backspaceCount, 0);
};
incrementBackspaceCount_fn = function() {
  __privateWrapper(this, _backspaceCount)._++;
};
handleYearNumberKey_fn = function(e) {
  __privateGet(this, _pressedKeys).push(e.key);
  let moveToNext = false;
  const num = Number.parseInt(e.key);
  this.root.updateSegment("year", (prev2) => {
    if (this.root.states.year.hasLeftFocus) {
      prev2 = null;
      this.root.states.year.hasLeftFocus = false;
    }
    if (strict_equals(prev2, null)) {
      this.announcer.announce(num);
      return `000${num}`;
    }
    const str = prev2.toString() + num.toString();
    const mergedInt = Number.parseInt(str);
    const mergedIntDigits = String(mergedInt).length;
    if (mergedIntDigits < 4) {
      if (__privateGet(this, _backspaceCount) > 0 && __privateGet(this, _pressedKeys).length <= __privateGet(this, _backspaceCount) && str.length <= 4) {
        this.announcer.announce(mergedInt);
        return str;
      }
      this.announcer.announce(mergedInt);
      return prependYearZeros(mergedInt);
    }
    this.announcer.announce(mergedInt);
    moveToNext = true;
    const mergedIntStr = `${mergedInt}`;
    if (mergedIntStr.length > 4) {
      return mergedIntStr.slice(0, 4);
    }
    return mergedIntStr;
  });
  if (strict_equals(__privateGet(this, _pressedKeys).length, 4) || strict_equals(__privateGet(this, _pressedKeys).length, __privateGet(this, _backspaceCount))) {
    moveToNext = true;
  }
  if (moveToNext) {
    moveToNextSegment(e, this.root.getFieldNode());
  }
};
handleYearBackspace_fn = function(e) {
  __privateSet(this, _pressedKeys, []);
  __privateMethod(this, _DateFieldYearSegmentState_instances, incrementBackspaceCount_fn).call(this);
  let moveToPrev = false;
  this.root.updateSegment("year", (prev2) => {
    this.root.states.year.hasLeftFocus = false;
    if (strict_equals(prev2, null)) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (strict_equals(str.length, 1)) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = str.slice(0, -1);
    this.announcer.announce(next3);
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevSegment(e, this.root.getFieldNode());
  }
};
var DateFieldDaySegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "day", SEGMENT_CONFIGS.day);
  }
};
var DateFieldMonthSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "month", SEGMENT_CONFIGS.month);
  }
};
var DateFieldHourSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS.hour);
  }
  // Override to handle special hour logic
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (strict_equals(part, "hour") && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (strict_equals(hourValue, "0") && this.root.dayPeriodNode && strict_equals(this.root.hourCycle.current, 24, false)) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var DateFieldMinuteSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS.minute);
  }
};
var DateFieldSecondSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS.second);
  }
};
var _announcer, _props84;
var _DateFieldDayPeriodSegmentState = class _DateFieldDayPeriodSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _announcer);
    __privateAdd(this, _props84, tag(
      user_derived(() => {
        const segmentValues = this.root.segmentValues;
        if (!("dayPeriod" in segmentValues)) return;
        const valueMin = 0;
        const valueMax = 12;
        const valueNow = strict_equals(segmentValues.dayPeriod, "AM") ? 0 : 12;
        const valueText = segmentValues.dayPeriod ?? "AM";
        return {
          ...this.root.sharedSegmentAttrs,
          id: this.opts.id.current,
          inputmode: "text",
          "aria-label": "AM/PM",
          "aria-valuemin": valueMin,
          "aria-valuemax": valueMax,
          "aria-valuenow": valueNow,
          "aria-valuetext": valueText,
          onkeydown: this.onkeydown,
          onclick: this.root.handleSegmentClick,
          ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
          ...this.attachment
        };
      }),
      "DateFieldDayPeriodSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _announcer, this.root.announcer);
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
  }
  static create(opts) {
    return new _DateFieldDayPeriodSegmentState(opts, DateFieldRootContext.get());
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableDayPeriodKey(e.key)) return;
    if (isArrowUp(e.key) || isArrowDown(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (strict_equals(prev2, "AM")) {
          const next4 = "PM";
          __privateGet(this, _announcer).announce(next4);
          return next4;
        }
        const next3 = "AM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
    }
    if (strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.P) || kbd_constants_exports.a || kbd_constants_exports.p) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.a) ? "AM" : "PM";
        __privateGet(this, _announcer).announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props84));
  }
  set props(value) {
    set(__privateGet(this, _props84), value);
  }
};
_announcer = new WeakMap();
_props84 = new WeakMap();
var DateFieldDayPeriodSegmentState = _DateFieldDayPeriodSegmentState;
var _props85;
var _DateFieldLiteralSegmentState = class _DateFieldLiteralSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props85, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-hidden": getAriaHidden(true),
        ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
        ...this.attachment
      })),
      "DateFieldLiteralSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _DateFieldLiteralSegmentState(opts, DateFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props85));
  }
  set props(value) {
    set(__privateGet(this, _props85), value);
  }
};
_props85 = new WeakMap();
var DateFieldLiteralSegmentState = _DateFieldLiteralSegmentState;
var _props86;
var _DateFieldTimeZoneSegmentState = class _DateFieldTimeZoneSegmentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props86, tag(
      user_derived(() => ({
        role: "textbox",
        id: this.opts.id.current,
        "aria-label": "timezone, ",
        style: { caretColor: "transparent" },
        onkeydown: this.onkeydown,
        ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
        "data-readonly": getDataReadonly(true),
        ...this.attachment
      })),
      "DateFieldTimeZoneSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _DateFieldTimeZoneSegmentState(opts, DateFieldRootContext.get());
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props86));
  }
  set props(value) {
    set(__privateGet(this, _props86), value);
  }
};
_props86 = new WeakMap();
var DateFieldTimeZoneSegmentState = _DateFieldTimeZoneSegmentState;
var DateFieldSegmentState = class {
  static create(part, opts) {
    const root18 = DateFieldRootContext.get();
    switch (part) {
      case "day":
        return new DateFieldDaySegmentState(opts, root18);
      case "month":
        return new DateFieldMonthSegmentState(opts, root18);
      case "year":
        return new DateFieldYearSegmentState(opts, root18);
      case "hour":
        return new DateFieldHourSegmentState(opts, root18);
      case "minute":
        return new DateFieldMinuteSegmentState(opts, root18);
      case "second":
        return new DateFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new DateFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new DateFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new DateFieldTimeZoneSegmentState(opts, root18);
    }
  }
};
function isAcceptableDayPeriodKey(key) {
  return isAcceptableSegmentKey(key) || strict_equals(key, kbd_constants_exports.A) || strict_equals(key, kbd_constants_exports.P) || strict_equals(key, kbd_constants_exports.a) || strict_equals(key, kbd_constants_exports.p);
}
function isArrowUp(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_UP);
}
function isArrowDown(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_DOWN);
}
function isBackspace(key) {
  return strict_equals(key, kbd_constants_exports.BACKSPACE);
}
function prependYearZeros(year) {
  const digits = String(year).length;
  const diff = 4 - digits;
  return `${"0".repeat(diff)}${year}`;
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte
Date_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte";
function Date_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultValue: value()
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  DateFieldRootState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    granularity: box.with(() => $$props.granularity),
    hideTimeZone: box.with(() => hideTimeZone()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    validate: box.with(() => validate()),
    readonly: box.with(() => readonly()),
    readonlySegments: box.with(() => readonlySegments()),
    required: box.with(() => required()),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field = hmr(Date_field, () => Date_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field[HMR].source;
    set(Date_field[HMR].source, module.default[HMR].original);
  });
}
var date_field_default = Date_field;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte
Date_field_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte";
function Date_field_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_field_hidden_input);
  const hiddenInputState = DateFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => hiddenInputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => hiddenInputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_hidden_input = hmr(Date_field_hidden_input, () => Date_field_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_hidden_input[HMR].source;
    set(Date_field_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_hidden_input_default = Date_field_hidden_input;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte
Date_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte";
var root_255 = add_locations(from_html(`<div><!></div>`), Date_field_input[FILENAME], [[34, 1]]);
var root7 = add_locations(from_html(`<!> <!>`, 1), Date_field_input[FILENAME], []);
function Date_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "children",
      "child"
    ],
    "restProps"
  );
  const inputState = DateFieldInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    name: box.with(() => name())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = root7();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_255();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  date_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_input = hmr(Date_field_input, () => Date_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_input[HMR].source;
    set(Date_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_input_default = Date_field_input;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte
Date_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte";
var root_256 = add_locations(from_html(`<div><!></div>`), Date_field_label[FILENAME], [[31, 1]]);
function Date_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = DateFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_256();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_label = hmr(Date_field_label, () => Date_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_label[HMR].source;
    set(Date_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_field_label_default = Date_field_label;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte
Date_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte";
var root_257 = add_locations(from_html(`<span><!></span>`), Date_field_segment[FILENAME], [[34, 1]]);
function Date_field_segment($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_segment);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "part"
    ],
    "restProps"
  );
  const segmentState = DateFieldSegmentState.create($$props.part, {
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, segmentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_257();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_segment = hmr(Date_field_segment, () => Date_field_segment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_segment[HMR].source;
    set(Date_field_segment[HMR].source, module.default[HMR].original);
  });
}
var date_field_segment_default = Date_field_segment;

// node_modules/bits-ui/dist/bits/date-picker/exports.js
var exports_exports13 = {};
__export(exports_exports13, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_picker_calendar_default,
  Cell: () => calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  ContentStatic: () => date_picker_content_static_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  Portal: () => portal_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_picker_trigger_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/date-picker/date-picker.svelte.js
var DatePickerRootContext = new Context("DatePicker.Root");
var DatePickerRootState = class _DatePickerRootState {
  constructor(opts) {
    __publicField(this, "opts");
    this.opts = opts;
  }
  static create(opts) {
    return DatePickerRootContext.set(new _DatePickerRootState(opts));
  }
};

// node_modules/bits-ui/dist/bits/popover/popover.svelte.js
var popoverAttrs = createBitsAttrs({
  component: "popover",
  parts: ["root", "trigger", "content", "close"]
});
var PopoverRootContext = new Context("Popover.Root");
var _contentNode5, _triggerNode4;
var _PopoverRootState = class _PopoverRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _contentNode5, tag(state(null), "PopoverRootState.contentNode"));
    __privateAdd(this, _triggerNode4, tag(state(null), "PopoverRootState.triggerNode"));
    this.opts = opts;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  static create(opts) {
    return PopoverRootContext.set(new _PopoverRootState(opts));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode5));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode5), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode4));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode4), value, true);
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
};
_contentNode5 = new WeakMap();
_triggerNode4 = new WeakMap();
var PopoverRootState = _PopoverRootState;
var _PopoverTriggerState_instances, getAriaControls_fn, _props87;
var _PopoverTriggerState = class _PopoverTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _PopoverTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props87, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-haspopup": "dialog",
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "aria-controls": __privateMethod(this, _PopoverTriggerState_instances, getAriaControls_fn).call(this),
        [popoverAttrs.trigger]: "",
        disabled: this.opts.disabled.current,
        //
        onkeydown: this.onkeydown,
        onclick: this.onclick,
        ...this.attachment
      })),
      "PopoverTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PopoverTriggerState(opts, PopoverRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
    e.preventDefault();
    this.root.toggleOpen();
  }
  get props() {
    return get(__privateGet(this, _props87));
  }
  set props(value) {
    set(__privateGet(this, _props87), value);
  }
};
_PopoverTriggerState_instances = new WeakSet();
getAriaControls_fn = function() {
  var _a, _b;
  if (this.root.opts.open.current && ((_a = this.root.contentNode) == null ? void 0 : _a.id)) {
    return (_b = this.root.contentNode) == null ? void 0 : _b.id;
  }
  return void 0;
};
_props87 = new WeakMap();
var PopoverTriggerState = _PopoverTriggerState;
var _snippetProps15, _props88;
var _PopoverContentState = class _PopoverContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      if (!isElement2(e.target)) return;
      const closestTrigger = e.target.closest(popoverAttrs.selector("trigger"));
      if (strict_equals(closestTrigger, this.root.triggerNode)) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      this.opts.onEscapeKeydown.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      var _a;
      this.opts.onCloseAutoFocus.current(e);
      if (e.defaultPrevented) return;
      e.preventDefault();
      (_a = this.root.triggerNode) == null ? void 0 : _a.focus();
    });
    __privateAdd(this, _snippetProps15, tag(user_derived(() => ({ open: this.root.opts.open.current })), "PopoverContentState.snippetProps"));
    __privateAdd(this, _props88, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        tabindex: -1,
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        [popoverAttrs.content]: "",
        style: { pointerEvents: "auto" },
        ...this.attachment
      })),
      "PopoverContentState.props"
    ));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onCloseAutoFocus: this.onCloseAutoFocus
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
  }
  static create(opts) {
    return new _PopoverContentState(opts, PopoverRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps15));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps15), value);
  }
  get props() {
    return get(__privateGet(this, _props88));
  }
  set props(value) {
    set(__privateGet(this, _props88), value);
  }
};
_snippetProps15 = new WeakMap();
_props88 = new WeakMap();
var PopoverContentState = _PopoverContentState;
var _props89;
var _PopoverCloseState = class _PopoverCloseState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props89, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        type: "button",
        [popoverAttrs.close]: "",
        ...this.attachment
      })),
      "PopoverCloseState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PopoverCloseState(opts, PopoverRootContext.get());
  }
  onclick(_) {
    this.root.handleClose();
  }
  onkeydown(e) {
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
    e.preventDefault();
    this.root.handleClose();
  }
  get props() {
    return get(__privateGet(this, _props89));
  }
  set props(value) {
    set(__privateGet(this, _props89), value);
  }
};
_props89 = new WeakMap();
var PopoverCloseState = _PopoverCloseState;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte
Date_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte";
function Date_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnDateSelect = prop($$props, "closeOnDateSelect", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric");
  const defaultPlaceholder = getDefaultDate({
    granularity: $$props.granularity,
    defaultValue: value()
  });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onDateSelect() {
    if (closeOnDateSelect()) {
      open(false);
    }
  }
  const pickerRootState = DatePickerRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    initialFocus: box.with(() => initialFocus()),
    onDateSelect: box.with(() => onDateSelect),
    defaultPlaceholder,
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat())
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  DateFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: box.with(() => validate()),
    onInvalid: box.with(() => onInvalid()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, FloatingLayer_Root) => {
    FloatingLayer_Root($$anchor2, {
      children: wrap_snippet(Date_picker, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker = hmr(Date_picker, () => Date_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker[HMR].source;
    set(Date_picker[HMR].source, module.default[HMR].original);
  });
}
var date_picker_default = Date_picker;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte
Date_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte";
var root_258 = add_locations(from_html(`<div><!></div>`), Date_picker_calendar[FILENAME], [[58, 1]]);
function Date_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_picker_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const datePickerRootState = DatePickerRootContext.get();
  const calendarState = CalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: datePickerRootState.opts.calendarLabel,
    fixedWeeks: datePickerRootState.opts.fixedWeeks,
    isDateDisabled: datePickerRootState.opts.isDateDisabled,
    isDateUnavailable: datePickerRootState.opts.isDateUnavailable,
    locale: datePickerRootState.opts.locale,
    numberOfMonths: datePickerRootState.opts.numberOfMonths,
    pagedNavigation: datePickerRootState.opts.pagedNavigation,
    preventDeselect: datePickerRootState.opts.preventDeselect,
    readonly: datePickerRootState.opts.readonly,
    type: box.with(() => "single"),
    weekStartsOn: datePickerRootState.opts.weekStartsOn,
    weekdayFormat: datePickerRootState.opts.weekdayFormat,
    disabled: datePickerRootState.opts.disabled,
    disableDaysOutsideMonth: datePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: datePickerRootState.opts.maxValue,
    minValue: datePickerRootState.opts.minValue,
    placeholder: datePickerRootState.opts.placeholder,
    value: datePickerRootState.opts.value,
    onDateSelect: datePickerRootState.opts.onDateSelect,
    initialFocus: datePickerRootState.opts.initialFocus,
    defaultPlaceholder: datePickerRootState.opts.defaultPlaceholder,
    maxDays: box.with(() => void 0),
    monthFormat: datePickerRootState.opts.monthFormat,
    yearFormat: datePickerRootState.opts.yearFormat
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, calendarState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...calendarState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_258();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => calendarState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_calendar = hmr(Date_picker_calendar, () => Date_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_calendar[HMR].source;
    set(Date_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_picker_calendar_default = Date_picker_calendar;

// node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte
Popover_content[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte";
var root_411 = add_locations(from_html(`<div><div><!></div></div>`), Popover_content[FILENAME], [[60, 4, [[61, 5]]]]);
var root_97 = add_locations(from_html(`<div><div><!></div></div>`), Popover_content[FILENAME], [[87, 4, [[88, 5]]]]);
function Popover_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = PopoverContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_411();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Popover_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_97();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content = hmr(Popover_content, () => Popover_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content[HMR].source;
    set(Popover_content[HMR].source, module.default[HMR].original);
  });
}
var popover_content_default = Popover_content;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte
Date_picker_content[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte";
function Date_picker_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_content_default, ref);
    popover_content_default(node, spread_props(() => get(mergedProps), () => restProps, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content = hmr(Date_picker_content, () => Date_picker_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content[HMR].source;
    set(Date_picker_content[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_default = Date_picker_content;

// node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte
Popover_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte";
var root_412 = add_locations(from_html(`<div><!></div>`), Popover_content_static[FILENAME], [[61, 4]]);
var root_98 = add_locations(from_html(`<div><!></div>`), Popover_content_static[FILENAME], [[87, 4]]);
function Popover_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_content_static);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = PopoverContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("popover")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_412();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          get trapFocus() {
            return trapFocus();
          },
          get preventScroll() {
            return preventScroll();
          },
          loop: true,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Popover_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("popover")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_98();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              get trapFocus() {
                return trapFocus();
              },
              get preventScroll() {
                return preventScroll();
              },
              loop: true,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content_static = hmr(Popover_content_static, () => Popover_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content_static[HMR].source;
    set(Popover_content_static[HMR].source, module.default[HMR].original);
  });
}
var popover_content_static_default = Popover_content_static;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte
Date_picker_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte";
function Date_picker_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content_static);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_content_static_default, ref);
    popover_content_static_default(node, spread_props(() => get(mergedProps), () => restProps, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content_static = hmr(Date_picker_content_static, () => Date_picker_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content_static[HMR].source;
    set(Date_picker_content_static[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_static_default = Date_picker_content_static;

// node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte
Popover_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte";
var root_313 = add_locations(from_html(`<button><!></button>`), Popover_trigger[FILENAME], [[36, 2]]);
function Popover_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = PopoverTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: wrap_snippet(Popover_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_313();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_trigger = hmr(Popover_trigger, () => Popover_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_trigger[HMR].source;
    set(Popover_trigger[HMR].source, module.default[HMR].original);
  });
}
var popover_trigger_default = Popover_trigger;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte
Date_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte";
function Date_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_trigger);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onkeydown"
    ],
    "restProps"
  );
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateFieldAttrs.selector("input"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = tag(user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_trigger_default, ref);
    popover_trigger_default(node, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_trigger = hmr(Date_picker_trigger, () => Date_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_trigger[HMR].source;
    set(Date_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_picker_trigger_default = Date_picker_trigger;

// node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte
Popover_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte";
function Popover_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    floating_layer_arrow_default(node, spread_props(() => restProps, {
      "data-popover-arrow": "",
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_arrow = hmr(Popover_arrow, () => Popover_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_arrow[HMR].source;
    set(Popover_arrow[HMR].source, module.default[HMR].original);
  });
}
var popover_arrow_default = Popover_arrow;

// node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte
Popover_close[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte";
var root_259 = add_locations(from_html(`<button><!></button>`), Popover_close[FILENAME], [[30, 1]]);
function Popover_close($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_close);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const closeState = PopoverCloseState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, closeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_259();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_close = hmr(Popover_close, () => Popover_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_close[HMR].source;
    set(Popover_close[HMR].source, module.default[HMR].original);
  });
}
var popover_close_default = Popover_close;

// node_modules/bits-ui/dist/bits/date-range-field/exports.js
var exports_exports14 = {};
__export(exports_exports14, {
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  Root: () => date_range_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-range-field/date-range-field.svelte.js
var dateRangeFieldAttrs = createBitsAttrs({
  component: "date-range-field",
  parts: ["root", "label"]
});
var DateRangeFieldRootContext = new Context("DateRangeField.Root");
var _fieldNode2, _labelNode4, _descriptionNode3, _startValueComplete, _endValueComplete, _rangeComplete, _validationStatus2, _isInvalid3, _DateRangeFieldRootState_instances, updateValue_fn, _props90;
var _DateRangeFieldRootState = class _DateRangeFieldRootState {
  constructor(opts) {
    __privateAdd(this, _DateRangeFieldRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "startFieldState");
    __publicField(this, "endFieldState");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __privateAdd(this, _fieldNode2, tag(state(null), "DateRangeFieldRootState.fieldNode"));
    __privateAdd(this, _labelNode4, tag(state(null), "DateRangeFieldRootState.labelNode"));
    __privateAdd(this, _descriptionNode3, tag(state(null), "DateRangeFieldRootState.descriptionNode"));
    __privateAdd(this, _startValueComplete, tag(user_derived(() => strict_equals(this.opts.startValue.current, void 0, false)), "DateRangeFieldRootState.startValueComplete"));
    __privateAdd(this, _endValueComplete, tag(user_derived(() => strict_equals(this.opts.endValue.current, void 0, false)), "DateRangeFieldRootState.endValueComplete"));
    __privateAdd(this, _rangeComplete, tag(user_derived(() => this.startValueComplete && this.endValueComplete), "DateRangeFieldRootState.rangeComplete"));
    __publicField(this, "domContext");
    __publicField(this, "attachment");
    __privateAdd(this, _validationStatus2, tag(
      user_derived(() => {
        var _a, _b;
        const value = this.opts.value.current;
        if (strict_equals(value, void 0)) return false;
        if (strict_equals(value.start, void 0) || strict_equals(value.end, void 0)) return false;
        const msg = (_b = (_a = this.opts.validate).current) == null ? void 0 : _b.call(_a, { start: value.start, end: value.end });
        if (msg) {
          return { reason: "custom", message: msg };
        }
        const minValue = this.opts.minValue.current;
        if (minValue && value.start && isBefore(value.start, minValue)) {
          return { reason: "min" };
        }
        const maxValue = this.opts.maxValue.current;
        if (maxValue && value.end && isBefore(maxValue, value.end) || maxValue && value.start && isBefore(maxValue, value.start)) {
          return { reason: "max" };
        }
        return false;
      }),
      "DateRangeFieldRootState.validationStatus"
    ));
    __privateAdd(this, _isInvalid3, tag(
      user_derived(() => {
        if (strict_equals(this.validationStatus, false)) return false;
        return true;
      }),
      "DateRangeFieldRootState.isInvalid"
    ));
    __privateAdd(this, _props90, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        [dateRangeFieldAttrs.root]: "",
        "data-invalid": getDataInvalid(this.isInvalid),
        ...this.attachment
      })),
      "DateRangeFieldRootState.props"
    ));
    this.opts = opts;
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: box.with(() => "long"),
      yearFormat: box.with(() => "numeric")
    });
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _DateRangeFieldRootState_instances, updateValue_fn).call(this, (prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  static create(opts) {
    return DateRangeFieldRootContext.set(new _DateRangeFieldRootState(opts));
  }
  get fieldNode() {
    return get(__privateGet(this, _fieldNode2));
  }
  set fieldNode(value) {
    set(__privateGet(this, _fieldNode2), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode4));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode4), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode3));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode3), value, true);
  }
  get startValueComplete() {
    return get(__privateGet(this, _startValueComplete));
  }
  set startValueComplete(value) {
    set(__privateGet(this, _startValueComplete), value);
  }
  get endValueComplete() {
    return get(__privateGet(this, _endValueComplete));
  }
  set endValueComplete(value) {
    set(__privateGet(this, _endValueComplete), value);
  }
  get rangeComplete() {
    return get(__privateGet(this, _rangeComplete));
  }
  set rangeComplete(value) {
    set(__privateGet(this, _rangeComplete), value);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus2));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus2), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid3));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid3), value);
  }
  get props() {
    return get(__privateGet(this, _props90));
  }
  set props(value) {
    set(__privateGet(this, _props90), value);
  }
};
_fieldNode2 = new WeakMap();
_labelNode4 = new WeakMap();
_descriptionNode3 = new WeakMap();
_startValueComplete = new WeakMap();
_endValueComplete = new WeakMap();
_rangeComplete = new WeakMap();
_validationStatus2 = new WeakMap();
_isInvalid3 = new WeakMap();
_DateRangeFieldRootState_instances = new WeakSet();
updateValue_fn = function(cb) {
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
};
_props90 = new WeakMap();
var DateRangeFieldRootState = _DateRangeFieldRootState;
var _onclick, _props91;
var _DateRangeFieldLabelState = class _DateRangeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _onclick, () => {
      if (this.root.opts.disabled.current) return;
      const firstSegment = getFirstSegment(this.root.fieldNode);
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props91, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-invalid": getDataInvalid(this.root.isInvalid),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        [dateRangeFieldAttrs.label]: "",
        onclick: __privateGet(this, _onclick),
        ...this.attachment
      })),
      "DateRangeFieldLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _DateRangeFieldLabelState(opts, DateRangeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props91));
  }
  set props(value) {
    set(__privateGet(this, _props91), value);
  }
};
_onclick = new WeakMap();
_props91 = new WeakMap();
var DateRangeFieldLabelState = _DateRangeFieldLabelState;
var DateRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = DateRangeFieldRootContext.get();
    const fieldState = DateFieldRootState.create(
      {
        value: strict_equals(type, "start") ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: box.with(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: box.with(() => root18.isInvalid)
      },
      root18
    );
    return new DateFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte
Date_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte";
var root_260 = add_locations(from_html(`<div><!></div>`), Date_range_field[FILENAME], [[137, 1]]);
function Date_range_field($$anchor, $$props) {
  var _a, _b;
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "disabled",
      "readonly",
      "required",
      "hourCycle",
      "granularity",
      "locale",
      "hideTimeZone",
      "validate",
      "onInvalid",
      "maxValue",
      "minValue",
      "readonlySegments",
      "children",
      "child",
      "onStartValueChange",
      "onEndValueChange",
      "errorMessageId"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy((_a = value()) == null ? void 0 : _a.start)), "startValue");
  let endValue = tag(state(proxy((_b = value()) == null ? void 0 : _b.end)), "endValue");
  function handleDefaultPlaceholder() {
    var _a2;
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultValue: (_a2 = value()) == null ? void 0 : _a2.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = DateRangeFieldRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    required: box.with(() => required()),
    hourCycle: box.with(() => $$props.hourCycle),
    granularity: box.with(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    validate: box.with(() => validate()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: box.with(() => readonlySegments()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_260();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field = hmr(Date_range_field, () => Date_range_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field[HMR].source;
    set(Date_range_field[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_default = Date_range_field;

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte
Date_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte";
var root_261 = add_locations(from_html(`<div><!></div>`), Date_range_field_input[FILENAME], [[38, 1]]);
var root8 = add_locations(from_html(`<!> <!>`, 1), Date_range_field_input[FILENAME], []);
function Date_range_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const inputState = DateRangeFieldInputState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      name: box.with(() => name())
    },
    $$props.type
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" })), "mergedProps");
  var fragment = root8();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_261();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  date_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_input = hmr(Date_range_field_input, () => Date_range_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_input[HMR].source;
    set(Date_range_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_input_default = Date_range_field_input;

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte
Date_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte";
var root_262 = add_locations(from_html(`<span><!></span>`), Date_range_field_label[FILENAME], [[31, 1]]);
function Date_range_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = DateRangeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_262();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_label = hmr(Date_range_field_label, () => Date_range_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_label[HMR].source;
    set(Date_range_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_label_default = Date_range_field_label;

// node_modules/bits-ui/dist/bits/date-range-picker/exports.js
var exports_exports15 = {};
__export(exports_exports15, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_range_picker_calendar_default,
  Cell: () => range_calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_range_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_range_picker_trigger_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/date-range-picker/date-range-picker.svelte.js
var DateRangePickerRootContext = new Context("DateRangePicker.Root");
var DateRangePickerRootState = class _DateRangePickerRootState {
  constructor(opts) {
    __publicField(this, "opts");
    this.opts = opts;
  }
  static create(opts) {
    return DateRangePickerRootContext.set(new _DateRangePickerRootState(opts));
  }
};

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte
Date_range_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte";
var root_314 = add_locations(from_html(`<div><!></div>`), Date_range_picker[FILENAME], [[218, 2]]);
function Date_range_picker($$anchor, $$props) {
  var _a, _b, _c;
  check_target(new.target);
  push($$props, true, Date_range_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnRangeSelect = prop($$props, "closeOnRangeSelect", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "open",
      "onOpenChange",
      "onOpenChangeComplete",
      "value",
      "id",
      "ref",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "isDateUnavailable",
      "onInvalid",
      "minValue",
      "maxValue",
      "disabled",
      "readonly",
      "granularity",
      "readonlySegments",
      "hourCycle",
      "locale",
      "hideTimeZone",
      "required",
      "calendarLabel",
      "disableDaysOutsideMonth",
      "preventDeselect",
      "pagedNavigation",
      "weekStartsOn",
      "weekdayFormat",
      "isDateDisabled",
      "fixedWeeks",
      "numberOfMonths",
      "closeOnRangeSelect",
      "onStartValueChange",
      "onEndValueChange",
      "validate",
      "errorMessageId",
      "minDays",
      "maxDays",
      "excludeDisabled",
      "child",
      "children",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy((_a = value()) == null ? void 0 : _a.start)), "startValue");
  let endValue = tag(state(proxy((_b = value()) == null ? void 0 : _b.end)), "endValue");
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const defaultPlaceholder = getDefaultDate({
    granularity: $$props.granularity,
    defaultValue: (_c = value()) == null ? void 0 : _c.start
  });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onRangeSelect() {
    if (closeOnRangeSelect()) {
      open(false);
    }
  }
  const pickerRootState = DateRangePickerRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    minDays: box.with(() => $$props.minDays),
    maxDays: box.with(() => $$props.maxDays),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    excludeDisabled: box.with(() => excludeDisabled()),
    onRangeSelect: box.with(() => onRangeSelect),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  const fieldRootState = DateRangeFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: box.with(() => validate()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    startValue: pickerRootState.opts.startValue,
    endValue: pickerRootState.opts.endValue,
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, fieldRootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Date_range_picker, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_314();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker = hmr(Date_range_picker, () => Date_range_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker[HMR].source;
    set(Date_range_picker[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_default = Date_range_picker;

// node_modules/bits-ui/dist/bits/range-calendar/range-calendar.svelte.js
var RangeCalendarCellContext = new Context("RangeCalendar.Cell");
var _visibleMonths2, _months2, _focusedValue, _weekdays2, _isStartInvalid, _isEndInvalid, _isInvalid4, _isNextButtonDisabled2, _isPrevButtonDisabled2, _headingValue2, _fullCalendarLabel2, _highlightedRange, _initialPlaceholderYear2, _defaultYears2, _RangeCalendarRootState_instances, updateValue_fn2, setStartValue_fn, setEndValue_fn, isRangeValid_fn, announceEmpty_fn, announceSelectedDate_fn, announceSelectedRange_fn, _snippetProps16, _props92, hasDisabledDatesInRange_fn;
var _RangeCalendarRootState = class _RangeCalendarRootState {
  constructor(opts) {
    __privateAdd(this, _RangeCalendarRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _visibleMonths2, tag(user_derived(() => this.months.map((month) => month.value)), "RangeCalendarRootState.visibleMonths"));
    __privateAdd(this, _months2, tag(state(proxy([])), "RangeCalendarRootState.months"));
    __publicField(this, "announcer");
    __publicField(this, "formatter");
    __publicField(this, "accessibleHeadingId", useId());
    __privateAdd(this, _focusedValue, tag(state(void 0), "RangeCalendarRootState.focusedValue"));
    __publicField(this, "lastPressedDateValue");
    __publicField(this, "domContext");
    __privateAdd(this, _weekdays2, tag(
      user_derived(() => {
        return getWeekdays({
          months: this.months,
          formatter: this.formatter,
          weekdayFormat: this.opts.weekdayFormat.current
        });
      }),
      "RangeCalendarRootState.weekdays"
    ));
    __privateAdd(this, _isStartInvalid, tag(
      user_derived(() => {
        if (!this.opts.startValue.current) return false;
        return this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current);
      }),
      "RangeCalendarRootState.isStartInvalid"
    ));
    __privateAdd(this, _isEndInvalid, tag(
      user_derived(() => {
        if (!this.opts.endValue.current) return false;
        return this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current);
      }),
      "RangeCalendarRootState.isEndInvalid"
    ));
    __privateAdd(this, _isInvalid4, tag(
      user_derived(() => {
        if (this.isStartInvalid || this.isEndInvalid) return true;
        if (this.opts.endValue.current && this.opts.startValue.current && isBefore(this.opts.endValue.current, this.opts.startValue.current)) return true;
        return false;
      }),
      "RangeCalendarRootState.isInvalid"
    ));
    __privateAdd(this, _isNextButtonDisabled2, tag(
      user_derived(() => {
        return getIsNextButtonDisabled({
          maxValue: this.opts.maxValue.current,
          months: this.months,
          disabled: this.opts.disabled.current
        });
      }),
      "RangeCalendarRootState.isNextButtonDisabled"
    ));
    __privateAdd(this, _isPrevButtonDisabled2, tag(
      user_derived(() => {
        return getIsPrevButtonDisabled({
          minValue: this.opts.minValue.current,
          months: this.months,
          disabled: this.opts.disabled.current
        });
      }),
      "RangeCalendarRootState.isPrevButtonDisabled"
    ));
    __privateAdd(this, _headingValue2, tag(
      user_derived(() => {
        this.opts.monthFormat.current;
        this.opts.yearFormat.current;
        return getCalendarHeadingValue({
          months: this.months,
          formatter: this.formatter,
          locale: this.opts.locale.current
        });
      }),
      "RangeCalendarRootState.headingValue"
    ));
    __privateAdd(this, _fullCalendarLabel2, tag(user_derived(() => `${this.opts.calendarLabel.current} ${this.headingValue}`), "RangeCalendarRootState.fullCalendarLabel"));
    __privateAdd(this, _highlightedRange, tag(
      user_derived(() => {
        if (this.opts.startValue.current && this.opts.endValue.current) return null;
        if (!this.opts.startValue.current || !this.focusedValue) return null;
        const isStartBeforeFocused = isBefore(this.opts.startValue.current, this.focusedValue);
        const start = isStartBeforeFocused ? this.opts.startValue.current : this.focusedValue;
        const end = isStartBeforeFocused ? this.focusedValue : this.opts.startValue.current;
        const range = { start, end };
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
          return range;
        }
        const isValid = areAllDaysBetweenValid(start, end, this.isDateUnavailable, this.isDateDisabled);
        if (isValid) return range;
        return null;
      }),
      "RangeCalendarRootState.highlightedRange"
    ));
    __privateAdd(this, _initialPlaceholderYear2, tag(user_derived(() => untrack(() => this.opts.placeholder.current.year)), "RangeCalendarRootState.initialPlaceholderYear"));
    __privateAdd(this, _defaultYears2, tag(
      user_derived(() => {
        return getDefaultYears({
          minValue: this.opts.minValue.current,
          maxValue: this.opts.maxValue.current,
          placeholderYear: this.initialPlaceholderYear
        });
      }),
      "RangeCalendarRootState.defaultYears"
    ));
    __publicField(this, "setMonths", (months) => {
      this.months = months;
    });
    __publicField(this, "getBitsAttr", (part) => {
      return calendarAttrs.getAttr(part, "range-calendar");
    });
    __privateAdd(this, _snippetProps16, tag(user_derived(() => ({ months: this.months, weekdays: this.weekdays })), "RangeCalendarRootState.snippetProps"));
    __privateAdd(this, _props92, tag(
      user_derived(() => ({
        ...getCalendarElementProps({
          fullCalendarLabel: this.fullCalendarLabel,
          id: this.opts.id.current,
          isInvalid: this.isInvalid,
          disabled: this.opts.disabled.current,
          readonly: this.opts.readonly.current
        }),
        [this.getBitsAttr("root")]: "",
        //
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "RangeCalendarRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    user_pre_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    user_effect(() => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = this.fullCalendarLabel;
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([startValue, endValue, excludeDisabled]) => {
        if (!excludeDisabled || !startValue || !endValue) return;
        if (__privateMethod(this, _RangeCalendarRootState_instances, hasDisabledDatesInRange_fn).call(this, startValue, endValue)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
          __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
        }
      }
    );
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            if (isBefore(endValue, startValue)) {
              const start = startValue;
              const end = endValue;
              __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, end);
              __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, start);
              if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, endValue, startValue)) {
                __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, startValue);
                __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
                return { start: startValue, end: void 0 };
              }
              return { start: endValue, end: startValue };
            } else {
              if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, startValue, endValue)) {
                __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, endValue);
                __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
                return { start: endValue, end: void 0 };
              }
              return { start: startValue, end: endValue };
            }
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateUnavailable = this.isDateUnavailable.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isSelected = this.isSelected.bind(this);
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  static create(opts) {
    return CalendarRootContext.set(new _RangeCalendarRootState(opts));
  }
  get visibleMonths() {
    return get(__privateGet(this, _visibleMonths2));
  }
  set visibleMonths(value) {
    set(__privateGet(this, _visibleMonths2), value);
  }
  get months() {
    return get(__privateGet(this, _months2));
  }
  set months(value) {
    set(__privateGet(this, _months2), value, true);
  }
  get focusedValue() {
    return get(__privateGet(this, _focusedValue));
  }
  set focusedValue(value) {
    set(__privateGet(this, _focusedValue), value, true);
  }
  get weekdays() {
    return get(__privateGet(this, _weekdays2));
  }
  set weekdays(value) {
    set(__privateGet(this, _weekdays2), value);
  }
  get isStartInvalid() {
    return get(__privateGet(this, _isStartInvalid));
  }
  set isStartInvalid(value) {
    set(__privateGet(this, _isStartInvalid), value);
  }
  get isEndInvalid() {
    return get(__privateGet(this, _isEndInvalid));
  }
  set isEndInvalid(value) {
    set(__privateGet(this, _isEndInvalid), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid4));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid4), value);
  }
  get isNextButtonDisabled() {
    return get(__privateGet(this, _isNextButtonDisabled2));
  }
  set isNextButtonDisabled(value) {
    set(__privateGet(this, _isNextButtonDisabled2), value);
  }
  get isPrevButtonDisabled() {
    return get(__privateGet(this, _isPrevButtonDisabled2));
  }
  set isPrevButtonDisabled(value) {
    set(__privateGet(this, _isPrevButtonDisabled2), value);
  }
  get headingValue() {
    return get(__privateGet(this, _headingValue2));
  }
  set headingValue(value) {
    set(__privateGet(this, _headingValue2), value);
  }
  get fullCalendarLabel() {
    return get(__privateGet(this, _fullCalendarLabel2));
  }
  set fullCalendarLabel(value) {
    set(__privateGet(this, _fullCalendarLabel2), value);
  }
  get highlightedRange() {
    return get(__privateGet(this, _highlightedRange));
  }
  set highlightedRange(value) {
    set(__privateGet(this, _highlightedRange), value);
  }
  get initialPlaceholderYear() {
    return get(__privateGet(this, _initialPlaceholderYear2));
  }
  set initialPlaceholderYear(value) {
    set(__privateGet(this, _initialPlaceholderYear2), value);
  }
  get defaultYears() {
    return get(__privateGet(this, _defaultYears2));
  }
  set defaultYears(value) {
    set(__privateGet(this, _defaultYears2), value);
  }
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isAfter(date, maxValue)) return true;
    return false;
  }
  isDateUnavailable(date) {
    if (this.opts.isDateUnavailable.current(date)) return true;
    return false;
  }
  isSelectionStart(date) {
    if (!this.opts.startValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.startValue.current);
  }
  isSelectionEnd(date) {
    if (!this.opts.endValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.endValue.current);
  }
  isSelected(date) {
    if (this.opts.startValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date)) return true;
    if (this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date)) return true;
    if (this.opts.startValue.current && this.opts.endValue.current) {
      return isBetweenInclusive(date, this.opts.startValue.current, this.opts.endValue.current);
    }
    return false;
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  handleCellClick(e, date) {
    if (this.isDateDisabled(date) || this.isDateUnavailable(date)) return;
    const prevLastPressedDate = this.lastPressedDateValue;
    this.lastPressedDateValue = date;
    if (this.opts.startValue.current && strict_equals(this.highlightedRange, null)) {
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
        this.opts.placeholder.current = date;
        __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
        return;
      } else if (!this.opts.endValue.current) {
        e.preventDefault();
        if (prevLastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevLastPressedDate, date)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
        }
      }
    }
    if (this.opts.startValue.current && this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date) && !this.opts.preventDeselect.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, void 0);
      __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
      this.opts.placeholder.current = date;
      __privateMethod(this, _RangeCalendarRootState_instances, announceEmpty_fn).call(this);
      return;
    }
    if (!this.opts.startValue.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
    } else if (!this.opts.endValue.current) {
      const startDate = this.opts.startValue.current;
      const endDate = date;
      const orderedStart = isBefore(endDate, startDate) ? endDate : startDate;
      const orderedEnd = isBefore(endDate, startDate) ? startDate : endDate;
      if (!__privateMethod(this, _RangeCalendarRootState_instances, isRangeValid_fn).call(this, orderedStart, orderedEnd)) {
        __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
        __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
        __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      } else {
        if (isBefore(endDate, startDate)) {
          __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, endDate);
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, startDate);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedRange_fn).call(this, endDate, startDate);
        } else {
          __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, date);
          __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedRange_fn).call(this, this.opts.startValue.current, date);
        }
      }
    } else if (this.opts.endValue.current && this.opts.startValue.current) {
      __privateMethod(this, _RangeCalendarRootState_instances, setEndValue_fn).call(this, void 0);
      __privateMethod(this, _RangeCalendarRootState_instances, announceSelectedDate_fn).call(this, date);
      __privateMethod(this, _RangeCalendarRootState_instances, setStartValue_fn).call(this, date);
    }
  }
  onkeydown(event) {
    return handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps16));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps16), value);
  }
  get props() {
    return get(__privateGet(this, _props92));
  }
  set props(value) {
    set(__privateGet(this, _props92), value);
  }
};
_visibleMonths2 = new WeakMap();
_months2 = new WeakMap();
_focusedValue = new WeakMap();
_weekdays2 = new WeakMap();
_isStartInvalid = new WeakMap();
_isEndInvalid = new WeakMap();
_isInvalid4 = new WeakMap();
_isNextButtonDisabled2 = new WeakMap();
_isPrevButtonDisabled2 = new WeakMap();
_headingValue2 = new WeakMap();
_fullCalendarLabel2 = new WeakMap();
_highlightedRange = new WeakMap();
_initialPlaceholderYear2 = new WeakMap();
_defaultYears2 = new WeakMap();
_RangeCalendarRootState_instances = new WeakSet();
updateValue_fn2 = function(cb) {
  var _a, _b;
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
  if (newValue.start && newValue.end) {
    (_b = (_a = this.opts.onRangeSelect) == null ? void 0 : _a.current) == null ? void 0 : _b.call(_a);
  }
};
setStartValue_fn = function(value) {
  this.opts.startValue.current = value;
  __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => ({ ...prev2, start: value }));
};
setEndValue_fn = function(value) {
  this.opts.endValue.current = value;
  __privateMethod(this, _RangeCalendarRootState_instances, updateValue_fn2).call(this, (prev2) => ({ ...prev2, end: value }));
};
isRangeValid_fn = function(start, end) {
  const orderedStart = isBefore(end, start) ? end : start;
  const orderedEnd = isBefore(end, start) ? start : end;
  const startDate = orderedStart.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
  const endDate = orderedEnd.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
  const timeDifference = endDate.getTime() - startDate.getTime();
  const daysDifference = Math.floor(timeDifference / (1e3 * 60 * 60 * 24));
  const daysInRange = daysDifference + 1;
  if (this.opts.minDays.current && daysInRange < this.opts.minDays.current) return false;
  if (this.opts.maxDays.current && daysInRange > this.opts.maxDays.current) return false;
  if (this.opts.excludeDisabled.current && __privateMethod(this, _RangeCalendarRootState_instances, hasDisabledDatesInRange_fn).call(this, orderedStart, orderedEnd)) {
    return false;
  }
  return true;
};
announceEmpty_fn = function() {
  this.announcer.announce("Selected date is now empty.", "polite");
};
announceSelectedDate_fn = function(date) {
  this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(date, false)}`, "polite");
};
announceSelectedRange_fn = function(start, end) {
  this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(start, false)} to ${this.formatter.selectedDate(end, false)}`, "polite");
};
_snippetProps16 = new WeakMap();
_props92 = new WeakMap();
hasDisabledDatesInRange_fn = function(start, end) {
  for (let date = start; isBefore(date, end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, end); date = date.add({ days: 1 })) {
    if (this.isDateDisabled(date)) return true;
  }
  return false;
};
var RangeCalendarRootState = _RangeCalendarRootState;
var _cellDate2, _isOutsideMonth2, _isDisabled9, _isUnavailable2, _isDateToday2, _isOutsideVisibleMonths2, _isFocusedDate2, _isSelectedDate2, _isSelectionStart, _isRangeStart, _isRangeEnd, _isRangeMiddle, _isSelectionMiddle, _isSelectionEnd, _isHighlighted2, _labelText2, _snippetProps17, _ariaDisabled2, _sharedDataAttrs2, _props93;
var _RangeCalendarCellState = class _RangeCalendarCellState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _cellDate2, tag(user_derived(() => toDate(this.opts.date.current)), "RangeCalendarCellState.cellDate"));
    __privateAdd(this, _isOutsideMonth2, tag(user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)), "RangeCalendarCellState.isOutsideMonth"));
    __privateAdd(this, _isDisabled9, tag(user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current), "RangeCalendarCellState.isDisabled"));
    __privateAdd(this, _isUnavailable2, tag(user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)), "RangeCalendarCellState.isUnavailable"));
    __privateAdd(this, _isDateToday2, tag(user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), "RangeCalendarCellState.isDateToday"));
    __privateAdd(this, _isOutsideVisibleMonths2, tag(user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)), "RangeCalendarCellState.isOutsideVisibleMonths"));
    __privateAdd(this, _isFocusedDate2, tag(user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)), "RangeCalendarCellState.isFocusedDate"));
    __privateAdd(this, _isSelectedDate2, tag(user_derived(() => this.root.isSelected(this.opts.date.current)), "RangeCalendarCellState.isSelectedDate"));
    __privateAdd(this, _isSelectionStart, tag(user_derived(() => this.root.isSelectionStart(this.opts.date.current)), "RangeCalendarCellState.isSelectionStart"));
    __privateAdd(this, _isRangeStart, tag(user_derived(() => this.root.isSelectionStart(this.opts.date.current)), "RangeCalendarCellState.isRangeStart"));
    __privateAdd(this, _isRangeEnd, tag(
      user_derived(() => {
        if (!this.root.opts.endValue.current) return this.root.isSelectionStart(this.opts.date.current);
        return this.root.isSelectionEnd(this.opts.date.current);
      }),
      "RangeCalendarCellState.isRangeEnd"
    ));
    __privateAdd(this, _isRangeMiddle, tag(user_derived(() => this.isSelectionMiddle), "RangeCalendarCellState.isRangeMiddle"));
    __privateAdd(this, _isSelectionMiddle, tag(
      user_derived(() => {
        return this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd;
      }),
      "RangeCalendarCellState.isSelectionMiddle"
    ));
    __privateAdd(this, _isSelectionEnd, tag(user_derived(() => this.root.isSelectionEnd(this.opts.date.current)), "RangeCalendarCellState.isSelectionEnd"));
    __privateAdd(this, _isHighlighted2, tag(user_derived(() => this.root.highlightedRange ? isBetweenInclusive(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : false), "RangeCalendarCellState.isHighlighted"));
    __privateAdd(this, _labelText2, tag(
      user_derived(() => this.root.formatter.custom(this.cellDate, {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      })),
      "RangeCalendarCellState.labelText"
    ));
    __privateAdd(this, _snippetProps17, tag(
      user_derived(() => ({
        disabled: this.isDisabled,
        unavailable: this.isUnavailable,
        selected: this.isSelectedDate
      })),
      "RangeCalendarCellState.snippetProps"
    ));
    __privateAdd(this, _ariaDisabled2, tag(
      user_derived(() => {
        return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
      }),
      "RangeCalendarCellState.ariaDisabled"
    ));
    __privateAdd(this, _sharedDataAttrs2, tag(
      user_derived(() => ({
        "data-unavailable": getDataUnavailable(this.isUnavailable),
        "data-today": this.isDateToday ? "" : void 0,
        "data-outside-month": this.isOutsideMonth ? "" : void 0,
        "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
        "data-focused": this.isFocusedDate ? "" : void 0,
        "data-selection-start": this.isSelectionStart ? "" : void 0,
        "data-selection-end": this.isSelectionEnd ? "" : void 0,
        "data-range-start": this.isRangeStart ? "" : void 0,
        "data-range-end": this.isRangeEnd ? "" : void 0,
        "data-range-middle": this.isRangeMiddle ? "" : void 0,
        "data-highlighted": this.isHighlighted ? "" : void 0,
        "data-selected": getDataSelected(this.isSelectedDate),
        "data-value": this.opts.date.current.toString(),
        "data-type": getDateValueType(this.opts.date.current),
        "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
      })),
      "RangeCalendarCellState.sharedDataAttrs"
    ));
    __privateAdd(this, _props93, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "gridcell",
        "aria-selected": getAriaSelected(this.isSelectedDate),
        "aria-disabled": getAriaDisabled(this.ariaDisabled),
        ...this.sharedDataAttrs,
        [this.root.getBitsAttr("cell")]: "",
        ...this.attachment
      })),
      "RangeCalendarCellState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return RangeCalendarCellContext.set(new _RangeCalendarCellState(opts, CalendarRootContext.get()));
  }
  get cellDate() {
    return get(__privateGet(this, _cellDate2));
  }
  set cellDate(value) {
    set(__privateGet(this, _cellDate2), value);
  }
  get isOutsideMonth() {
    return get(__privateGet(this, _isOutsideMonth2));
  }
  set isOutsideMonth(value) {
    set(__privateGet(this, _isOutsideMonth2), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled9));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled9), value);
  }
  get isUnavailable() {
    return get(__privateGet(this, _isUnavailable2));
  }
  set isUnavailable(value) {
    set(__privateGet(this, _isUnavailable2), value);
  }
  get isDateToday() {
    return get(__privateGet(this, _isDateToday2));
  }
  set isDateToday(value) {
    set(__privateGet(this, _isDateToday2), value);
  }
  get isOutsideVisibleMonths() {
    return get(__privateGet(this, _isOutsideVisibleMonths2));
  }
  set isOutsideVisibleMonths(value) {
    set(__privateGet(this, _isOutsideVisibleMonths2), value);
  }
  get isFocusedDate() {
    return get(__privateGet(this, _isFocusedDate2));
  }
  set isFocusedDate(value) {
    set(__privateGet(this, _isFocusedDate2), value);
  }
  get isSelectedDate() {
    return get(__privateGet(this, _isSelectedDate2));
  }
  set isSelectedDate(value) {
    set(__privateGet(this, _isSelectedDate2), value);
  }
  get isSelectionStart() {
    return get(__privateGet(this, _isSelectionStart));
  }
  set isSelectionStart(value) {
    set(__privateGet(this, _isSelectionStart), value);
  }
  get isRangeStart() {
    return get(__privateGet(this, _isRangeStart));
  }
  set isRangeStart(value) {
    set(__privateGet(this, _isRangeStart), value);
  }
  get isRangeEnd() {
    return get(__privateGet(this, _isRangeEnd));
  }
  set isRangeEnd(value) {
    set(__privateGet(this, _isRangeEnd), value);
  }
  get isRangeMiddle() {
    return get(__privateGet(this, _isRangeMiddle));
  }
  set isRangeMiddle(value) {
    set(__privateGet(this, _isRangeMiddle), value);
  }
  get isSelectionMiddle() {
    return get(__privateGet(this, _isSelectionMiddle));
  }
  set isSelectionMiddle(value) {
    set(__privateGet(this, _isSelectionMiddle), value);
  }
  get isSelectionEnd() {
    return get(__privateGet(this, _isSelectionEnd));
  }
  set isSelectionEnd(value) {
    set(__privateGet(this, _isSelectionEnd), value);
  }
  get isHighlighted() {
    return get(__privateGet(this, _isHighlighted2));
  }
  set isHighlighted(value) {
    set(__privateGet(this, _isHighlighted2), value);
  }
  get labelText() {
    return get(__privateGet(this, _labelText2));
  }
  set labelText(value) {
    set(__privateGet(this, _labelText2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps17));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps17), value);
  }
  get ariaDisabled() {
    return get(__privateGet(this, _ariaDisabled2));
  }
  set ariaDisabled(value) {
    set(__privateGet(this, _ariaDisabled2), value);
  }
  get sharedDataAttrs() {
    return get(__privateGet(this, _sharedDataAttrs2));
  }
  set sharedDataAttrs(value) {
    set(__privateGet(this, _sharedDataAttrs2), value);
  }
  get props() {
    return get(__privateGet(this, _props93));
  }
  set props(value) {
    set(__privateGet(this, _props93), value);
  }
};
_cellDate2 = new WeakMap();
_isOutsideMonth2 = new WeakMap();
_isDisabled9 = new WeakMap();
_isUnavailable2 = new WeakMap();
_isDateToday2 = new WeakMap();
_isOutsideVisibleMonths2 = new WeakMap();
_isFocusedDate2 = new WeakMap();
_isSelectedDate2 = new WeakMap();
_isSelectionStart = new WeakMap();
_isRangeStart = new WeakMap();
_isRangeEnd = new WeakMap();
_isRangeMiddle = new WeakMap();
_isSelectionMiddle = new WeakMap();
_isSelectionEnd = new WeakMap();
_isHighlighted2 = new WeakMap();
_labelText2 = new WeakMap();
_snippetProps17 = new WeakMap();
_ariaDisabled2 = new WeakMap();
_sharedDataAttrs2 = new WeakMap();
_props93 = new WeakMap();
var RangeCalendarCellState = _RangeCalendarCellState;
var _tabindex2, _snippetProps18, _props94;
var _RangeCalendarDayState = class _RangeCalendarDayState {
  constructor(opts, cell) {
    __publicField(this, "opts");
    __publicField(this, "cell");
    __publicField(this, "attachment");
    __privateAdd(this, _tabindex2, tag(user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1), "RangeCalendarDayState.#tabindex"));
    __privateAdd(this, _snippetProps18, tag(
      user_derived(() => ({
        disabled: this.cell.isDisabled,
        unavailable: this.cell.isUnavailable,
        selected: this.cell.isSelectedDate,
        day: `${this.cell.opts.date.current.day}`
      })),
      "RangeCalendarDayState.snippetProps"
    ));
    __privateAdd(this, _props94, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "button",
        "aria-label": this.cell.labelText,
        "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
        ...this.cell.sharedDataAttrs,
        tabindex: get(__privateGet(this, _tabindex2)),
        [this.cell.root.getBitsAttr("day")]: "",
        // Shared logic for range calendar and calendar
        "data-bits-day": "",
        //
        onclick: this.onclick,
        onmouseenter: this.onmouseenter,
        onfocusin: this.onfocusin,
        ...this.attachment
      })),
      "RangeCalendarDayState.props"
    ));
    this.opts = opts;
    this.cell = cell;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onmouseenter = this.onmouseenter.bind(this);
    this.onfocusin = this.onfocusin.bind(this);
  }
  static create(opts) {
    return new _RangeCalendarDayState(opts, RangeCalendarCellContext.get());
  }
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  onfocusin(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps18));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps18), value);
  }
  get props() {
    return get(__privateGet(this, _props94));
  }
  set props(value) {
    set(__privateGet(this, _props94), value);
  }
};
_tabindex2 = new WeakMap();
_snippetProps18 = new WeakMap();
_props94 = new WeakMap();
var RangeCalendarDayState = _RangeCalendarDayState;

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte
Date_range_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte";
var root_263 = add_locations(from_html(`<div><!></div>`), Date_range_picker_calendar[FILENAME], [[60, 1]]);
function Date_range_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_picker_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dateRangePickerRootState = DateRangePickerRootContext.get();
  const rangeCalendarState = RangeCalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: dateRangePickerRootState.opts.calendarLabel,
    fixedWeeks: dateRangePickerRootState.opts.fixedWeeks,
    isDateDisabled: dateRangePickerRootState.opts.isDateDisabled,
    isDateUnavailable: dateRangePickerRootState.opts.isDateUnavailable,
    locale: dateRangePickerRootState.opts.locale,
    numberOfMonths: dateRangePickerRootState.opts.numberOfMonths,
    pagedNavigation: dateRangePickerRootState.opts.pagedNavigation,
    preventDeselect: dateRangePickerRootState.opts.preventDeselect,
    readonly: dateRangePickerRootState.opts.readonly,
    weekStartsOn: dateRangePickerRootState.opts.weekStartsOn,
    weekdayFormat: dateRangePickerRootState.opts.weekdayFormat,
    disabled: dateRangePickerRootState.opts.disabled,
    disableDaysOutsideMonth: dateRangePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: dateRangePickerRootState.opts.maxValue,
    minValue: dateRangePickerRootState.opts.minValue,
    placeholder: dateRangePickerRootState.opts.placeholder,
    value: dateRangePickerRootState.opts.value,
    excludeDisabled: dateRangePickerRootState.opts.excludeDisabled,
    onRangeSelect: dateRangePickerRootState.opts.onRangeSelect,
    startValue: dateRangePickerRootState.opts.startValue,
    endValue: dateRangePickerRootState.opts.endValue,
    defaultPlaceholder: dateRangePickerRootState.opts.defaultPlaceholder,
    minDays: dateRangePickerRootState.opts.minDays,
    maxDays: dateRangePickerRootState.opts.maxDays,
    monthFormat: dateRangePickerRootState.opts.monthFormat,
    yearFormat: dateRangePickerRootState.opts.yearFormat
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rangeCalendarState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rangeCalendarState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_263();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rangeCalendarState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_calendar = hmr(Date_range_picker_calendar, () => Date_range_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_calendar[HMR].source;
    set(Date_range_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_calendar_default = Date_range_picker_calendar;

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte
Date_range_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte";
function Date_range_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_picker_trigger);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "onkeydown"
    ],
    "restProps"
  );
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateRangeFieldAttrs.selector("root"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = tag(user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_trigger_default, ref);
    popover_trigger_default(node, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_trigger = hmr(Date_range_picker_trigger, () => Date_range_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_trigger[HMR].source;
    set(Date_range_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_trigger_default = Date_range_picker_trigger;

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte
Range_calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte";
var root_264 = add_locations(from_html(`<td><!></td>`), Range_calendar_cell[FILENAME], [[35, 1]]);
function Range_calendar_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar_cell);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = RangeCalendarCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...cellState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_264();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps);
      reset(td);
      append($$anchor2, td);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_cell = hmr(Range_calendar_cell, () => Range_calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_cell[HMR].source;
    set(Range_calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_cell_default = Range_calendar_cell;

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte
Range_calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte";
var root_265 = add_locations(from_html(`<div><!></div>`), Range_calendar_day[FILENAME], [[31, 1]]);
function Range_calendar_day($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar_day);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dayState = RangeCalendarDayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, dayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...dayState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_265();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_day = hmr(Range_calendar_day, () => Range_calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_day[HMR].source;
    set(Range_calendar_day[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_day_default = Range_calendar_day;

// node_modules/bits-ui/dist/bits/dialog/exports.js
var exports_exports16 = {};
__export(exports_exports16, {
  Close: () => dialog_close_default,
  Content: () => dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte
Dialog[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte";
function Dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: box.with(() => "dialog"),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog = hmr(Dialog, () => Dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog[HMR].source;
    set(Dialog[HMR].source, module.default[HMR].original);
  });
}
var dialog_default = Dialog;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte
Dialog_close[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte";
var root_266 = add_locations(from_html(`<button><!></button>`), Dialog_close[FILENAME], [[34, 1]]);
function Dialog_close($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_close);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const closeState = DialogCloseState.create({
    variant: box.with(() => "close"),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, closeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_266();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_close = hmr(Dialog_close, () => Dialog_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_close[HMR].source;
    set(Dialog_close[HMR].source, module.default[HMR].original);
  });
}
var dialog_close_default = Dialog_close;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte
Dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte";
var root_62 = add_locations(from_html(`<!> <!>`, 1), Dialog_content[FILENAME], []);
var root_82 = add_locations(from_html(`<!> <div><!></div>`, 1), Dialog_content[FILENAME], [[102, 8]]);
function Dialog_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = DialogContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => contentState.root.opts.open.current || forceMount());
  {
    const presence = wrap_snippet(Dialog_content, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression_1 = user_derived(() => shouldEnableFocusTrap({
        forceMount: forceMount(),
        present: contentState.root.opts.open.current,
        open: contentState.root.opts.open.current
      }));
      {
        const focusScope = wrap_snippet(Dialog_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg0 == null ? void 0 : $$arg0().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          escape_layer_default(node_2, spread_props(() => get(mergedProps), {
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get ref() {
              return contentState.opts.ref;
            },
            onEscapeKeydown: (e) => {
              onEscapeKeydown()(e);
              if (e.defaultPrevented) return;
              contentState.root.handleClose();
            },
            children: wrap_snippet(Dialog_content, ($$anchor4, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                get ref() {
                  return contentState.opts.ref;
                },
                get enabled() {
                  return contentState.root.opts.open.current;
                },
                onInteractOutside: (e) => {
                  onInteractOutside()(e);
                  if (e.defaultPrevented) return;
                  contentState.root.handleClose();
                },
                children: wrap_snippet(Dialog_content, ($$anchor5, $$slotProps2) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    children: wrap_snippet(Dialog_content, ($$anchor6, $$slotProps3) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      {
                        var consequent_1 = ($$anchor7) => {
                          var fragment_6 = root_62();
                          var node_6 = first_child(fragment_6);
                          {
                            var consequent = ($$anchor8) => {
                              var fragment_7 = comment();
                              var node_7 = first_child(fragment_7);
                              scroll_lock_default(node_7, {
                                get preventScroll() {
                                  return preventScroll();
                                },
                                get restoreScrollDelay() {
                                  return restoreScrollDelay();
                                }
                              });
                              append($$anchor8, fragment_7);
                            };
                            if_block(node_6, ($$render) => {
                              if (contentState.root.opts.open.current) $$render(consequent);
                            });
                          }
                          var node_8 = sibling(node_6, 2);
                          var render_arg = derived_safe_equal(() => ({
                            props: mergeProps(get(mergedProps), focusScopeProps()),
                            ...contentState.snippetProps
                          }));
                          snippet(node_8, () => $$props.child, () => get(render_arg));
                          append($$anchor7, fragment_6);
                        };
                        var alternate = ($$anchor7) => {
                          var fragment_8 = root_82();
                          var node_9 = first_child(fragment_8);
                          scroll_lock_default(node_9, {
                            get preventScroll() {
                              return preventScroll();
                            }
                          });
                          var div = sibling(node_9, 2);
                          attribute_effect(div, ($0) => ({ ...$0 }), [
                            () => mergeProps(get(mergedProps), focusScopeProps())
                          ]);
                          var node_10 = child(div);
                          snippet(node_10, () => $$props.children ?? noop);
                          reset(div);
                          append($$anchor7, fragment_8);
                        };
                        if_block(node_5, ($$render) => {
                          if ($$props.child) $$render(consequent_1);
                          else $$render(alternate, false);
                        });
                      }
                      append($$anchor6, fragment_5);
                    }),
                    $$slots: { default: true }
                  }));
                  append($$anchor5, fragment_4);
                }),
                $$slots: { default: true }
              }));
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          }));
          append($$anchor3, fragment_2);
        });
        focus_scope_default(node_1, {
          get ref() {
            return contentState.opts.ref;
          },
          loop: true,
          get trapFocus() {
            return trapFocus();
          },
          get enabled() {
            return get(expression_1);
          },
          get onOpenAutoFocus() {
            return onOpenAutoFocus();
          },
          onCloseAutoFocus: (e) => {
            onCloseAutoFocus()(e);
            if (e.defaultPrevented) return;
            afterSleep(1, () => {
              var _a;
              return (_a = contentState.root.triggerNode) == null ? void 0 : _a.focus();
            });
          },
          focusScope,
          $$slots: { focusScope: true }
        });
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get forceMount() {
        return forceMount();
      },
      get open() {
        return get(expression);
      },
      get ref() {
        return contentState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_content = hmr(Dialog_content, () => Dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_content[HMR].source;
    set(Dialog_content[HMR].source, module.default[HMR].original);
  });
}
var dialog_content_default = Dialog_content;

// node_modules/bits-ui/dist/bits/dropdown-menu/exports.js
var exports_exports17 = {};
__export(exports_exports17, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => dropdown_menu_content_default,
  ContentStatic: () => dropdown_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/components/menu.svelte
Menu[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu.svelte";
function Menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), variant = prop($$props, "_internal_variant", 3, "dropdown-menu");
  const root18 = MenuRootState.create({
    variant: box.with(() => variant()),
    dir: box.with(() => dir()),
    onClose: () => {
      open(false);
      onOpenChange()(false);
    }
  });
  MenuMenuState.create(
    {
      open: box.with(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: box.with(() => onOpenChangeComplete())
    },
    root18
  );
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Menu, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu = hmr(Menu, () => Menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu[HMR].source;
    set(Menu[HMR].source, module.default[HMR].original);
  });
}
var menu_default = Menu;

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte
Dropdown_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte";
var root_413 = add_locations(from_html(`<div><div><!></div></div>`), Dropdown_menu_content[FILENAME], [[79, 4, [[80, 5]]]]);
var root_99 = add_locations(from_html(`<div><div><!></div></div>`), Dropdown_menu_content[FILENAME], [[107, 4, [[108, 5]]]]);
function Dropdown_menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dropdown_menu_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount",
      "trapFocus"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_413();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          get trapFocus() {
            return trapFocus();
          },
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Dropdown_menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_99();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              get trapFocus() {
                return trapFocus();
              },
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content = hmr(Dropdown_menu_content, () => Dropdown_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content[HMR].source;
    set(Dropdown_menu_content[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_default = Dropdown_menu_content;

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte
Dropdown_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte";
var root_414 = add_locations(from_html(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[73, 4]]);
var root_910 = add_locations(from_html(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[100, 4]]);
function Dropdown_menu_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dropdown_menu_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("dropdown-menu")
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_414();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Dropdown_menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("dropdown-menu")
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_910();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content_static = hmr(Dropdown_menu_content_static, () => Dropdown_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content_static[HMR].source;
    set(Dropdown_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_static_default = Dropdown_menu_content_static;

// node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte
Menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte";
var root_315 = add_locations(from_html(`<button><!></button>`), Menu_trigger[FILENAME], [[36, 2]]);
function Menu_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled",
      "type"
    ],
    "restProps"
  );
  const triggerState = DropdownMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: wrap_snippet(Menu_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_315();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_trigger = hmr(Menu_trigger, () => Menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_trigger[HMR].source;
    set(Menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_trigger_default = Menu_trigger;

// node_modules/bits-ui/dist/bits/label/exports.js
var exports_exports18 = {};
__export(exports_exports18, {
  Root: () => label_default
});

// node_modules/bits-ui/dist/bits/label/label.svelte.js
var labelAttrs = createBitsAttrs({ component: "label", parts: ["root"] });
var _props95;
var _LabelRootState = class _LabelRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props95, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [labelAttrs.root]: "",
        onmousedown: this.onmousedown,
        ...this.attachment
      })),
      "LabelRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onmousedown = this.onmousedown.bind(this);
  }
  static create(opts) {
    return new _LabelRootState(opts);
  }
  onmousedown(e) {
    if (e.detail > 1) e.preventDefault();
  }
  get props() {
    return get(__privateGet(this, _props95));
  }
  set props(value) {
    set(__privateGet(this, _props95), value);
  }
};
_props95 = new WeakMap();
var LabelRootState = _LabelRootState;

// node_modules/bits-ui/dist/bits/label/components/label.svelte
Label[FILENAME] = "node_modules/bits-ui/dist/bits/label/components/label.svelte";
var root_267 = add_locations(from_html(`<label><!></label>`), Label[FILENAME], [[31, 1]]);
function Label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "for"
    ],
    "restProps"
  );
  const rootState = LabelRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { for: $$props.for })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_267();
      attribute_effect(label, () => ({ ...get(mergedProps), for: $$props.for }));
      var node_2 = child(label);
      snippet(node_2, () => $$props.children ?? noop);
      reset(label);
      append($$anchor2, label);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Label = hmr(Label, () => Label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Label[HMR].source;
    set(Label[HMR].source, module.default[HMR].original);
  });
}
var label_default = Label;

// node_modules/bits-ui/dist/bits/link-preview/exports.js
var exports_exports19 = {};
__export(exports_exports19, {
  Arrow: () => floating_layer_arrow_default,
  Content: () => link_preview_content_default,
  ContentStatic: () => link_preview_content_static_default,
  Portal: () => portal_default,
  Root: () => link_preview_default,
  Trigger: () => link_preview_trigger_default
});

// node_modules/bits-ui/dist/bits/link-preview/link-preview.svelte.js
var linkPreviewAttrs = createBitsAttrs({
  component: "link-preview",
  parts: ["content", "trigger"]
});
var LinkPreviewRootContext = new Context("LinkPreview.Root");
var _hasSelection, _isPointerDownOnContent, _containsSelection, _contentNode6, _contentMounted, _triggerNode5;
var _LinkPreviewRootState = class _LinkPreviewRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _hasSelection, tag(state(false), "LinkPreviewRootState.hasSelection"));
    __privateAdd(this, _isPointerDownOnContent, tag(state(false), "LinkPreviewRootState.isPointerDownOnContent"));
    __privateAdd(this, _containsSelection, tag(state(false), "LinkPreviewRootState.containsSelection"));
    __publicField(this, "timeout", null);
    __privateAdd(this, _contentNode6, tag(state(null), "LinkPreviewRootState.contentNode"));
    __privateAdd(this, _contentMounted, tag(state(false), "LinkPreviewRootState.contentMounted"));
    __privateAdd(this, _triggerNode5, tag(state(null), "LinkPreviewRootState.triggerNode"));
    __publicField(this, "isOpening", false);
    __publicField(this, "domContext", new DOMContext(() => null));
    this.opts = opts;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.opts.open.current, (isOpen) => {
      if (!isOpen) {
        this.hasSelection = false;
        return;
      }
      if (!this.domContext) return;
      const handlePointerUp = () => {
        this.containsSelection = false;
        this.isPointerDownOnContent = false;
        afterSleep(1, () => {
          var _a;
          const isSelection = strict_equals((_a = this.domContext.getDocument().getSelection()) == null ? void 0 : _a.toString(), "", false);
          if (isSelection) {
            this.hasSelection = true;
          } else {
            this.hasSelection = false;
          }
        });
      };
      const unsubListener = on(this.domContext.getDocument(), "pointerup", handlePointerUp);
      if (!this.contentNode) return;
      const tabCandidates = getTabbableCandidates(this.contentNode);
      for (const candidate of tabCandidates) {
        candidate.setAttribute("tabindex", "-1");
      }
      return () => {
        unsubListener();
        this.hasSelection = false;
        this.isPointerDownOnContent = false;
      };
    });
  }
  static create(opts) {
    return LinkPreviewRootContext.set(new _LinkPreviewRootState(opts));
  }
  get hasSelection() {
    return get(__privateGet(this, _hasSelection));
  }
  set hasSelection(value) {
    set(__privateGet(this, _hasSelection), value, true);
  }
  get isPointerDownOnContent() {
    return get(__privateGet(this, _isPointerDownOnContent));
  }
  set isPointerDownOnContent(value) {
    set(__privateGet(this, _isPointerDownOnContent), value, true);
  }
  get containsSelection() {
    return get(__privateGet(this, _containsSelection));
  }
  set containsSelection(value) {
    set(__privateGet(this, _containsSelection), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode6));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode6), value, true);
  }
  get contentMounted() {
    return get(__privateGet(this, _contentMounted));
  }
  set contentMounted(value) {
    set(__privateGet(this, _contentMounted), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode5));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode5), value, true);
  }
  clearTimeout() {
    if (this.timeout) {
      this.domContext.clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  handleOpen() {
    this.clearTimeout();
    if (this.opts.open.current) return;
    this.isOpening = true;
    this.timeout = this.domContext.setTimeout(
      () => {
        if (this.isOpening) {
          this.opts.open.current = true;
          this.isOpening = false;
        }
      },
      this.opts.openDelay.current
    );
  }
  immediateClose() {
    this.clearTimeout();
    this.isOpening = false;
    this.opts.open.current = false;
  }
  handleClose() {
    this.isOpening = false;
    this.clearTimeout();
    if (!this.isPointerDownOnContent && !this.hasSelection) {
      this.timeout = this.domContext.setTimeout(
        () => {
          this.opts.open.current = false;
        },
        this.opts.closeDelay.current
      );
    }
  }
};
_hasSelection = new WeakMap();
_isPointerDownOnContent = new WeakMap();
_containsSelection = new WeakMap();
_contentNode6 = new WeakMap();
_contentMounted = new WeakMap();
_triggerNode5 = new WeakMap();
var LinkPreviewRootState = _LinkPreviewRootState;
var _props96;
var _LinkPreviewTriggerState = class _LinkPreviewTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props96, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          "aria-haspopup": "dialog",
          "aria-expanded": getAriaExpanded(this.root.opts.open.current),
          "data-state": getDataOpenClosed(this.root.opts.open.current),
          "aria-controls": (_a = this.root.contentNode) == null ? void 0 : _a.id,
          role: "button",
          [linkPreviewAttrs.trigger]: "",
          onpointerenter: this.onpointerenter,
          onfocus: this.onfocus,
          onblur: this.onblur,
          onpointerleave: this.onpointerleave,
          ...this.attachment
        };
      }),
      "LinkPreviewTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  static create(opts) {
    return new _LinkPreviewTriggerState(opts, LinkPreviewRootContext.get());
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onpointerleave(e) {
    if (isTouch(e)) return;
    if (!this.root.contentMounted) {
      this.root.immediateClose();
    }
  }
  onfocus(e) {
    if (!isFocusVisible(e.currentTarget)) return;
    this.root.handleOpen();
  }
  onblur(_) {
    this.root.handleClose();
  }
  get props() {
    return get(__privateGet(this, _props96));
  }
  set props(value) {
    set(__privateGet(this, _props96), value);
  }
};
_props96 = new WeakMap();
var LinkPreviewTriggerState = _LinkPreviewTriggerState;
var _snippetProps19, _props97;
var _LinkPreviewContentState = class _LinkPreviewContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onEscapeKeydown).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps19, tag(user_derived(() => ({ open: this.root.opts.open.current })), "LinkPreviewContentState.snippetProps"));
    __privateAdd(this, _props97, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        tabindex: -1,
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        [linkPreviewAttrs.content]: "",
        onpointerdown: this.onpointerdown,
        onpointerenter: this.onpointerenter,
        onfocusout: this.onfocusout,
        ...this.attachment
      })),
      "LinkPreviewContentState.props"
    ));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.opts.ref.current,
      enabled: () => this.root.opts.open.current,
      onPointerExit: () => {
        this.root.handleClose();
      }
    });
    onDestroyEffect(() => {
      this.root.clearTimeout();
    });
  }
  static create(opts) {
    return new _LinkPreviewContentState(opts, LinkPreviewRootContext.get());
  }
  onpointerdown(e) {
    const target = e.target;
    if (!isElement2(target)) return;
    if (e.currentTarget.contains(target)) {
      this.root.containsSelection = true;
    }
    this.root.hasSelection = true;
    this.root.isPointerDownOnContent = true;
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onfocusout(e) {
    e.preventDefault();
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps19));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps19), value);
  }
  get props() {
    return get(__privateGet(this, _props97));
  }
  set props(value) {
    set(__privateGet(this, _props97), value);
  }
};
_snippetProps19 = new WeakMap();
_props97 = new WeakMap();
var LinkPreviewContentState = _LinkPreviewContentState;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte
Link_preview[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte";
function Link_preview($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), openDelay = prop($$props, "openDelay", 3, 700), closeDelay = prop($$props, "closeDelay", 3, 300);
  LinkPreviewRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    openDelay: box.with(() => openDelay()),
    closeDelay: box.with(() => closeDelay()),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Root, ($$anchor2, FloatingLayer_Root) => {
    FloatingLayer_Root($$anchor2, {
      children: wrap_snippet(Link_preview, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        snippet(node_1, () => $$props.children ?? noop);
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview = hmr(Link_preview, () => Link_preview[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview[HMR].source;
    set(Link_preview[HMR].source, module.default[HMR].original);
  });
}
var link_preview_default = Link_preview;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte
Link_preview_content[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte";
var root_415 = add_locations(from_html(`<div><div><!></div></div>`), Link_preview_content[FILENAME], [[76, 4, [[77, 5]]]]);
var root_911 = add_locations(from_html(`<div><div><!></div></div>`), Link_preview_content[FILENAME], [[103, 4, [[104, 5]]]]);
var root_7 = add_locations(from_html(`<!> <!>`, 1), Link_preview_content[FILENAME], []);
function Link_preview_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = LinkPreviewContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const floatingProps = tag(
    user_derived(() => ({
      side: side(),
      sideOffset: sideOffset(),
      align: align(),
      avoidCollisions: avoidCollisions(),
      arrowPadding: arrowPadding(),
      sticky: sticky(),
      hideWhenDetached: hideWhenDetached(),
      collisionPadding: collisionPadding()
    })),
    "floatingProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_415();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Link_preview_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = root_7();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              get(mergedProps2);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_911();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              var node_9 = sibling(node_6, 2);
              validate_binding("bind:mounted={contentState.root.contentMounted}", () => contentState.root, () => "contentMounted", 109, 12);
              mounted_default(node_9, {
                get mounted() {
                  return contentState.root.contentMounted;
                },
                set mounted($$value) {
                  contentState.root.contentMounted = $$value;
                }
              });
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content = hmr(Link_preview_content, () => Link_preview_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content[HMR].source;
    set(Link_preview_content[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_default = Link_preview_content;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte
Link_preview_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte";
var root_316 = add_locations(from_html(`<a><!></a>`), Link_preview_trigger[FILENAME], [[33, 2]]);
function Link_preview_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const triggerState = LinkPreviewTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
    FloatingLayer_Anchor($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Link_preview_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var a2 = root_316();
            attribute_effect(a2, () => ({ ...get(mergedProps) }));
            var node_3 = child(a2);
            snippet(node_3, () => $$props.children ?? noop);
            reset(a2);
            append($$anchor4, a2);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_trigger = hmr(Link_preview_trigger, () => Link_preview_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_trigger[HMR].source;
    set(Link_preview_trigger[HMR].source, module.default[HMR].original);
  });
}
var link_preview_trigger_default = Link_preview_trigger;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte
Link_preview_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte";
var root_416 = add_locations(from_html(`<div><!></div>`), Link_preview_content_static[FILENAME], [[57, 4]]);
var root_912 = add_locations(from_html(`<div><!></div>`), Link_preview_content_static[FILENAME], [[83, 4]]);
function Link_preview_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = LinkPreviewContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("link-preview")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_416();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.root.opts.open.current;
          },
          isStatic: true,
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Link_preview_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("link-preview")
              }));
              get(mergedProps2);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_912();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.root.opts.open.current;
              },
              isStatic: true,
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content_static = hmr(Link_preview_content_static, () => Link_preview_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content_static[HMR].source;
    set(Link_preview_content_static[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_static_default = Link_preview_content_static;

// node_modules/bits-ui/dist/bits/menubar/exports.js
var exports_exports20 = {};
__export(exports_exports20, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => menubar_content_default,
  ContentStatic: () => menubar_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Menu: () => menubar_menu_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menubar_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menubar_trigger_default
});

// node_modules/bits-ui/dist/bits/menubar/menubar.svelte.js
var menubarAttrs = createBitsAttrs({
  component: "menubar",
  parts: ["root", "trigger", "content"]
});
var MenubarRootContext = new Context("Menubar.Root");
var MenubarMenuContext = new Context("Menubar.Menu");
var _wasOpenedByKeyboard, _triggerIds, _props98;
var _MenubarRootState = class _MenubarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _wasOpenedByKeyboard, tag(state(false), "MenubarRootState.wasOpenedByKeyboard"));
    __privateAdd(this, _triggerIds, tag(state(proxy([])), "MenubarRootState.triggerIds"));
    __publicField(this, "valueToChangeHandler", /* @__PURE__ */ new Map());
    /**
     * @param id - the id of the trigger to register
     * @returns - a function to de-register the trigger
     */
    __publicField(this, "registerTrigger", (id) => {
      this.triggerIds.push(id);
      return () => {
        this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
      };
    });
    /**
     * @param value - the value of the menu to register
     * @param contentId - the content id to associate with the value
     * @returns - a function to de-register the menu
     */
    __publicField(this, "registerMenu", (value, onOpenChange) => {
      this.valueToChangeHandler.set(value, onOpenChange);
      return () => {
        this.valueToChangeHandler.delete(value);
      };
    });
    __publicField(this, "updateValue", (value) => {
      var _a, _b;
      const currValue = this.opts.value.current;
      const currHandler = (_a = this.valueToChangeHandler.get(currValue)) == null ? void 0 : _a.current;
      const nextHandler = (_b = this.valueToChangeHandler.get(value)) == null ? void 0 : _b.current;
      this.opts.value.current = value;
      if (currHandler && strict_equals(currValue, value, false)) {
        currHandler(false);
      }
      if (nextHandler) {
        nextHandler(true);
      }
    });
    __publicField(this, "getTriggers", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll(menubarAttrs.selector("trigger")));
    });
    __publicField(this, "onMenuOpen", (id, triggerId) => {
      this.updateValue(id);
      this.rovingFocusGroup.setCurrentTabStopId(triggerId);
    });
    __publicField(this, "onMenuClose", () => {
      this.updateValue("");
    });
    __publicField(this, "onMenuToggle", (id) => {
      this.updateValue(this.opts.value.current ? "" : id);
    });
    __privateAdd(this, _props98, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "menubar",
        [menubarAttrs.root]: "",
        ...this.attachment
      })),
      "MenubarRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: menubarAttrs.trigger,
      loop: this.opts.loop,
      orientation: box.with(() => "horizontal")
    });
  }
  static create(opts) {
    return MenubarRootContext.set(new _MenubarRootState(opts));
  }
  get wasOpenedByKeyboard() {
    return get(__privateGet(this, _wasOpenedByKeyboard));
  }
  set wasOpenedByKeyboard(value) {
    set(__privateGet(this, _wasOpenedByKeyboard), value, true);
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds), value, true);
  }
  get props() {
    return get(__privateGet(this, _props98));
  }
  set props(value) {
    set(__privateGet(this, _props98), value);
  }
};
_wasOpenedByKeyboard = new WeakMap();
_triggerIds = new WeakMap();
_props98 = new WeakMap();
var MenubarRootState = _MenubarRootState;
var _open2, _triggerNode6, _triggerId2, _contentId3, _contentNode7;
var _MenubarMenuState = class _MenubarMenuState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _open2, tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "MenubarMenuState.open"));
    __publicField(this, "wasOpenedByKeyboard", false);
    __privateAdd(this, _triggerNode6, tag(state(null), "MenubarMenuState.triggerNode"));
    __privateAdd(this, _triggerId2, tag(user_derived(() => {
      var _a;
      return (_a = this.triggerNode) == null ? void 0 : _a.id;
    }), "MenubarMenuState.triggerId"));
    __privateAdd(this, _contentId3, tag(user_derived(() => {
      var _a;
      return (_a = this.contentNode) == null ? void 0 : _a.id;
    }), "MenubarMenuState.contentId"));
    __privateAdd(this, _contentNode7, tag(state(null), "MenubarMenuState.contentNode"));
    this.opts = opts;
    this.root = root18;
    watch(() => this.open, () => {
      if (!this.open) {
        this.wasOpenedByKeyboard = false;
      }
    });
    onMount(() => {
      return this.root.registerMenu(this.opts.value.current, opts.onOpenChange);
    });
  }
  static create(opts) {
    return MenubarMenuContext.set(new _MenubarMenuState(opts, MenubarRootContext.get()));
  }
  get open() {
    return get(__privateGet(this, _open2));
  }
  set open(value) {
    set(__privateGet(this, _open2), value);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode6));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode6), value, true);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId2));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId2), value);
  }
  get contentId() {
    return get(__privateGet(this, _contentId3));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId3), value);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode7));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode7), value, true);
  }
  getTriggerNode() {
    return this.triggerNode;
  }
  toggleMenu() {
    this.root.onMenuToggle(this.opts.value.current);
  }
  openMenu() {
    var _a;
    this.root.onMenuOpen(this.opts.value.current, ((_a = this.triggerNode) == null ? void 0 : _a.id) ?? "");
  }
};
_open2 = new WeakMap();
_triggerNode6 = new WeakMap();
_triggerId2 = new WeakMap();
_contentId3 = new WeakMap();
_contentNode7 = new WeakMap();
var MenubarMenuState = _MenubarMenuState;
var _isFocused2, _tabIndex, _props99;
var _MenubarTriggerState = class _MenubarTriggerState {
  constructor(opts, menu) {
    __publicField(this, "opts");
    __publicField(this, "menu");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused2, tag(state(false), "MenubarTriggerState.isFocused"));
    __privateAdd(this, _tabIndex, tag(state(0), "MenubarTriggerState.#tabIndex"));
    __publicField(this, "onpointerdown", (e) => {
      if (!this.opts.disabled.current && strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
        if (!this.menu.open) {
          e.preventDefault();
        }
        this.menu.toggleMenu();
      }
    });
    __publicField(this, "onpointerenter", () => {
      var _a;
      const isMenubarOpen = Boolean(this.root.opts.value.current);
      if (isMenubarOpen && !this.menu.open) {
        this.menu.openMenu();
        (_a = this.menu.getTriggerNode()) == null ? void 0 : _a.focus();
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.opts.disabled.current) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
        this.root.onMenuToggle(this.menu.opts.value.current);
      }
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        this.menu.openMenu();
      }
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        this.menu.wasOpenedByKeyboard = true;
        e.preventDefault();
      }
      this.root.rovingFocusGroup.handleKeydown(this.menu.getTriggerNode(), e);
    });
    __publicField(this, "onfocus", () => {
      this.isFocused = true;
    });
    __publicField(this, "onblur", () => {
      this.isFocused = false;
    });
    __privateAdd(this, _props99, tag(
      user_derived(() => ({
        type: "button",
        role: "menuitem",
        id: this.opts.id.current,
        "aria-haspopup": "menu",
        "aria-expanded": getAriaExpanded(this.menu.open),
        "aria-controls": this.menu.open ? this.menu.contentId : void 0,
        "data-highlighted": this.isFocused ? "" : void 0,
        "data-state": getDataOpenClosed(this.menu.open),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-menu-value": this.menu.opts.value.current,
        disabled: this.opts.disabled.current ? true : void 0,
        tabindex: get(__privateGet(this, _tabIndex)),
        [menubarAttrs.trigger]: "",
        onpointerdown: this.onpointerdown,
        onpointerenter: this.onpointerenter,
        onkeydown: this.onkeydown,
        onfocus: this.onfocus,
        onblur: this.onblur,
        ...this.attachment
      })),
      "MenubarTriggerState.props"
    ));
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.triggerNode = v);
    onMount(() => {
      return this.root.registerTrigger(opts.id.current);
    });
    user_effect(() => {
      if (this.root.triggerIds.length) {
        set(__privateGet(this, _tabIndex), this.root.rovingFocusGroup.getTabIndex(this.menu.getTriggerNode()), true);
      }
    });
  }
  static create(opts) {
    return new _MenubarTriggerState(opts, MenubarMenuContext.get());
  }
  get isFocused() {
    return get(__privateGet(this, _isFocused2));
  }
  set isFocused(value) {
    set(__privateGet(this, _isFocused2), value, true);
  }
  get props() {
    return get(__privateGet(this, _props99));
  }
  set props(value) {
    set(__privateGet(this, _props99), value);
  }
};
_isFocused2 = new WeakMap();
_tabIndex = new WeakMap();
_props99 = new WeakMap();
var MenubarTriggerState = _MenubarTriggerState;
var _props100;
var _MenubarContentState = class _MenubarContentState {
  constructor(opts, menu) {
    __publicField(this, "opts");
    __publicField(this, "menu");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onCloseAutoFocus", (e) => {
      this.opts.onCloseAutoFocus.current(e);
      if (e.defaultPrevented) return;
    });
    __publicField(this, "onFocusOutside", (e) => {
      const target = e.target;
      const isMenubarTrigger = this.root.getTriggers().some((trigger) => trigger.contains(target));
      if (isMenubarTrigger) e.preventDefault();
      this.opts.onFocusOutside.current(e);
    });
    __publicField(this, "onInteractOutside", (e) => {
      this.opts.onInteractOutside.current(e);
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      this.opts.onOpenAutoFocus.current(e);
      if (e.defaultPrevented) return;
      afterTick(() => {
        var _a;
        return (_a = this.opts.ref.current) == null ? void 0 : _a.focus();
      });
    });
    __publicField(this, "onkeydown", (e) => {
      if (strict_equals(e.key, kbd_constants_exports.ARROW_LEFT, false) && strict_equals(e.key, kbd_constants_exports.ARROW_RIGHT, false)) return;
      const target = e.target;
      const targetIsSubTrigger = target.hasAttribute("data-menu-sub-trigger");
      const isKeydownInsideSubMenu = strict_equals(target.closest("[data-menu-content]"), e.currentTarget, false);
      const prevMenuKey = strict_equals(this.root.opts.dir.current, "rtl") ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT;
      const isPrevKey = strict_equals(prevMenuKey, e.key);
      const isNextKey = !isPrevKey;
      if (isNextKey && targetIsSubTrigger) return;
      if (isKeydownInsideSubMenu && isPrevKey) return;
      const items = this.root.getTriggers().filter((trigger) => !trigger.disabled);
      let candidates = items.map((item) => ({
        value: item.getAttribute("data-menu-value"),
        triggerId: item.id ?? ""
      }));
      if (isPrevKey) candidates.reverse();
      const candidateValues = candidates.map(({ value }) => value);
      const currentIndex = candidateValues.indexOf(this.menu.opts.value.current);
      candidates = this.root.opts.loop.current ? wrapArray(candidates, currentIndex + 1) : candidates.slice(currentIndex + 1);
      const [nextValue] = candidates;
      if (nextValue) this.menu.root.onMenuOpen(nextValue.value, nextValue.triggerId);
    });
    __privateAdd(this, _props100, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-labelledby": this.menu.triggerId,
        style: getFloatingContentCSSVars("menubar"),
        onkeydown: this.onkeydown,
        "data-menu-content": "",
        [menubarAttrs.content]: "",
        ...this.attachment
      })),
      "MenubarContentState.props"
    ));
    __publicField(this, "popperProps", {
      onCloseAutoFocus: this.onCloseAutoFocus,
      onFocusOutside: this.onFocusOutside,
      onInteractOutside: this.onInteractOutside,
      onOpenAutoFocus: this.onOpenAutoFocus
    });
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.contentNode = v);
  }
  static create(opts) {
    return new _MenubarContentState(opts, MenubarMenuContext.get());
  }
  get props() {
    return get(__privateGet(this, _props100));
  }
  set props(value) {
    set(__privateGet(this, _props100), value);
  }
};
_props100 = new WeakMap();
var MenubarContentState = _MenubarContentState;

// node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte
Menubar[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte";
var root_268 = add_locations(from_html(`<div><!></div>`), Menubar[FILENAME], [[45, 1]]);
function Menubar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 7, ""), dir = prop($$props, "dir", 3, "ltr"), loop = prop($$props, "loop", 3, true), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "dir",
      "loop",
      "onValueChange"
    ],
    "restProps"
  );
  const rootState = MenubarRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    dir: box.with(() => dir()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_268();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar = hmr(Menubar, () => Menubar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar[HMR].source;
    set(Menubar[HMR].source, module.default[HMR].original);
  });
}
var menubar_default = Menubar;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte
Menubar_menu[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte";
function Menubar_menu($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_menu);
  let value = prop($$props, "value", 19, () => createId(uid)), onOpenChange = prop($$props, "onOpenChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "onOpenChange"
    ],
    "restProps"
  );
  const menuState = MenubarMenuState.create({
    value: box.with(() => value()),
    onOpenChange: box.with(() => onOpenChange())
  });
  var fragment = comment();
  var node = first_child(fragment);
  menu_default(node, spread_props(
    {
      get open() {
        return menuState.open;
      },
      onOpenChange: (open) => {
        if (!open) menuState.root.onMenuClose();
      },
      get dir() {
        return menuState.root.opts.dir.current;
      },
      _internal_variant: "menubar"
    },
    () => restProps
  ));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_menu = hmr(Menubar_menu, () => Menubar_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_menu[HMR].source;
    set(Menubar_menu[HMR].source, module.default[HMR].original);
  });
}
var menubar_menu_default = Menubar_menu;

// node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte
Menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte";
var root_417 = add_locations(from_html(`<div><div><!></div></div>`), Menu_content[FILENAME], [[83, 4, [[84, 5]]]]);
var root_913 = add_locations(from_html(`<div><div><!></div></div>`), Menu_content[FILENAME], [[114, 4, [[115, 5]]]]);
function Menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocusProp())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } })), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_417();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_913();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content = hmr(Menu_content, () => Menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content[HMR].source;
    set(Menu_content[HMR].source, module.default[HMR].original);
  });
}
var menu_content_default = Menu_content;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte
Menubar_content[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte";
function Menubar_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_content);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id",
      "onInteractOutside",
      "onFocusOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const contentState = MenubarContentState.create({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onFocusOutside: box.with(() => onFocusOutside()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", menu_content_default, ref);
    menu_content_default(node, spread_props(() => get(mergedProps), () => contentState.popperProps, {
      preventScroll: false,
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content = hmr(Menubar_content, () => Menubar_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content[HMR].source;
    set(Menubar_content[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_default = Menubar_content;

// node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte
Menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte";
var root_418 = add_locations(from_html(`<div><!></div>`), Menu_content_static[FILENAME], [[79, 4]]);
var root_914 = add_locations(from_html(`<div><!></div>`), Menu_content_static[FILENAME], [[109, 4]]);
function Menu_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocusProp())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } })), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(props(), {
            style: {
              outline: "none",
              ...getFloatingContentCSSVars("menu")
            }
          }));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(finalProps),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_418();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get ref() {
            return contentState.opts.ref;
          },
          get enabled() {
            return contentState.parentMenu.opts.open.current;
          },
          onInteractOutside: handleInteractOutside,
          onEscapeKeydown: handleEscapeKeydown,
          trapFocus: true,
          get loop() {
            return loop();
          },
          forceMount: true,
          isStatic: true,
          get id() {
            return id();
          },
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const finalProps = user_derived(() => mergeProps(props(), {
                style: {
                  outline: "none",
                  ...getFloatingContentCSSVars("menu")
                }
              }));
              get(finalProps);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(finalProps),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_914();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get ref() {
                return contentState.opts.ref;
              },
              get open() {
                return contentState.parentMenu.opts.open.current;
              },
              onInteractOutside: handleInteractOutside,
              onEscapeKeydown: handleEscapeKeydown,
              trapFocus: true,
              get loop() {
                return loop();
              },
              forceMount: false,
              isStatic: true,
              get id() {
                return id();
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content_static = hmr(Menu_content_static, () => Menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content_static[HMR].source;
    set(Menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_content_static_default = Menu_content_static;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte
Menubar_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte";
function Menubar_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_content_static);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onFocusOutside",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const contentState = MenubarContentState.create({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onFocusOutside: box.with(() => onFocusOutside()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", menu_content_static_default, ref);
    menu_content_static_default(node, spread_props(() => get(mergedProps), () => contentState.popperProps, {
      preventScroll: false,
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content_static = hmr(Menubar_content_static, () => Menubar_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content_static[HMR].source;
    set(Menubar_content_static[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_static_default = Menubar_content_static;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte
Menubar_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte";
var root_317 = add_locations(from_html(`<button><!></button>`), Menubar_trigger[FILENAME], [[45, 2]]);
function Menubar_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const triggerState = MenubarTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const dropdownTriggerState = DropdownMenuTriggerState.create(triggerState.opts);
  const triggerAttachment = attachRef((v) => assign(dropdownTriggerState.parentMenu, "triggerNode", v, "node_modules/​bits-ui/​dist/​bits/​menubar/​components/​menubar-trigger.svelte:31:30"));
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { ...triggerAttachment })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    children: wrap_snippet(Menubar_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_317();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_trigger = hmr(Menubar_trigger, () => Menubar_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_trigger[HMR].source;
    set(Menubar_trigger[HMR].source, module.default[HMR].original);
  });
}
var menubar_trigger_default = Menubar_trigger;

// node_modules/bits-ui/dist/bits/meter/exports.js
var exports_exports21 = {};
__export(exports_exports21, {
  Root: () => meter_default
});

// node_modules/bits-ui/dist/bits/meter/meter.svelte.js
var meterAttrs = createBitsAttrs({ component: "meter", parts: ["root"] });
var _props101;
var _MeterRootState = class _MeterRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props101, tag(
      user_derived(() => ({
        role: "meter",
        value: this.opts.value.current,
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": this.opts.value.current,
        "data-value": this.opts.value.current,
        "data-max": this.opts.max.current,
        "data-min": this.opts.min.current,
        [meterAttrs.root]: "",
        ...this.attachment
      })),
      "MeterRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _MeterRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props101));
  }
  set props(value) {
    set(__privateGet(this, _props101), value);
  }
};
_props101 = new WeakMap();
var MeterRootState = _MeterRootState;

// node_modules/bits-ui/dist/bits/meter/components/meter.svelte
Meter[FILENAME] = "node_modules/bits-ui/dist/bits/meter/components/meter.svelte";
var root_269 = add_locations(from_html(`<div><!></div>`), Meter[FILENAME], [[37, 1]]);
function Meter($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Meter);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "max",
      "min",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = MeterRootState.create({
    value: box.with(() => value()),
    max: box.with(() => max()),
    min: box.with(() => min()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_269();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Meter = hmr(Meter, () => Meter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Meter[HMR].source;
    set(Meter[HMR].source, module.default[HMR].original);
  });
}
var meter_default = Meter;

// node_modules/bits-ui/dist/bits/navigation-menu/exports.js
var exports_exports22 = {};
__export(exports_exports22, {
  Content: () => navigation_menu_content_default,
  Indicator: () => navigation_menu_indicator_default,
  Item: () => navigation_menu_item_default,
  Link: () => navigation_menu_link_default,
  List: () => navigation_menu_list_default,
  Root: () => navigation_menu_default,
  Sub: () => navigation_menu_sub_default,
  Trigger: () => navigation_menu_trigger_default,
  Viewport: () => navigation_menu_viewport_default
});

// node_modules/bits-ui/dist/bits/pin-input/usePasswordManager.svelte.js
var PWM_BADGE_MARGIN_RIGHT = 18;
var PWM_BADGE_SPACE_WIDTH_PX = 40;
var PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px`;
var PASSWORD_MANAGER_SELECTORS = [
  "[data-lastpass-icon-root]",
  // LastPass,
  "com-1password-button",
  // 1Password,
  "[data-dashlanecreated]",
  // Dashlane,
  '[style$="2147483647 !important;"]'
  // Bitwarden
].join(",");
function usePasswordManagerBadge({
  containerRef,
  inputRef,
  pushPasswordManagerStrategy,
  isFocused,
  domContext
}) {
  let hasPwmBadge = tag(state(false), "hasPwmBadge");
  let hasPwmBadgeSpace = tag(state(false), "hasPwmBadgeSpace");
  let done = tag(state(false), "done");
  function willPushPwmBadge() {
    const strategy = pushPasswordManagerStrategy.current;
    if (strict_equals(strategy, "none")) return false;
    const increaseWidthCase = strict_equals(strategy, "increase-width") && get(hasPwmBadge) && get(hasPwmBadgeSpace);
    return increaseWidthCase;
  }
  function trackPwmBadge() {
    const container = containerRef.current;
    const input = inputRef.current;
    if (!container || !input || get(done) || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    const elementToCompare = container;
    const rightCornerX = elementToCompare.getBoundingClientRect().left + elementToCompare.offsetWidth;
    const centeredY = elementToCompare.getBoundingClientRect().top + elementToCompare.offsetHeight / 2;
    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT;
    const y = centeredY;
    const passwordManagerStrategy = domContext.querySelectorAll(PASSWORD_MANAGER_SELECTORS);
    if (strict_equals(passwordManagerStrategy.length, 0)) {
      const maybeBadgeEl = domContext.getDocument().elementFromPoint(x, y);
      if (strict_equals(maybeBadgeEl, container)) return;
    }
    set(hasPwmBadge, true);
    set(done, true);
  }
  user_effect(() => {
    const container = containerRef.current;
    if (!container || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    function checkHasSpace() {
      const viewportWidth = getWindow(container).innerWidth;
      const distanceToRightEdge = viewportWidth - container.getBoundingClientRect().right;
      set(hasPwmBadgeSpace, distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX);
    }
    checkHasSpace();
    const interval = setInterval(checkHasSpace, 1e3);
    return () => {
      clearInterval(interval);
    };
  });
  user_effect(() => {
    const focused = isFocused.current || strict_equals(domContext.getActiveElement(), inputRef.current);
    if (strict_equals(pushPasswordManagerStrategy.current, "none") || !focused) return;
    const t1 = setTimeout(trackPwmBadge, 0);
    const t2 = setTimeout(trackPwmBadge, 2e3);
    const t3 = setTimeout(trackPwmBadge, 5e3);
    const t4 = setTimeout(
      () => {
        set(done, true);
      },
      6e3
    );
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
      clearTimeout(t3);
      clearTimeout(t4);
    };
  });
  return {
    get hasPwmBadge() {
      return get(hasPwmBadge);
    },
    get willPushPwmBadge() {
      return willPushPwmBadge();
    },
    PWM_BADGE_SPACE_WIDTH
  };
}

// node_modules/bits-ui/dist/bits/pin-input/pin-input.svelte.js
var REGEXP_ONLY_DIGITS = "^\\d+$";
var REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
var REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";
var pinInputAttrs = createBitsAttrs({
  component: "pin-input",
  parts: ["root", "cell"]
});
var KEYS_TO_IGNORE = [
  "Backspace",
  "Delete",
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "End",
  "Escape",
  "Enter",
  "Tab",
  "Shift",
  "Control",
  "Meta"
];
var _inputRef, _isHoveringInput, _isFocused3, _mirrorSelectionStart, _mirrorSelectionEnd, _previousValue, _regexPattern, _prevInputMetadata, _pwmb, _initialLoad, _rootStyles, _rootProps, _inputWrapperProps, _inputStyle, _PinInputRootState_instances, applyStyles_fn, _onDocumentSelectionChange, _inputProps, _cells, _snippetProps20;
var _PinInputRootState = class _PinInputRootState {
  constructor(opts) {
    __privateAdd(this, _PinInputRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _inputRef, box(null));
    __privateAdd(this, _isHoveringInput, tag(state(false), "PinInputRootState.#isHoveringInput"));
    __publicField(this, "inputAttachment", attachRef(__privateGet(this, _inputRef)));
    __privateAdd(this, _isFocused3, box(false));
    __privateAdd(this, _mirrorSelectionStart, tag(state(null), "PinInputRootState.#mirrorSelectionStart"));
    __privateAdd(this, _mirrorSelectionEnd, tag(state(null), "PinInputRootState.#mirrorSelectionEnd"));
    __privateAdd(this, _previousValue, new Previous(() => this.opts.value.current ?? ""));
    __privateAdd(this, _regexPattern, tag(
      user_derived(() => {
        if (strict_equals(typeof this.opts.pattern.current, "string")) {
          return new RegExp(this.opts.pattern.current);
        } else {
          return this.opts.pattern.current;
        }
      }),
      "PinInputRootState.#regexPattern"
    ));
    __privateAdd(this, _prevInputMetadata, tag(
      state(proxy({
        prev: [null, null, "none"],
        willSyntheticBlur: false
      })),
      "PinInputRootState.#prevInputMetadata"
    ));
    __privateAdd(this, _pwmb);
    __privateAdd(this, _initialLoad);
    __publicField(this, "domContext");
    __publicField(this, "onkeydown", (e) => {
      const key = e.key;
      if (KEYS_TO_IGNORE.includes(key)) return;
      if (e.ctrlKey || e.metaKey) return;
      if (key && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(key)) {
        e.preventDefault();
      }
    });
    __privateAdd(this, _rootStyles, tag(
      user_derived(() => ({
        position: "relative",
        cursor: this.opts.disabled.current ? "default" : "text",
        userSelect: "none",
        WebkitUserSelect: "none",
        pointerEvents: "none"
      })),
      "PinInputRootState.#rootStyles"
    ));
    __privateAdd(this, _rootProps, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [pinInputAttrs.root]: "",
        style: get(__privateGet(this, _rootStyles)),
        ...this.attachment
      })),
      "PinInputRootState.rootProps"
    ));
    __privateAdd(this, _inputWrapperProps, tag(
      user_derived(() => ({
        style: {
          position: "absolute",
          inset: 0,
          pointerEvents: "none"
        }
      })),
      "PinInputRootState.inputWrapperProps"
    ));
    __privateAdd(this, _inputStyle, tag(
      user_derived(() => ({
        position: "absolute",
        inset: 0,
        width: __privateGet(this, _pwmb).willPushPwmBadge ? `calc(100% + ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH})` : "100%",
        clipPath: __privateGet(this, _pwmb).willPushPwmBadge ? `inset(0 ${__privateGet(this, _pwmb).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
        height: "100%",
        display: "flex",
        textAlign: this.opts.textAlign.current,
        opacity: "1",
        color: "transparent",
        pointerEvents: "all",
        background: "transparent",
        caretColor: "transparent",
        border: "0 solid transparent",
        outline: "0 solid transparent",
        boxShadow: "none",
        lineHeight: "1",
        letterSpacing: "-.5em",
        fontSize: "var(--bits-pin-input-root-height)",
        fontFamily: "monospace",
        fontVariantNumeric: "tabular-nums"
      })),
      "PinInputRootState.#inputStyle"
    ));
    __privateAdd(this, _onDocumentSelectionChange, () => {
      var _a;
      const input = __privateGet(this, _inputRef).current;
      const container = this.opts.ref.current;
      if (!input || !container) return;
      if (strict_equals(this.domContext.getActiveElement(), input, false)) {
        set(__privateGet(this, _mirrorSelectionStart), null);
        set(__privateGet(this, _mirrorSelectionEnd), null);
        return;
      }
      const selStart = input.selectionStart;
      const selEnd = input.selectionEnd;
      const selDir = input.selectionDirection ?? "none";
      const maxLength = input.maxLength;
      const val = input.value;
      const prev2 = get(__privateGet(this, _prevInputMetadata)).prev;
      let start = -1;
      let end = -1;
      let direction;
      if (strict_equals(val.length, 0, false) && strict_equals(selStart, null, false) && strict_equals(selEnd, null, false)) {
        const isSingleCaret = strict_equals(selStart, selEnd);
        const isInsertMode = strict_equals(selStart, val.length) && val.length < maxLength;
        if (isSingleCaret && !isInsertMode) {
          const c = selStart;
          if (strict_equals(c, 0)) {
            start = 0;
            end = 1;
            direction = "forward";
          } else if (strict_equals(c, maxLength)) {
            start = c - 1;
            end = c;
            direction = "backward";
          } else if (maxLength > 1 && val.length > 1) {
            let offset2 = 0;
            if (strict_equals(prev2[0], null, false) && strict_equals(prev2[1], null, false)) {
              direction = c < prev2[0] ? "backward" : "forward";
              const wasPreviouslyInserting = strict_equals(prev2[0], prev2[1]) && prev2[0] < maxLength;
              if (strict_equals(direction, "backward") && !wasPreviouslyInserting) {
                offset2 = -1;
              }
            }
            start = offset2 - c;
            end = offset2 + c + 1;
          }
        }
        if (strict_equals(start, -1, false) && strict_equals(end, -1, false) && strict_equals(start, end, false)) {
          (_a = __privateGet(this, _inputRef).current) == null ? void 0 : _a.setSelectionRange(start, end, direction);
        }
      }
      const s = strict_equals(start, -1, false) ? start : selStart;
      const e = strict_equals(end, -1, false) ? end : selEnd;
      const dir = direction ?? selDir;
      set(__privateGet(this, _mirrorSelectionStart), s, true);
      set(__privateGet(this, _mirrorSelectionEnd), e, true);
      get(__privateGet(this, _prevInputMetadata)).prev = [s, e, dir];
    });
    __publicField(this, "oninput", (e) => {
      const newValue = e.currentTarget.value.slice(0, this.opts.maxLength.current);
      if (newValue.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue)) {
        e.preventDefault();
        return;
      }
      const maybeHasDeleted = strict_equals(typeof __privateGet(this, _previousValue).current, "string") && newValue.length < __privateGet(this, _previousValue).current.length;
      if (maybeHasDeleted) {
        this.domContext.getDocument().dispatchEvent(new Event("selectionchange"));
      }
      this.opts.value.current = newValue;
    });
    __publicField(this, "onfocus", (_) => {
      const input = __privateGet(this, _inputRef).current;
      if (input) {
        const start = Math.min(input.value.length, this.opts.maxLength.current - 1);
        const end = input.value.length;
        input.setSelectionRange(start, end);
        set(__privateGet(this, _mirrorSelectionStart), start, true);
        set(__privateGet(this, _mirrorSelectionEnd), end, true);
      }
      __privateGet(this, _isFocused3).current = true;
    });
    __publicField(this, "onpaste", (e) => {
      var _a, _b, _c, _d;
      const input = __privateGet(this, _inputRef).current;
      if (!input) return;
      const getNewValue = (finalContent) => {
        const start = strict_equals(input.selectionStart, null) ? void 0 : input.selectionStart;
        const end = strict_equals(input.selectionEnd, null) ? void 0 : input.selectionEnd;
        const isReplacing = strict_equals(start, end, false);
        const initNewVal = this.opts.value.current;
        const newValueUncapped = isReplacing ? initNewVal.slice(0, start) + finalContent + initNewVal.slice(end) : initNewVal.slice(0, start) + finalContent + initNewVal.slice(start);
        return newValueUncapped.slice(0, this.opts.maxLength.current);
      };
      const isValueInvalid = (newValue2) => {
        return newValue2.length > 0 && get(__privateGet(this, _regexPattern)) && !get(__privateGet(this, _regexPattern)).test(newValue2);
      };
      if (!((_a = this.opts.pasteTransformer) == null ? void 0 : _a.current) && (!__privateGet(this, _initialLoad).isIOS || !e.clipboardData || !input)) {
        const newValue2 = getNewValue((_b = e.clipboardData) == null ? void 0 : _b.getData("text/plain"));
        if (isValueInvalid(newValue2)) {
          e.preventDefault();
        }
        return;
      }
      const _content = ((_c = e.clipboardData) == null ? void 0 : _c.getData("text/plain")) ?? "";
      const content = ((_d = this.opts.pasteTransformer) == null ? void 0 : _d.current) ? this.opts.pasteTransformer.current(_content) : _content;
      e.preventDefault();
      const newValue = getNewValue(content);
      if (isValueInvalid(newValue)) return;
      input.value = newValue;
      this.opts.value.current = newValue;
      const selStart = Math.min(newValue.length, this.opts.maxLength.current - 1);
      const selEnd = newValue.length;
      input.setSelectionRange(selStart, selEnd);
      set(__privateGet(this, _mirrorSelectionStart), selStart, true);
      set(__privateGet(this, _mirrorSelectionEnd), selEnd, true);
    });
    __publicField(this, "onmouseover", (_) => {
      set(__privateGet(this, _isHoveringInput), true);
    });
    __publicField(this, "onmouseleave", (_) => {
      set(__privateGet(this, _isHoveringInput), false);
    });
    __publicField(this, "onblur", (_) => {
      if (get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur) {
        get(__privateGet(this, _prevInputMetadata)).willSyntheticBlur = false;
        return;
      }
      __privateGet(this, _isFocused3).current = false;
    });
    __privateAdd(this, _inputProps, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.inputId.current,
          style: get(__privateGet(this, _inputStyle)),
          autocomplete: this.opts.autocomplete.current || "one-time-code",
          "data-pin-input-input": "",
          "data-pin-input-input-mss": get(__privateGet(this, _mirrorSelectionStart)),
          "data-pin-input-input-mse": get(__privateGet(this, _mirrorSelectionEnd)),
          inputmode: this.opts.inputmode.current,
          pattern: (_a = get(__privateGet(this, _regexPattern))) == null ? void 0 : _a.source,
          maxlength: this.opts.maxLength.current,
          value: this.opts.value.current,
          disabled: getDisabled(this.opts.disabled.current),
          //
          onpaste: this.onpaste,
          oninput: this.oninput,
          onkeydown: this.onkeydown,
          onmouseover: this.onmouseover,
          onmouseleave: this.onmouseleave,
          onfocus: this.onfocus,
          onblur: this.onblur,
          ...this.inputAttachment
        };
      }),
      "PinInputRootState.inputProps"
    ));
    __privateAdd(this, _cells, tag(
      user_derived(() => Array.from({ length: this.opts.maxLength.current }).map((_, idx) => {
        const isActive = __privateGet(this, _isFocused3).current && strict_equals(get(__privateGet(this, _mirrorSelectionStart)), null, false) && strict_equals(get(__privateGet(this, _mirrorSelectionEnd)), null, false) && (strict_equals(get(__privateGet(this, _mirrorSelectionStart)), get(__privateGet(this, _mirrorSelectionEnd))) && strict_equals(idx, get(__privateGet(this, _mirrorSelectionStart))) || idx >= get(__privateGet(this, _mirrorSelectionStart)) && idx < get(__privateGet(this, _mirrorSelectionEnd)));
        const char = strict_equals(this.opts.value.current[idx], void 0, false) ? this.opts.value.current[idx] : null;
        return {
          char,
          isActive,
          hasFakeCaret: isActive && strict_equals(char, null)
        };
      })),
      "PinInputRootState.#cells"
    ));
    __privateAdd(this, _snippetProps20, tag(
      user_derived(() => ({
        cells: get(__privateGet(this, _cells)),
        isFocused: __privateGet(this, _isFocused3).current,
        isHovering: get(__privateGet(this, _isHoveringInput))
      })),
      "PinInputRootState.snippetProps"
    ));
    var _a;
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    __privateSet(this, _initialLoad, {
      value: this.opts.value,
      isIOS: strict_equals(typeof window, "undefined", false) && ((_a = window == null ? void 0 : window.CSS) == null ? void 0 : _a.supports("-webkit-touch-callout", "none"))
    });
    __privateSet(this, _pwmb, usePasswordManagerBadge({
      containerRef: this.opts.ref,
      inputRef: __privateGet(this, _inputRef),
      isFocused: __privateGet(this, _isFocused3),
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    }));
    onMount(() => {
      const input = __privateGet(this, _inputRef).current;
      const container = this.opts.ref.current;
      if (!input || !container) return;
      if (strict_equals(__privateGet(this, _initialLoad).value.current, input.value, false)) {
        this.opts.value.current = input.value;
      }
      get(__privateGet(this, _prevInputMetadata)).prev = [
        input.selectionStart,
        input.selectionEnd,
        input.selectionDirection ?? "none"
      ];
      const unsub = on(this.domContext.getDocument(), "selectionchange", __privateGet(this, _onDocumentSelectionChange), { capture: true });
      __privateGet(this, _onDocumentSelectionChange).call(this);
      if (strict_equals(this.domContext.getActiveElement(), input)) {
        __privateGet(this, _isFocused3).current = true;
      }
      if (!this.domContext.getElementById("pin-input-style")) {
        __privateMethod(this, _PinInputRootState_instances, applyStyles_fn).call(this);
      }
      const updateRootHeight = () => {
        if (container) {
          container.style.setProperty("--bits-pin-input-root-height", `${input.clientHeight}px`);
        }
      };
      updateRootHeight();
      const resizeObserver = new ResizeObserver(updateRootHeight);
      resizeObserver.observe(input);
      return () => {
        unsub();
        resizeObserver.disconnect();
      };
    });
    watch(
      [
        () => this.opts.value.current,
        () => __privateGet(this, _inputRef).current
      ],
      () => {
        syncTimeouts(
          () => {
            const input = __privateGet(this, _inputRef).current;
            if (!input) return;
            input.dispatchEvent(new Event("input"));
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const dir = input.selectionDirection ?? "none";
            if (strict_equals(start, null, false) && strict_equals(end, null, false)) {
              set(__privateGet(this, _mirrorSelectionStart), start, true);
              set(__privateGet(this, _mirrorSelectionEnd), end, true);
              get(__privateGet(this, _prevInputMetadata)).prev = [start, end, dir];
            }
          },
          this.domContext
        );
      }
    );
    user_effect(() => {
      const value = this.opts.value.current;
      const prevValue = __privateGet(this, _previousValue).current;
      const maxLength = this.opts.maxLength.current;
      const onComplete = this.opts.onComplete.current;
      if (strict_equals(prevValue, void 0)) return;
      if (strict_equals(value, prevValue, false) && prevValue.length < maxLength && strict_equals(value.length, maxLength)) {
        onComplete(value);
      }
    });
  }
  static create(opts) {
    return new _PinInputRootState(opts);
  }
  get rootProps() {
    return get(__privateGet(this, _rootProps));
  }
  set rootProps(value) {
    set(__privateGet(this, _rootProps), value);
  }
  get inputWrapperProps() {
    return get(__privateGet(this, _inputWrapperProps));
  }
  set inputWrapperProps(value) {
    set(__privateGet(this, _inputWrapperProps), value);
  }
  get inputProps() {
    return get(__privateGet(this, _inputProps));
  }
  set inputProps(value) {
    set(__privateGet(this, _inputProps), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps20));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps20), value);
  }
};
_inputRef = new WeakMap();
_isHoveringInput = new WeakMap();
_isFocused3 = new WeakMap();
_mirrorSelectionStart = new WeakMap();
_mirrorSelectionEnd = new WeakMap();
_previousValue = new WeakMap();
_regexPattern = new WeakMap();
_prevInputMetadata = new WeakMap();
_pwmb = new WeakMap();
_initialLoad = new WeakMap();
_rootStyles = new WeakMap();
_rootProps = new WeakMap();
_inputWrapperProps = new WeakMap();
_inputStyle = new WeakMap();
_PinInputRootState_instances = new WeakSet();
applyStyles_fn = function() {
  const doc = this.domContext.getDocument();
  const styleEl = doc.createElement("style");
  styleEl.id = "pin-input-style";
  doc.head.appendChild(styleEl);
  if (styleEl.sheet) {
    const autoFillStyles = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
    safeInsertRule(styleEl.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }");
    safeInsertRule(styleEl.sheet, `[data-pin-input-input]:autofill { ${autoFillStyles} }`);
    safeInsertRule(styleEl.sheet, `[data-pin-input-input]:-webkit-autofill { ${autoFillStyles} }`);
    safeInsertRule(styleEl.sheet, `@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`);
    safeInsertRule(styleEl.sheet, `[data-pin-input-input] + * { pointer-events: all !important; }`);
  }
};
_onDocumentSelectionChange = new WeakMap();
_inputProps = new WeakMap();
_cells = new WeakMap();
_snippetProps20 = new WeakMap();
var PinInputRootState = _PinInputRootState;
var _props102;
var _PinInputCellState = class _PinInputCellState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props102, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [pinInputAttrs.cell]: "",
        "data-active": this.opts.cell.current.isActive ? "" : void 0,
        "data-inactive": !this.opts.cell.current.isActive ? "" : void 0,
        ...this.attachment
      })),
      "PinInputCellState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _PinInputCellState(opts);
  }
  get props() {
    return get(__privateGet(this, _props102));
  }
  set props(value) {
    set(__privateGet(this, _props102), value);
  }
};
_props102 = new WeakMap();
var PinInputCellState = _PinInputCellState;
function syncTimeouts(cb, domContext) {
  const t1 = domContext.setTimeout(cb, 0);
  const t2 = domContext.setTimeout(cb, 10);
  const t3 = domContext.setTimeout(cb, 50);
  return [t1, t2, t3];
}
function safeInsertRule(sheet, rule) {
  try {
    sheet.insertRule(rule);
  } catch {
    console.error(...log_if_contains_state("error", "pin input could not insert CSS rule:", rule));
  }
}

// node_modules/bits-ui/dist/internal/use-arrow-navigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)) {
    return null;
  }
  const { arrowKeyOptions = "both", candidateSelector: attributeName, itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical))
    return null;
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item == null ? void 0 : item.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, { goForward, loop }, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index = elements.indexOf(currentElement);
  const newIndex = goForward ? index + 1 : index - 1;
  if (!loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(elements, candidate, { goForward, loop }, iterations);
  }
  return candidate;
}

// node_modules/bits-ui/dist/internal/svelte-resize-observer.svelte.js
var _node2, _onResize;
var SvelteResizeObserver = class {
  constructor(node, onResize) {
    __privateAdd(this, _node2);
    __privateAdd(this, _onResize);
    __privateSet(this, _node2, node);
    __privateSet(this, _onResize, onResize);
    this.handler = this.handler.bind(this);
    user_effect(this.handler);
  }
  handler() {
    let rAF = 0;
    const _node3 = __privateGet(this, _node2).call(this);
    if (!_node3) return;
    const resizeObserver = new ResizeObserver(() => {
      cancelAnimationFrame(rAF);
      rAF = window.requestAnimationFrame(__privateGet(this, _onResize));
    });
    resizeObserver.observe(_node3);
    return () => {
      window.cancelAnimationFrame(rAF);
      resizeObserver.unobserve(_node3);
    };
  }
};
_node2 = new WeakMap();
_onResize = new WeakMap();

// node_modules/bits-ui/dist/bits/navigation-menu/navigation-menu.svelte.js
var navigationMenuAttrs = createBitsAttrs({
  component: "navigation-menu",
  parts: [
    "root",
    "sub",
    "item",
    "list",
    "trigger",
    "content",
    "link",
    "viewport",
    "menu",
    "indicator"
  ]
});
var NavigationMenuProviderContext = new Context("NavigationMenu.Root");
var NavigationMenuItemContext = new Context("NavigationMenu.Item");
var NavigationMenuListContext = new Context("NavigationMenu.List");
var NavigationMenuContentContext = new Context("NavigationMenu.Content");
var NavigationMenuSubContext = new Context("NavigationMenu.Sub");
var NavigationMenuProviderState = class _NavigationMenuProviderState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "indicatorTrackRef", box(null));
    __publicField(this, "viewportRef", box(null));
    __publicField(this, "viewportContent", new SvelteMap());
    __publicField(this, "onTriggerEnter");
    __publicField(this, "onTriggerLeave", noop3);
    __publicField(this, "onContentEnter", noop3);
    __publicField(this, "onContentLeave", noop3);
    __publicField(this, "onItemSelect");
    __publicField(this, "onItemDismiss");
    __publicField(this, "activeItem", null);
    __publicField(this, "prevActiveItem", null);
    __publicField(this, "setActiveItem", (item) => {
      this.prevActiveItem = this.activeItem;
      this.activeItem = item;
    });
    this.opts = opts;
    this.onTriggerEnter = opts.onTriggerEnter;
    this.onTriggerLeave = opts.onTriggerLeave ?? noop3;
    this.onContentEnter = opts.onContentEnter ?? noop3;
    this.onContentLeave = opts.onContentLeave ?? noop3;
    this.onItemDismiss = opts.onItemDismiss;
    this.onItemSelect = opts.onItemSelect;
  }
  static create(opts) {
    return NavigationMenuProviderContext.set(new _NavigationMenuProviderState(opts));
  }
};
var _derivedDelay, _debouncedFn, _onTriggerEnter, _onTriggerLeave, _onContentEnter, _onContentLeave, _onItemSelect, _onItemDismiss, _props103;
var _NavigationMenuRootState = class _NavigationMenuRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "provider");
    __publicField(this, "previousValue", box(""));
    __publicField(this, "isDelaySkipped");
    __privateAdd(this, _derivedDelay, tag(
      user_derived(() => {
        var _a, _b;
        const isOpen = strict_equals((_b = (_a = this.opts) == null ? void 0 : _a.value) == null ? void 0 : _b.current, "", false);
        if (isOpen || this.isDelaySkipped.current) {
          return 100;
        } else {
          return this.opts.delayDuration.current;
        }
      }),
      "NavigationMenuRootState.#derivedDelay"
    ));
    __privateAdd(this, _debouncedFn, useDebounce(
      (val, itemState) => {
        if (strict_equals(typeof val, "string")) {
          this.setValue(val, itemState);
        }
      },
      () => get(__privateGet(this, _derivedDelay))
    ));
    __privateAdd(this, _onTriggerEnter, (itemValue, itemState) => {
      __privateGet(this, _debouncedFn).call(this, itemValue, itemState);
    });
    __privateAdd(this, _onTriggerLeave, () => {
      this.isDelaySkipped.current = false;
      __privateGet(this, _debouncedFn).call(this, "", null);
    });
    __privateAdd(this, _onContentEnter, () => {
      __privateGet(this, _debouncedFn).call(this, void 0, null);
    });
    __privateAdd(this, _onContentLeave, () => {
      if (this.provider.activeItem && strict_equals(this.provider.activeItem.opts.openOnHover.current, false)) {
        return;
      }
      __privateGet(this, _debouncedFn).call(this, "", null);
    });
    __privateAdd(this, _onItemSelect, (itemValue, itemState) => {
      this.setValue(itemValue, itemState);
    });
    __privateAdd(this, _onItemDismiss, () => {
      this.setValue("", null);
    });
    __publicField(this, "setValue", (newValue, itemState) => {
      this.previousValue.current = this.opts.value.current;
      this.opts.value.current = newValue;
      this.provider.setActiveItem(itemState);
      if (strict_equals(newValue, "")) {
        this.previousValue.current = "";
      }
    });
    __privateAdd(this, _props103, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        dir: this.opts.dir.current,
        [navigationMenuAttrs.root]: "",
        [navigationMenuAttrs.menu]: "",
        ...this.attachment
      })),
      "NavigationMenuRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.isDelaySkipped = boxAutoReset(false, {
      afterMs: this.opts.skipDelayDuration.current,
      getWindow: () => getWindow(opts.ref.current)
    });
    this.provider = NavigationMenuProviderState.create({
      value: this.opts.value,
      previousValue: this.previousValue,
      dir: this.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      isRootMenu: true,
      onTriggerEnter: (itemValue, itemState) => {
        __privateGet(this, _onTriggerEnter).call(this, itemValue, itemState);
      },
      onTriggerLeave: __privateGet(this, _onTriggerLeave),
      onContentEnter: __privateGet(this, _onContentEnter),
      onContentLeave: __privateGet(this, _onContentLeave),
      onItemSelect: __privateGet(this, _onItemSelect),
      onItemDismiss: __privateGet(this, _onItemDismiss)
    });
  }
  static create(opts) {
    return new _NavigationMenuRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props103));
  }
  set props(value) {
    set(__privateGet(this, _props103), value);
  }
};
_derivedDelay = new WeakMap();
_debouncedFn = new WeakMap();
_onTriggerEnter = new WeakMap();
_onTriggerLeave = new WeakMap();
_onContentEnter = new WeakMap();
_onContentLeave = new WeakMap();
_onItemSelect = new WeakMap();
_onItemDismiss = new WeakMap();
_props103 = new WeakMap();
var NavigationMenuRootState = _NavigationMenuRootState;
var _props104;
var _NavigationMenuSubState = class _NavigationMenuSubState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "previousValue", box(""));
    __publicField(this, "subProvider");
    __publicField(this, "attachment");
    __publicField(this, "setValue", (newValue, itemState) => {
      this.previousValue.current = this.opts.value.current;
      this.opts.value.current = newValue;
      this.subProvider.setActiveItem(itemState);
      if (strict_equals(newValue, "")) {
        this.previousValue.current = "";
      }
    });
    __privateAdd(this, _props104, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        [navigationMenuAttrs.sub]: "",
        [navigationMenuAttrs.menu]: "",
        ...this.attachment
      })),
      "NavigationMenuSubState.props"
    ));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.subProvider = NavigationMenuProviderState.create({
      isRootMenu: false,
      value: this.opts.value,
      dir: this.context.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      onTriggerEnter: this.setValue,
      onItemSelect: this.setValue,
      onItemDismiss: () => this.setValue("", null),
      previousValue: this.previousValue
    });
  }
  static create(opts) {
    return new _NavigationMenuSubState(opts, NavigationMenuProviderContext.get());
  }
  get props() {
    return get(__privateGet(this, _props104));
  }
  set props(value) {
    set(__privateGet(this, _props104), value);
  }
};
_props104 = new WeakMap();
var NavigationMenuSubState = _NavigationMenuSubState;
var _listTriggers, _wrapperMounted, _wrapperProps2, _props105;
var _NavigationMenuListState = class _NavigationMenuListState {
  constructor(opts, context) {
    __publicField(this, "wrapperId", box(useId()));
    __publicField(this, "wrapperRef", box(null));
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __publicField(this, "wrapperAttachment", attachRef(this.wrapperRef, (v) => this.context.indicatorTrackRef.current = v));
    __privateAdd(this, _listTriggers, tag(state([]), "NavigationMenuListState.listTriggers"));
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _wrapperMounted, tag(state(false), "NavigationMenuListState.wrapperMounted"));
    __privateAdd(this, _wrapperProps2, tag(
      user_derived(() => ({
        id: this.wrapperId.current,
        ...this.wrapperAttachment
      })),
      "NavigationMenuListState.wrapperProps"
    ));
    __privateAdd(this, _props105, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.context.opts.orientation.current),
        [navigationMenuAttrs.list]: "",
        ...this.attachment
      })),
      "NavigationMenuListState.props"
    ));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: opts.ref,
      candidateSelector: `${navigationMenuAttrs.selector("trigger")}:not([data-disabled]), ${navigationMenuAttrs.selector("link")}:not([data-disabled])`,
      loop: box.with(() => false),
      orientation: this.context.opts.orientation
    });
  }
  static create(opts) {
    return NavigationMenuListContext.set(new _NavigationMenuListState(opts, NavigationMenuProviderContext.get()));
  }
  get listTriggers() {
    return get(__privateGet(this, _listTriggers));
  }
  set listTriggers(value) {
    set(__privateGet(this, _listTriggers), value);
  }
  get wrapperMounted() {
    return get(__privateGet(this, _wrapperMounted));
  }
  set wrapperMounted(value) {
    set(__privateGet(this, _wrapperMounted), value, true);
  }
  registerTrigger(trigger) {
    if (trigger) this.listTriggers.push(trigger);
    return () => {
      this.listTriggers = this.listTriggers.filter((t) => strict_equals(t.id, trigger.id, false));
    };
  }
  get wrapperProps() {
    return get(__privateGet(this, _wrapperProps2));
  }
  set wrapperProps(value) {
    set(__privateGet(this, _wrapperProps2), value);
  }
  get props() {
    return get(__privateGet(this, _props105));
  }
  set props(value) {
    set(__privateGet(this, _props105), value);
  }
};
_listTriggers = new WeakMap();
_wrapperMounted = new WeakMap();
_wrapperProps2 = new WeakMap();
_props105 = new WeakMap();
var NavigationMenuListState = _NavigationMenuListState;
var _contentNode8, _triggerNode7, _focusProxyNode, _contentId4, _triggerId3, _handleContentEntry, _handleContentExit, _props106;
var _NavigationMenuItemState = class _NavigationMenuItemState {
  constructor(opts, listContext) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "listContext");
    __privateAdd(this, _contentNode8, tag(state(null), "NavigationMenuItemState.contentNode"));
    __privateAdd(this, _triggerNode7, tag(state(null), "NavigationMenuItemState.triggerNode"));
    __privateAdd(this, _focusProxyNode, tag(state(null), "NavigationMenuItemState.focusProxyNode"));
    __publicField(this, "restoreContentTabOrder", noop3);
    __publicField(this, "wasEscapeClose", false);
    __privateAdd(this, _contentId4, tag(user_derived(() => {
      var _a;
      return (_a = this.contentNode) == null ? void 0 : _a.id;
    }), "NavigationMenuItemState.contentId"));
    __privateAdd(this, _triggerId3, tag(user_derived(() => {
      var _a;
      return (_a = this.triggerNode) == null ? void 0 : _a.id;
    }), "NavigationMenuItemState.triggerId"));
    __publicField(this, "contentChildren", box(void 0));
    __publicField(this, "contentChild", box(void 0));
    __publicField(this, "contentProps", box({}));
    __publicField(this, "domContext");
    __privateAdd(this, _handleContentEntry, (side = "start") => {
      if (!this.contentNode) return;
      this.restoreContentTabOrder();
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) focusFirst2(strict_equals(side, "start") ? candidates : candidates.reverse(), () => this.domContext.getActiveElement());
    });
    __privateAdd(this, _handleContentExit, () => {
      if (!this.contentNode) return;
      const candidates = getTabbableCandidates(this.contentNode);
      if (candidates.length) this.restoreContentTabOrder = removeFromTabOrder(candidates);
    });
    __publicField(this, "onEntryKeydown", __privateGet(this, _handleContentEntry));
    __publicField(this, "onFocusProxyEnter", __privateGet(this, _handleContentEntry));
    __publicField(this, "onRootContentClose", __privateGet(this, _handleContentExit));
    __publicField(this, "onContentFocusOutside", __privateGet(this, _handleContentExit));
    __privateAdd(this, _props106, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [navigationMenuAttrs.item]: "",
        ...this.attachment
      })),
      "NavigationMenuItemState.props"
    ));
    this.opts = opts;
    this.listContext = listContext;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return NavigationMenuItemContext.set(new _NavigationMenuItemState(opts, NavigationMenuListContext.get()));
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode8));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode8), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode7));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode7), value, true);
  }
  get focusProxyNode() {
    return get(__privateGet(this, _focusProxyNode));
  }
  set focusProxyNode(value) {
    set(__privateGet(this, _focusProxyNode), value, true);
  }
  get contentId() {
    return get(__privateGet(this, _contentId4));
  }
  set contentId(value) {
    set(__privateGet(this, _contentId4), value);
  }
  get triggerId() {
    return get(__privateGet(this, _triggerId3));
  }
  set triggerId(value) {
    set(__privateGet(this, _triggerId3), value);
  }
  get props() {
    return get(__privateGet(this, _props106));
  }
  set props(value) {
    set(__privateGet(this, _props106), value);
  }
};
_contentNode8 = new WeakMap();
_triggerNode7 = new WeakMap();
_focusProxyNode = new WeakMap();
_contentId4 = new WeakMap();
_triggerId3 = new WeakMap();
_handleContentEntry = new WeakMap();
_handleContentExit = new WeakMap();
_props106 = new WeakMap();
var NavigationMenuItemState = _NavigationMenuItemState;
var _focusProxyMounted, _open3, _props107, _focusProxyProps;
var _NavigationMenuTriggerState = class _NavigationMenuTriggerState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "focusProxyId", box(useId()));
    __publicField(this, "focusProxyRef", box(null));
    __publicField(this, "focusProxyAttachment", attachRef(this.focusProxyRef, (v) => this.itemContext.focusProxyNode = v));
    __publicField(this, "context");
    __publicField(this, "itemContext");
    __publicField(this, "listContext");
    __publicField(this, "hasPointerMoveOpened", box(false));
    __publicField(this, "wasClickClose", false);
    __privateAdd(this, _focusProxyMounted, tag(state(false), "NavigationMenuTriggerState.focusProxyMounted"));
    __privateAdd(this, _open3, tag(user_derived(() => strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current)), "NavigationMenuTriggerState.open"));
    __publicField(this, "onpointerenter", (_) => {
      this.wasClickClose = false;
      this.itemContext.wasEscapeClose = false;
    });
    __publicField(this, "onpointermove", whenMouse(() => {
      if (this.opts.disabled.current || this.wasClickClose || this.itemContext.wasEscapeClose || this.hasPointerMoveOpened.current || !this.itemContext.opts.openOnHover.current) {
        return;
      }
      this.context.onTriggerEnter(this.itemContext.opts.value.current, this.itemContext);
      this.hasPointerMoveOpened.current = true;
    }));
    __publicField(this, "onpointerleave", whenMouse(() => {
      if (this.opts.disabled.current || !this.itemContext.opts.openOnHover.current) return;
      this.context.onTriggerLeave();
      this.hasPointerMoveOpened.current = false;
    }));
    __publicField(this, "onclick", () => {
      if (this.hasPointerMoveOpened.current) return;
      const shouldClose = this.open && (!this.itemContext.opts.openOnHover.current || this.context.opts.isRootMenu);
      if (shouldClose) {
        this.context.onItemSelect("", null);
      } else if (!this.open) {
        this.context.onItemSelect(this.itemContext.opts.value.current, this.itemContext);
      }
      this.wasClickClose = shouldClose;
    });
    __publicField(this, "onkeydown", (e) => {
      const verticalEntryKey = strict_equals(this.context.opts.dir.current, "rtl") ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT;
      const entryKey = {
        horizontal: kbd_constants_exports.ARROW_DOWN,
        vertical: verticalEntryKey
      }[this.context.opts.orientation.current];
      if (this.open && strict_equals(e.key, entryKey)) {
        this.itemContext.onEntryKeydown();
        e.preventDefault();
        return;
      }
      this.itemContext.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    });
    __publicField(this, "focusProxyOnFocus", (e) => {
      const content = this.itemContext.contentNode;
      const prevFocusedElement = e.relatedTarget;
      const wasTriggerFocused = this.opts.ref.current && strict_equals(prevFocusedElement, this.opts.ref.current);
      const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
      if (wasTriggerFocused || !wasFocusFromContent) {
        this.itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
      }
    });
    __privateAdd(this, _props107, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: this.opts.disabled.current,
        "data-disabled": getDataDisabled(Boolean(this.opts.disabled.current)),
        "data-state": getDataOpenClosed(this.open),
        "data-value": this.itemContext.opts.value.current,
        "aria-expanded": getAriaExpanded(this.open),
        "aria-controls": this.itemContext.contentId,
        [navigationMenuAttrs.trigger]: "",
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        onpointerenter: this.onpointerenter,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "NavigationMenuTriggerState.props"
    ));
    __privateAdd(this, _focusProxyProps, tag(
      user_derived(() => ({
        id: this.focusProxyId.current,
        tabindex: 0,
        onfocus: this.focusProxyOnFocus,
        ...this.focusProxyAttachment
      })),
      "NavigationMenuTriggerState.focusProxyProps"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.triggerNode = v);
    this.hasPointerMoveOpened = boxAutoReset(false, {
      afterMs: 300,
      getWindow: () => getWindow(opts.ref.current)
    });
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (!node) return;
      return this.listContext.registerTrigger(node);
    });
  }
  static create(opts) {
    return new _NavigationMenuTriggerState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get(),
      sub: NavigationMenuSubContext.getOr(null)
    });
  }
  get focusProxyMounted() {
    return get(__privateGet(this, _focusProxyMounted));
  }
  set focusProxyMounted(value) {
    set(__privateGet(this, _focusProxyMounted), value, true);
  }
  get open() {
    return get(__privateGet(this, _open3));
  }
  set open(value) {
    set(__privateGet(this, _open3), value);
  }
  get props() {
    return get(__privateGet(this, _props107));
  }
  set props(value) {
    set(__privateGet(this, _props107), value);
  }
  get focusProxyProps() {
    return get(__privateGet(this, _focusProxyProps));
  }
  set focusProxyProps(value) {
    set(__privateGet(this, _focusProxyProps), value);
  }
};
_focusProxyMounted = new WeakMap();
_open3 = new WeakMap();
_props107 = new WeakMap();
_focusProxyProps = new WeakMap();
var NavigationMenuTriggerState = _NavigationMenuTriggerState;
var LINK_SELECT_EVENT = new CustomEventDispatcher("bitsLinkSelect", { bubbles: true, cancelable: true });
var ROOT_CONTENT_DISMISS_EVENT = new CustomEventDispatcher("bitsRootContentDismiss", { cancelable: true, bubbles: true });
var _isFocused4, _handlePointerDismiss, _props108;
var _NavigationMenuLinkState = class _NavigationMenuLinkState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __privateAdd(this, _isFocused4, tag(state(false), "NavigationMenuLinkState.isFocused"));
    __publicField(this, "onclick", (e) => {
      const currTarget = e.currentTarget;
      LINK_SELECT_EVENT.listen(currTarget, (e2) => this.opts.onSelect.current(e2), { once: true });
      const linkSelectEvent = LINK_SELECT_EVENT.dispatch(currTarget);
      if (!linkSelectEvent.defaultPrevented && !e.metaKey) {
        ROOT_CONTENT_DISMISS_EVENT.dispatch(currTarget);
      }
    });
    __publicField(this, "onkeydown", (e) => {
      if (this.context.item.contentNode) return;
      this.context.item.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
    });
    __publicField(this, "onfocus", (_) => {
      this.isFocused = true;
    });
    __publicField(this, "onblur", (_) => {
      this.isFocused = false;
    });
    __privateAdd(this, _handlePointerDismiss, () => {
      const currentlyOpenValue = this.context.provider.opts.value.current;
      const isInsideOpenSubmenu = strict_equals(this.context.item.opts.value.current, currentlyOpenValue);
      const activeItem = this.context.item.listContext.context.activeItem;
      if (activeItem && !activeItem.opts.openOnHover.current) return;
      if (currentlyOpenValue && !isInsideOpenSubmenu) {
        this.context.provider.onItemDismiss();
      }
    });
    __publicField(this, "onpointerenter", () => {
      __privateGet(this, _handlePointerDismiss).call(this);
    });
    __publicField(this, "onpointermove", whenMouse(() => {
      __privateGet(this, _handlePointerDismiss).call(this);
    }));
    __privateAdd(this, _props108, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-active": this.opts.active.current ? "" : void 0,
        "aria-current": this.opts.active.current ? "page" : void 0,
        "data-focused": this.isFocused ? "" : void 0,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        onfocus: this.onfocus,
        onblur: this.onblur,
        onpointerenter: this.onpointerenter,
        onpointermove: this.onpointermove,
        [navigationMenuAttrs.link]: "",
        ...this.attachment
      })),
      "NavigationMenuLinkState.props"
    ));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _NavigationMenuLinkState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get()
    });
  }
  get isFocused() {
    return get(__privateGet(this, _isFocused4));
  }
  set isFocused(value) {
    set(__privateGet(this, _isFocused4), value, true);
  }
  get props() {
    return get(__privateGet(this, _props108));
  }
  set props(value) {
    set(__privateGet(this, _props108), value);
  }
};
_isFocused4 = new WeakMap();
_handlePointerDismiss = new WeakMap();
_props108 = new WeakMap();
var NavigationMenuLinkState = _NavigationMenuLinkState;
var _isVisible;
var _NavigationMenuIndicatorState = class _NavigationMenuIndicatorState {
  constructor(context) {
    __publicField(this, "context");
    __privateAdd(this, _isVisible, tag(user_derived(() => Boolean(this.context.opts.value.current)), "NavigationMenuIndicatorState.isVisible"));
    this.context = context;
  }
  static create() {
    return new _NavigationMenuIndicatorState(NavigationMenuProviderContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible), value);
  }
};
_isVisible = new WeakMap();
var NavigationMenuIndicatorState = _NavigationMenuIndicatorState;
var _position, _isHorizontal, _isVisible2, _activeTrigger, _shouldRender8, _props109;
var _NavigationMenuIndicatorImplState = class _NavigationMenuIndicatorImplState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "context");
    __publicField(this, "listContext");
    __privateAdd(this, _position, tag(state(null), "NavigationMenuIndicatorImplState.position"));
    __privateAdd(this, _isHorizontal, tag(user_derived(() => strict_equals(this.context.opts.orientation.current, "horizontal")), "NavigationMenuIndicatorImplState.isHorizontal"));
    __privateAdd(this, _isVisible2, tag(user_derived(() => !!this.context.opts.value.current), "NavigationMenuIndicatorImplState.isVisible"));
    __privateAdd(this, _activeTrigger, tag(
      user_derived(() => {
        const items = this.listContext.listTriggers;
        const triggerNode = items.find((item) => strict_equals(item.getAttribute("data-value"), this.context.opts.value.current));
        return triggerNode ?? null;
      }),
      "NavigationMenuIndicatorImplState.activeTrigger"
    ));
    __privateAdd(this, _shouldRender8, tag(user_derived(() => strict_equals(this.position, null, false)), "NavigationMenuIndicatorImplState.shouldRender"));
    __publicField(this, "handlePositionChange", () => {
      if (!this.activeTrigger) return;
      this.position = {
        size: this.isHorizontal ? this.activeTrigger.offsetWidth : this.activeTrigger.offsetHeight,
        offset: this.isHorizontal ? this.activeTrigger.offsetLeft : this.activeTrigger.offsetTop
      };
    });
    __privateAdd(this, _props109, tag(
      user_derived(() => {
        var _a, _b, _c, _d;
        return {
          id: this.opts.id.current,
          "data-state": this.isVisible ? "visible" : "hidden",
          "data-orientation": getDataOrientation(this.context.opts.orientation.current),
          style: {
            position: "absolute",
            ...this.isHorizontal ? {
              left: 0,
              width: `${(_a = this.position) == null ? void 0 : _a.size}px`,
              transform: `translateX(${(_b = this.position) == null ? void 0 : _b.offset}px)`
            } : {
              top: 0,
              height: `${(_c = this.position) == null ? void 0 : _c.size}px`,
              transform: `translateY(${(_d = this.position) == null ? void 0 : _d.offset}px)`
            }
          },
          [navigationMenuAttrs.indicator]: "",
          ...this.attachment
        };
      }),
      "NavigationMenuIndicatorImplState.props"
    ));
    this.opts = opts;
    this.context = context.provider;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.activeTrigger, this.handlePositionChange);
    new SvelteResizeObserver(() => this.context.indicatorTrackRef.current, this.handlePositionChange);
  }
  static create(opts) {
    return new _NavigationMenuIndicatorImplState(opts, {
      provider: NavigationMenuProviderContext.get(),
      list: NavigationMenuListContext.get()
    });
  }
  get position() {
    return get(__privateGet(this, _position));
  }
  set position(value) {
    set(__privateGet(this, _position), value);
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal));
  }
  set isHorizontal(value) {
    set(__privateGet(this, _isHorizontal), value);
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible2));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible2), value);
  }
  get activeTrigger() {
    return get(__privateGet(this, _activeTrigger));
  }
  set activeTrigger(value) {
    set(__privateGet(this, _activeTrigger), value);
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender8));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender8), value);
  }
  get props() {
    return get(__privateGet(this, _props109));
  }
  set props(value) {
    set(__privateGet(this, _props109), value);
  }
};
_position = new WeakMap();
_isHorizontal = new WeakMap();
_isVisible2 = new WeakMap();
_activeTrigger = new WeakMap();
_shouldRender8 = new WeakMap();
_props109 = new WeakMap();
var NavigationMenuIndicatorImplState = _NavigationMenuIndicatorImplState;
var _mounted4, _open4, _value2, _isLastActiveValue, _props110;
var _NavigationMenuContentState = class _NavigationMenuContentState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "itemContext");
    __publicField(this, "listContext");
    __publicField(this, "attachment");
    __privateAdd(this, _mounted4, tag(state(false), "NavigationMenuContentState.mounted"));
    __privateAdd(this, _open4, tag(user_derived(() => strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current)), "NavigationMenuContentState.open"));
    __privateAdd(this, _value2, tag(user_derived(() => this.itemContext.opts.value.current), "NavigationMenuContentState.value"));
    __privateAdd(this, _isLastActiveValue, tag(
      user_derived(() => {
        if (this.context.viewportRef.current) {
          if (!this.context.opts.value.current && this.context.opts.previousValue.current) {
            return strict_equals(this.context.opts.previousValue.current, this.itemContext.opts.value.current);
          }
        }
        return false;
      }),
      "NavigationMenuContentState.isLastActiveValue"
    ));
    __publicField(this, "onpointerenter", (_) => {
      this.context.onContentEnter();
    });
    __publicField(this, "onpointerleave", whenMouse(() => {
      if (!this.itemContext.opts.openOnHover.current) return;
      this.context.onContentLeave();
    }));
    __privateAdd(this, _props110, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        onpointerenter: this.onpointerenter,
        onpointerleave: this.onpointerleave,
        ...this.attachment
      })),
      "NavigationMenuContentState.props"
    ));
    this.opts = opts;
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.contentNode = v);
  }
  static create(opts) {
    return NavigationMenuContentContext.set(new _NavigationMenuContentState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get()
    }));
  }
  get mounted() {
    return get(__privateGet(this, _mounted4));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted4), value, true);
  }
  get open() {
    return get(__privateGet(this, _open4));
  }
  set open(value) {
    set(__privateGet(this, _open4), value);
  }
  get value() {
    return get(__privateGet(this, _value2));
  }
  set value(value) {
    set(__privateGet(this, _value2), value);
  }
  get isLastActiveValue() {
    return get(__privateGet(this, _isLastActiveValue));
  }
  set isLastActiveValue(value) {
    set(__privateGet(this, _isLastActiveValue), value);
  }
  get props() {
    return get(__privateGet(this, _props110));
  }
  set props(value) {
    set(__privateGet(this, _props110), value);
  }
};
_mounted4 = new WeakMap();
_open4 = new WeakMap();
_value2 = new WeakMap();
_isLastActiveValue = new WeakMap();
_props110 = new WeakMap();
var NavigationMenuContentState = _NavigationMenuContentState;
var _prevMotionAttribute, _motionAttribute, _props111;
var _NavigationMenuContentImplState = class _NavigationMenuContentImplState {
  constructor(opts, itemContext) {
    __publicField(this, "opts");
    __publicField(this, "itemContext");
    __publicField(this, "context");
    __publicField(this, "listContext");
    __publicField(this, "attachment");
    __privateAdd(this, _prevMotionAttribute, tag(state(null), "NavigationMenuContentImplState.prevMotionAttribute"));
    __privateAdd(this, _motionAttribute, tag(
      user_derived(() => {
        const items = this.listContext.listTriggers;
        const values = items.map((item) => item.getAttribute("data-value")).filter(Boolean);
        if (strict_equals(this.context.opts.dir.current, "rtl")) values.reverse();
        const index = values.indexOf(this.context.opts.value.current);
        const prevIndex = values.indexOf(this.context.opts.previousValue.current);
        const isSelected = strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current);
        const wasSelected = strict_equals(prevIndex, values.indexOf(this.itemContext.opts.value.current));
        if (!this.context.opts.value.current && !this.context.opts.previousValue.current) {
          untrack(() => this.prevMotionAttribute = null);
          return null;
        }
        if (!isSelected && !wasSelected) return untrack(() => this.prevMotionAttribute);
        const attribute = (() => {
          if (strict_equals(index, prevIndex, false)) {
            if (isSelected && strict_equals(prevIndex, -1, false)) return index > prevIndex ? "from-end" : "from-start";
            if (wasSelected && strict_equals(index, -1, false)) return index > prevIndex ? "to-start" : "to-end";
          }
          return null;
        })();
        untrack(() => this.prevMotionAttribute = attribute);
        return attribute;
      }),
      "NavigationMenuContentImplState.motionAttribute"
    ));
    __publicField(this, "domContext");
    __publicField(this, "onFocusOutside", (e) => {
      var _a;
      this.itemContext.onContentFocusOutside();
      const target = e.target;
      if ((_a = this.context.opts.rootNavigationMenuRef.current) == null ? void 0 : _a.contains(target)) {
        e.preventDefault();
        return;
      }
      this.context.onItemDismiss();
    });
    __publicField(this, "onInteractOutside", (e) => {
      var _a;
      const target = e.target;
      const isTrigger = this.listContext.listTriggers.some((trigger) => trigger.contains(target));
      const isRootViewport = this.context.opts.isRootMenu && ((_a = this.context.viewportRef.current) == null ? void 0 : _a.contains(target));
      if (!this.context.opts.isRootMenu && !isTrigger) {
        this.context.onItemDismiss();
        return;
      }
      if (isTrigger || isRootViewport) {
        e.preventDefault();
        return;
      }
      if (!this.itemContext.opts.openOnHover.current) {
        this.context.onItemSelect("", null);
      }
    });
    __publicField(this, "onkeydown", (e) => {
      const target = e.target;
      if (!isElement2(target)) return;
      if (strict_equals(target.closest(navigationMenuAttrs.selector("menu")), this.context.opts.rootNavigationMenuRef.current, false)) return;
      const isMetaKey = e.altKey || e.ctrlKey || e.metaKey;
      const isTabKey = strict_equals(e.key, kbd_constants_exports.TAB) && !isMetaKey;
      const candidates = getTabbableCandidates(e.currentTarget);
      if (isTabKey) {
        const focusedElement = this.domContext.getActiveElement();
        const index = candidates.findIndex((candidate) => strict_equals(candidate, focusedElement));
        const isMovingBackwards = e.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);
        if (focusFirst2(nextCandidates, () => this.domContext.getActiveElement())) {
          e.preventDefault();
          return;
        } else {
          handleProxyFocus(this.itemContext.focusProxyNode);
          return;
        }
      }
      let activeEl = this.domContext.getActiveElement();
      if (this.itemContext.contentNode) {
        const focusedNode = this.itemContext.contentNode.querySelector("[data-focused]");
        if (focusedNode) {
          activeEl = focusedNode;
        }
      }
      if (strict_equals(activeEl, this.itemContext.triggerNode)) return;
      const newSelectedElement = useArrowNavigation(e, activeEl, void 0, {
        itemsArray: candidates,
        candidateSelector: navigationMenuAttrs.selector("link"),
        loop: false,
        enableIgnoredElement: true
      });
      newSelectedElement == null ? void 0 : newSelectedElement.focus();
    });
    __publicField(this, "onEscapeKeydown", (_) => {
      var _a;
      this.context.onItemDismiss();
      (_a = this.itemContext.triggerNode) == null ? void 0 : _a.focus();
      this.itemContext.wasEscapeClose = true;
    });
    __privateAdd(this, _props111, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-labelledby": this.itemContext.triggerId,
        "data-motion": this.motionAttribute ?? void 0,
        "data-orientation": getDataOrientation(this.context.opts.orientation.current),
        "data-state": getDataOpenClosed(strict_equals(this.context.opts.value.current, this.itemContext.opts.value.current)),
        onkeydown: this.onkeydown,
        [navigationMenuAttrs.content]: "",
        ...this.attachment
      })),
      "NavigationMenuContentImplState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.itemContext = itemContext;
    this.listContext = itemContext.listContext;
    this.context = itemContext.listContext.context;
    this.domContext = new DOMContext(opts.ref);
    watch(
      [
        () => this.itemContext.opts.value.current,
        () => this.itemContext.triggerNode,
        () => this.opts.ref.current
      ],
      () => {
        const content = this.opts.ref.current;
        if (!(content && this.context.opts.isRootMenu)) return;
        const handleClose = () => {
          var _a;
          this.context.onItemDismiss();
          this.itemContext.onRootContentClose();
          if (content.contains(this.domContext.getActiveElement())) {
            (_a = this.itemContext.triggerNode) == null ? void 0 : _a.focus();
          }
        };
        const removeListener = ROOT_CONTENT_DISMISS_EVENT.listen(content, handleClose);
        return () => {
          removeListener();
        };
      }
    );
  }
  static create(opts, itemState) {
    return new _NavigationMenuContentImplState(opts, itemState ?? NavigationMenuItemContext.get());
  }
  get prevMotionAttribute() {
    return get(__privateGet(this, _prevMotionAttribute));
  }
  set prevMotionAttribute(value) {
    set(__privateGet(this, _prevMotionAttribute), value, true);
  }
  get motionAttribute() {
    return get(__privateGet(this, _motionAttribute));
  }
  set motionAttribute(value) {
    set(__privateGet(this, _motionAttribute), value);
  }
  get props() {
    return get(__privateGet(this, _props111));
  }
  set props(value) {
    set(__privateGet(this, _props111), value);
  }
};
_prevMotionAttribute = new WeakMap();
_motionAttribute = new WeakMap();
_props111 = new WeakMap();
var NavigationMenuContentImplState = _NavigationMenuContentImplState;
var _open5, _viewportWidth, _viewportHeight, _activeContentValue, _size2, _contentNode9, _mounted5, _props112;
var _NavigationMenuViewportState = class _NavigationMenuViewportState {
  constructor(opts, context) {
    __publicField(this, "opts");
    __publicField(this, "context");
    __publicField(this, "attachment");
    __privateAdd(this, _open5, tag(user_derived(() => !!this.context.opts.value.current), "NavigationMenuViewportState.open"));
    __privateAdd(this, _viewportWidth, tag(user_derived(() => this.size ? `${this.size.width}px` : void 0), "NavigationMenuViewportState.viewportWidth"));
    __privateAdd(this, _viewportHeight, tag(user_derived(() => this.size ? `${this.size.height}px` : void 0), "NavigationMenuViewportState.viewportHeight"));
    __privateAdd(this, _activeContentValue, tag(user_derived(() => this.context.opts.value.current), "NavigationMenuViewportState.activeContentValue"));
    __privateAdd(this, _size2, tag(state(null), "NavigationMenuViewportState.size"));
    __privateAdd(this, _contentNode9, tag(state(null), "NavigationMenuViewportState.contentNode"));
    __privateAdd(this, _mounted5, tag(state(false), "NavigationMenuViewportState.mounted"));
    __privateAdd(this, _props112, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": getDataOpenClosed(this.open),
        "data-orientation": getDataOrientation(this.context.opts.orientation.current),
        style: {
          pointerEvents: !this.open && this.context.opts.isRootMenu ? "none" : void 0,
          "--bits-navigation-menu-viewport-width": this.viewportWidth,
          "--bits-navigation-menu-viewport-height": this.viewportHeight
        },
        [navigationMenuAttrs.viewport]: "",
        onpointerenter: this.context.onContentEnter,
        onpointerleave: this.context.onContentLeave,
        ...this.attachment
      })),
      "NavigationMenuViewportState.props"
    ));
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref, (v) => this.context.viewportRef.current = v);
    watch(
      [
        () => this.activeContentValue,
        () => this.open
      ],
      () => {
        afterTick(() => {
          var _a, _b;
          const currNode = this.context.viewportRef.current;
          if (!currNode) return;
          const el = ((_b = (_a = currNode.querySelector("[data-state=open]")) == null ? void 0 : _a.children) == null ? void 0 : _b[0]) ?? null;
          this.contentNode = el;
        });
      }
    );
    new SvelteResizeObserver(() => this.contentNode, () => {
      if (this.contentNode) {
        this.size = {
          width: this.contentNode.offsetWidth,
          height: this.contentNode.offsetHeight
        };
      }
    });
    watch(() => this.mounted, () => {
      if (!this.mounted && this.size) {
        this.size = null;
      }
    });
  }
  static create(opts) {
    return new _NavigationMenuViewportState(opts, NavigationMenuProviderContext.get());
  }
  get open() {
    return get(__privateGet(this, _open5));
  }
  set open(value) {
    set(__privateGet(this, _open5), value);
  }
  get viewportWidth() {
    return get(__privateGet(this, _viewportWidth));
  }
  set viewportWidth(value) {
    set(__privateGet(this, _viewportWidth), value);
  }
  get viewportHeight() {
    return get(__privateGet(this, _viewportHeight));
  }
  set viewportHeight(value) {
    set(__privateGet(this, _viewportHeight), value);
  }
  get activeContentValue() {
    return get(__privateGet(this, _activeContentValue));
  }
  set activeContentValue(value) {
    set(__privateGet(this, _activeContentValue), value);
  }
  get size() {
    return get(__privateGet(this, _size2));
  }
  set size(value) {
    set(__privateGet(this, _size2), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode9));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode9), value, true);
  }
  get mounted() {
    return get(__privateGet(this, _mounted5));
  }
  set mounted(value) {
    set(__privateGet(this, _mounted5), value, true);
  }
  get props() {
    return get(__privateGet(this, _props112));
  }
  set props(value) {
    set(__privateGet(this, _props112), value);
  }
};
_open5 = new WeakMap();
_viewportWidth = new WeakMap();
_viewportHeight = new WeakMap();
_activeContentValue = new WeakMap();
_size2 = new WeakMap();
_contentNode9 = new WeakMap();
_mounted5 = new WeakMap();
_props112 = new WeakMap();
var NavigationMenuViewportState = _NavigationMenuViewportState;
function focusFirst2(candidates, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  return candidates.some((candidate) => {
    if (strict_equals(candidate, previouslyFocusedElement)) return true;
    candidate.focus();
    return strict_equals(getActiveElement3(), previouslyFocusedElement, false);
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function whenMouse(handler) {
  return (e) => strict_equals(e.pointerType, "mouse") ? handler(e) : void 0;
}
function handleProxyFocus(guard, focusOptions) {
  if (!guard) return;
  const ariaHidden = guard.getAttribute("aria-hidden");
  guard.removeAttribute("aria-hidden");
  guard.focus(focusOptions);
  afterSleep(0, () => {
    if (strict_equals(ariaHidden, null)) {
      guard.setAttribute("aria-hidden", "");
    } else {
      guard.setAttribute("aria-hidden", ariaHidden);
    }
  });
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte
Navigation_menu[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte";
var root_270 = add_locations(from_html(`<nav><!></nav>`), Navigation_menu[FILENAME], [[49, 1]]);
function Navigation_menu($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), delayDuration = prop($$props, "delayDuration", 3, 200), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300), dir = prop($$props, "dir", 3, "ltr"), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "delayDuration",
      "skipDelayDuration",
      "dir",
      "orientation"
    ],
    "restProps"
  );
  const rootState = NavigationMenuRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    delayDuration: box.with(() => delayDuration()),
    skipDelayDuration: box.with(() => skipDelayDuration()),
    dir: box.with(() => dir()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps({ "aria-label": "main" }, restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_270();
      attribute_effect(nav, () => ({ ...get(mergedProps) }));
      var node_2 = child(nav);
      snippet(node_2, () => $$props.children ?? noop);
      reset(nav);
      append($$anchor2, nav);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu = hmr(Navigation_menu, () => Navigation_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu[HMR].source;
    set(Navigation_menu[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_default = Navigation_menu;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content-impl.svelte
Navigation_menu_content_impl[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content-impl.svelte";
var root_419 = add_locations(from_html(`<div><!></div>`), Navigation_menu_content_impl[FILENAME], [[88, 4]]);
function Navigation_menu_content_impl($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_content_impl);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "onInteractOutside",
      "onFocusOutside",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "interactOutsideBehavior",
      "itemState",
      "onRefChange"
    ],
    "restProps"
  );
  const contentImplState = NavigationMenuContentImplState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => {
        ref(v);
        untrack(() => {
          var _a;
          return (_a = $$props.onRefChange) == null ? void 0 : _a.call($$props, v);
        });
      })
    },
    $$props.itemState
  );
  if ($$props.itemState) {
    NavigationMenuItemContext.set($$props.itemState);
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentImplState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Navigation_menu_content_impl, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let dismissibleProps = () => $$arg0 == null ? void 0 : $$arg0().props;
      dismissibleProps();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      escape_layer_default(node_1, {
        enabled: true,
        get ref() {
          return contentImplState.opts.ref;
        },
        onEscapeKeydown: (e) => {
          onEscapeKeydown()(e);
          if (e.defaultPrevented) return;
          contentImplState.onEscapeKeydown(e);
        },
        get escapeKeydownBehavior() {
          return escapeKeydownBehavior();
        },
        children: wrap_snippet(Navigation_menu_content_impl, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          const finalProps = user_derived(() => mergeProps(get(mergedProps), dismissibleProps()));
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              snippet(node_3, () => $$props.child, () => ({ props: get(finalProps) }));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_419();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    });
    dismissible_layer_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return contentImplState.opts.ref;
      },
      enabled: true,
      onInteractOutside: (e) => {
        onInteractOutside()(e);
        if (e.defaultPrevented) return;
        contentImplState.onInteractOutside(e);
      },
      onFocusOutside: (e) => {
        onFocusOutside()(e);
        if (e.defaultPrevented) return;
        contentImplState.onFocusOutside(e);
      },
      get interactOutsideBehavior() {
        return interactOutsideBehavior();
      },
      children,
      $$slots: { default: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_content_impl = hmr(Navigation_menu_content_impl, () => Navigation_menu_content_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_content_impl[HMR].source;
    set(Navigation_menu_content_impl[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_content_impl_default = Navigation_menu_content_impl;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte
Navigation_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte";
var root_271 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_content[FILENAME], []);
function Navigation_menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = NavigationMenuContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => contentState.context.viewportRef.current || void 0);
  const expression_1 = user_derived(() => !contentState.context.viewportRef.current);
  portal_default(node, {
    get to() {
      return get(expression);
    },
    get disabled() {
      return get(expression_1);
    },
    children: wrap_snippet(Navigation_menu_content, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      const expression_2 = user_derived(() => forceMount() || contentState.open || contentState.isLastActiveValue);
      {
        const presence = wrap_snippet(Navigation_menu_content, function($$anchor3) {
          validate_snippet_args(...arguments);
          var fragment_2 = root_271();
          var node_2 = first_child(fragment_2);
          navigation_menu_content_impl_default(node_2, spread_props(() => get(mergedProps), {
            get children() {
              return $$props.children;
            },
            get child() {
              return $$props.child;
            }
          }));
          var node_3 = sibling(node_2, 2);
          validate_binding("bind:mounted={contentState.mounted}", () => contentState, () => "mounted", 43, 12);
          mounted_default(node_3, {
            get mounted() {
              return contentState.mounted;
            },
            set mounted($$value) {
              contentState.mounted = $$value;
            }
          });
          append($$anchor3, fragment_2);
        });
        presence_layer_default(node_1, {
          get open() {
            return get(expression_2);
          },
          get ref() {
            return contentState.opts.ref;
          },
          presence,
          $$slots: { presence: true }
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_content = hmr(Navigation_menu_content, () => Navigation_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_content[HMR].source;
    set(Navigation_menu_content[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_content_default = Navigation_menu_content;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator-impl.svelte
Navigation_menu_indicator_impl[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator-impl.svelte";
var root_272 = add_locations(from_html(`<div><!></div>`), Navigation_menu_indicator_impl[FILENAME], [[31, 1]]);
function Navigation_menu_indicator_impl($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_indicator_impl);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const indicatorState = NavigationMenuIndicatorImplState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, indicatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_272();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_indicator_impl = hmr(Navigation_menu_indicator_impl, () => Navigation_menu_indicator_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_indicator_impl[HMR].source;
    set(Navigation_menu_indicator_impl[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_indicator_impl_default = Navigation_menu_indicator_impl;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte
Navigation_menu_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte";
function Navigation_menu_indicator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_indicator);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const indicatorState = NavigationMenuIndicatorState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      portal_default(node_1, {
        get to() {
          return indicatorState.context.indicatorTrackRef.current;
        },
        children: wrap_snippet(Navigation_menu_indicator, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          const expression = user_derived(() => forceMount() || indicatorState.isVisible);
          const expression_1 = user_derived(() => box.with(() => ref()));
          {
            const presence = wrap_snippet(Navigation_menu_indicator, function($$anchor4) {
              validate_snippet_args(...arguments);
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                $$ownership_validator.binding("ref", navigation_menu_indicator_impl_default, ref);
                navigation_menu_indicator_impl_default(node_3, spread_props(() => get(mergedProps), {
                  get children() {
                    return $$props.children;
                  },
                  get child() {
                    return $$props.child;
                  },
                  get id() {
                    return id();
                  },
                  get ref() {
                    return ref();
                  },
                  set ref($$value) {
                    ref($$value);
                  }
                }));
              }
              append($$anchor4, fragment_3);
            });
            presence_layer_default(node_2, {
              get open() {
                return get(expression);
              },
              get ref() {
                return get(expression_1);
              },
              presence,
              $$slots: { presence: true }
            });
          }
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (indicatorState.context.indicatorTrackRef.current) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_indicator = hmr(Navigation_menu_indicator, () => Navigation_menu_indicator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_indicator[HMR].source;
    set(Navigation_menu_indicator[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_indicator_default = Navigation_menu_indicator;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte
Navigation_menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte";
var root_273 = add_locations(from_html(`<li><!></li>`), Navigation_menu_item[FILENAME], [[36, 1]]);
function Navigation_menu_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_item);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), openOnHover = prop($$props, "openOnHover", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "value",
      "ref",
      "child",
      "children",
      "openOnHover"
    ],
    "restProps"
  );
  const itemState = NavigationMenuItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    openOnHover: box.with(() => openOnHover())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_273();
      attribute_effect(li, () => ({ ...get(mergedProps) }));
      var node_2 = child(li);
      snippet(node_2, () => $$props.children ?? noop);
      reset(li);
      append($$anchor2, li);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_item = hmr(Navigation_menu_item, () => Navigation_menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_item[HMR].source;
    set(Navigation_menu_item[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_item_default = Navigation_menu_item;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte
Navigation_menu_link[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte";
var root_274 = add_locations(from_html(`<a><!></a>`), Navigation_menu_link[FILENAME], [[37, 1]]);
function Navigation_menu_link($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_link);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), active = prop($$props, "active", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "active",
      "onSelect",
      "tabindex"
    ],
    "restProps"
  );
  const linkState = NavigationMenuLinkState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    active: box.with(() => active()),
    onSelect: box.with(() => onSelect())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, linkState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_274();
      attribute_effect(a2, () => ({ ...get(mergedProps) }));
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      append($$anchor2, a2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_link = hmr(Navigation_menu_link, () => Navigation_menu_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_link[HMR].source;
    set(Navigation_menu_link[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_link_default = Navigation_menu_link;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte
Navigation_menu_list[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte";
var root_17 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_list[FILENAME], []);
var root_275 = add_locations(from_html(`<div><ul><!></ul></div> <!>`, 1), Navigation_menu_list[FILENAME], [[34, 1, [[35, 2]]]]);
function Navigation_menu_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const listState = NavigationMenuListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  const wrapperProps = tag(user_derived(() => mergeProps(listState.wrapperProps)), "wrapperProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_17();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        wrapperProps: get(wrapperProps)
      }));
      var node_2 = sibling(node_1, 2);
      validate_binding("bind:mounted={listState.wrapperMounted}", () => listState, () => "wrapperMounted", 32, 10);
      mounted_default(node_2, {
        get mounted() {
          return listState.wrapperMounted;
        },
        set mounted($$value) {
          listState.wrapperMounted = $$value;
        }
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = root_275();
      var div = first_child(fragment_2);
      attribute_effect(div, () => ({ ...get(wrapperProps) }));
      var ul = child(div);
      attribute_effect(ul, () => ({ ...get(mergedProps) }));
      var node_3 = child(ul);
      snippet(node_3, () => $$props.children ?? noop);
      reset(ul);
      reset(div);
      var node_4 = sibling(div, 2);
      validate_binding("bind:mounted={listState.wrapperMounted}", () => listState, () => "wrapperMounted", 39, 10);
      mounted_default(node_4, {
        get mounted() {
          return listState.wrapperMounted;
        },
        set mounted($$value) {
          listState.wrapperMounted = $$value;
        }
      });
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_list = hmr(Navigation_menu_list, () => Navigation_menu_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_list[HMR].source;
    set(Navigation_menu_list[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_list_default = Navigation_menu_list;

// node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte
Visually_hidden[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte";
var root_276 = add_locations(from_html(`<span><!></span>`), Visually_hidden[FILENAME], [[28, 1]]);
function Visually_hidden($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Visually_hidden);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child"
    ],
    "restProps"
  );
  const style = {
    position: "absolute",
    border: 0,
    width: "1px",
    display: "inline-block",
    height: "1px",
    padding: 0,
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  const mergedProps = tag(user_derived(() => mergeProps(restProps, { style })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_276();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Visually_hidden = hmr(Visually_hidden, () => Visually_hidden[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Visually_hidden[HMR].source;
    set(Visually_hidden[HMR].source, module.default[HMR].original);
  });
}
var visually_hidden_default = Visually_hidden;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte
Navigation_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte";
var root_277 = add_locations(from_html(`<button><!></button>`), Navigation_menu_trigger[FILENAME], [[36, 1]]);
var root_420 = add_locations(from_html(`<span></span>`), Navigation_menu_trigger[FILENAME], [[45, 2]]);
var root_318 = add_locations(from_html(`<!> <!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
var root9 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
function Navigation_menu_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const triggerState = NavigationMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = root9();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_277();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = root_318();
      var node_4 = first_child(fragment_2);
      visually_hidden_default(node_4, spread_props(() => triggerState.focusProxyProps));
      var node_5 = sibling(node_4, 2);
      validate_binding("bind:mounted={triggerState.focusProxyMounted}", () => triggerState, () => "focusProxyMounted", 43, 10);
      mounted_default(node_5, {
        get mounted() {
          return triggerState.focusProxyMounted;
        },
        set mounted($$value) {
          triggerState.focusProxyMounted = $$value;
        }
      });
      var node_6 = sibling(node_5, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var span = root_420();
          template_effect(() => set_attribute(span, "aria-owns", triggerState.itemContext.contentId ?? void 0));
          append($$anchor3, span);
        };
        if_block(node_6, ($$render) => {
          if (triggerState.context.viewportRef.current) $$render(consequent_1);
        });
      }
      append($$anchor2, fragment_2);
    };
    if_block(node_3, ($$render) => {
      if (triggerState.open) $$render(consequent_2);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_trigger = hmr(Navigation_menu_trigger, () => Navigation_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_trigger[HMR].source;
    set(Navigation_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_trigger_default = Navigation_menu_trigger;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte
Navigation_menu_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte";
var root_319 = add_locations(from_html(`<div><!></div>`), Navigation_menu_viewport[FILENAME], [[36, 3]]);
var root_18 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_viewport[FILENAME], []);
function Navigation_menu_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_viewport);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "child",
      "children"
    ],
    "restProps"
  );
  const viewportState = NavigationMenuViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => forceMount() || viewportState.open);
  {
    const presence = wrap_snippet(Navigation_menu_viewport, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = root_18();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_319();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          snippet(node_3, () => $$props.children ?? noop);
          reset(div);
          append($$anchor3, div);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      var node_4 = sibling(node_1, 2);
      validate_binding("bind:mounted={viewportState.mounted}", () => viewportState, () => "mounted", 40, 11);
      mounted_default(node_4, {
        get mounted() {
          return viewportState.mounted;
        },
        set mounted($$value) {
          viewportState.mounted = $$value;
        }
      });
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return get(expression);
      },
      get ref() {
        return viewportState.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_viewport = hmr(Navigation_menu_viewport, () => Navigation_menu_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_viewport[HMR].source;
    set(Navigation_menu_viewport[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_viewport_default = Navigation_menu_viewport;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-sub.svelte
Navigation_menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-sub.svelte";
var root_278 = add_locations(from_html(`<div><!></div>`), Navigation_menu_sub[FILENAME], [[43, 1]]);
function Navigation_menu_sub($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_sub);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "orientation"
    ],
    "restProps"
  );
  const rootState = NavigationMenuSubState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_278();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_sub = hmr(Navigation_menu_sub, () => Navigation_menu_sub[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_sub[HMR].source;
    set(Navigation_menu_sub[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_sub_default = Navigation_menu_sub;

// node_modules/bits-ui/dist/bits/pagination/exports.js
var exports_exports23 = {};
__export(exports_exports23, {
  NextButton: () => pagination_next_button_default,
  Page: () => pagination_page_default,
  PrevButton: () => pagination_prev_button_default,
  Root: () => pagination_default
});

// node_modules/bits-ui/dist/bits/pagination/pagination.svelte.js
var paginationAttrs = createBitsAttrs({
  component: "pagination",
  parts: ["root", "page", "prev", "next"]
});
var PaginationRootContext = new Context("Pagination.Root");
var _totalPages, _range, _pages, _hasPrevPage, _hasNextPage, _snippetProps21, _props113;
var _PaginationRootState = class _PaginationRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _totalPages, tag(
      user_derived(() => {
        if (strict_equals(this.opts.count.current, 0)) return 1;
        return Math.ceil(this.opts.count.current / this.opts.perPage.current);
      }),
      "PaginationRootState.totalPages"
    ));
    __privateAdd(this, _range, tag(
      user_derived(() => {
        const start = (this.opts.page.current - 1) * this.opts.perPage.current;
        const end = Math.min(start + this.opts.perPage.current, this.opts.count.current);
        return { start: start + 1, end };
      }),
      "PaginationRootState.range"
    ));
    __privateAdd(this, _pages, tag(
      user_derived(() => getPageItems({
        page: this.opts.page.current,
        totalPages: this.totalPages,
        siblingCount: this.opts.siblingCount.current
      })),
      "PaginationRootState.pages"
    ));
    __privateAdd(this, _hasPrevPage, tag(user_derived(() => this.opts.page.current > 1), "PaginationRootState.hasPrevPage"));
    __privateAdd(this, _hasNextPage, tag(user_derived(() => this.opts.page.current < this.totalPages), "PaginationRootState.hasNextPage"));
    __privateAdd(this, _snippetProps21, tag(
      user_derived(() => ({
        pages: this.pages,
        range: this.range,
        currentPage: this.opts.page.current
      })),
      "PaginationRootState.snippetProps"
    ));
    __privateAdd(this, _props113, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        [paginationAttrs.root]: "",
        ...this.attachment
      })),
      "PaginationRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return PaginationRootContext.set(new _PaginationRootState(opts));
  }
  get totalPages() {
    return get(__privateGet(this, _totalPages));
  }
  set totalPages(value) {
    set(__privateGet(this, _totalPages), value);
  }
  get range() {
    return get(__privateGet(this, _range));
  }
  set range(value) {
    set(__privateGet(this, _range), value);
  }
  get pages() {
    return get(__privateGet(this, _pages));
  }
  set pages(value) {
    set(__privateGet(this, _pages), value);
  }
  get hasPrevPage() {
    return get(__privateGet(this, _hasPrevPage));
  }
  set hasPrevPage(value) {
    set(__privateGet(this, _hasPrevPage), value);
  }
  get hasNextPage() {
    return get(__privateGet(this, _hasNextPage));
  }
  set hasNextPage(value) {
    set(__privateGet(this, _hasNextPage), value);
  }
  setPage(page) {
    this.opts.page.current = page;
  }
  getPageTriggerNodes() {
    const node = this.opts.ref.current;
    if (!node) return [];
    return Array.from(node.querySelectorAll("[data-pagination-page]"));
  }
  getButtonNode(type) {
    const node = this.opts.ref.current;
    if (!node) return;
    return node.querySelector(paginationAttrs.selector(type));
  }
  prevPage() {
    this.opts.page.current = Math.max(this.opts.page.current - 1, 1);
  }
  nextPage() {
    this.opts.page.current = Math.min(this.opts.page.current + 1, this.totalPages);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps21));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps21), value);
  }
  get props() {
    return get(__privateGet(this, _props113));
  }
  set props(value) {
    set(__privateGet(this, _props113), value);
  }
};
_totalPages = new WeakMap();
_range = new WeakMap();
_pages = new WeakMap();
_hasPrevPage = new WeakMap();
_hasNextPage = new WeakMap();
_snippetProps21 = new WeakMap();
_props113 = new WeakMap();
var PaginationRootState = _PaginationRootState;
var _isSelected3, _props114;
var _PaginationPageState = class _PaginationPageState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isSelected3, tag(user_derived(() => strict_equals(this.opts.page.current.value, this.root.opts.page.current)), "PaginationPageState.#isSelected"));
    __privateAdd(this, _props114, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-label": `Page ${this.opts.page.current.value}`,
        "data-value": `${this.opts.page.current.value}`,
        "data-selected": get(__privateGet(this, _isSelected3)) ? "" : void 0,
        [paginationAttrs.page]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "PaginationPageState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PaginationPageState(opts, PaginationRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    this.root.setPage(this.opts.page.current.value);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.setPage(this.opts.page.current.value);
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  get props() {
    return get(__privateGet(this, _props114));
  }
  set props(value) {
    set(__privateGet(this, _props114), value);
  }
};
_isSelected3 = new WeakMap();
_props114 = new WeakMap();
var PaginationPageState = _PaginationPageState;
var _PaginationButtonState_instances, action_fn, _isDisabled10, _props115;
var _PaginationButtonState = class _PaginationButtonState {
  constructor(opts, root18) {
    __privateAdd(this, _PaginationButtonState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled10, tag(
      user_derived(() => {
        if (this.opts.disabled.current) return true;
        if (strict_equals(this.opts.type, "prev")) return !this.root.hasPrevPage;
        if (strict_equals(this.opts.type, "next")) return !this.root.hasNextPage;
        return false;
      }),
      "PaginationButtonState.#isDisabled"
    ));
    __privateAdd(this, _props115, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [paginationAttrs[this.opts.type]]: "",
        disabled: get(__privateGet(this, _isDisabled10)),
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "PaginationButtonState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _PaginationButtonState(opts, PaginationRootContext.get());
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    __privateMethod(this, _PaginationButtonState_instances, action_fn).call(this);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      __privateMethod(this, _PaginationButtonState_instances, action_fn).call(this);
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  get props() {
    return get(__privateGet(this, _props115));
  }
  set props(value) {
    set(__privateGet(this, _props115), value);
  }
};
_PaginationButtonState_instances = new WeakSet();
action_fn = function() {
  strict_equals(this.opts.type, "prev") ? this.root.prevPage() : this.root.nextPage();
};
_isDisabled10 = new WeakMap();
_props115 = new WeakMap();
var PaginationButtonState = _PaginationButtonState;
function handleTriggerKeydown(e, node, root18) {
  if (!node || !root18.opts.ref.current) return;
  const items = root18.getPageTriggerNodes();
  const nextButton = root18.getButtonNode("next");
  const prevButton = root18.getButtonNode("prev");
  if (prevButton) {
    items.unshift(prevButton);
  }
  if (nextButton) {
    items.push(nextButton);
  }
  const currentIndex = items.indexOf(node);
  const dir = getElemDirection(root18.opts.ref.current);
  const { nextKey, prevKey } = getDirectionalKeys(dir, root18.opts.orientation.current);
  const loop = root18.opts.loop.current;
  const keyToIndex = {
    [nextKey]: currentIndex + 1,
    [prevKey]: currentIndex - 1,
    [kbd_constants_exports.HOME]: 0,
    [kbd_constants_exports.END]: items.length - 1
  };
  let itemIndex = keyToIndex[e.key];
  if (strict_equals(itemIndex, void 0)) return;
  e.preventDefault();
  if (itemIndex < 0 && loop) {
    itemIndex = items.length - 1;
  } else if (strict_equals(itemIndex, items.length) && loop) {
    itemIndex = 0;
  }
  const itemToFocus = items[itemIndex];
  if (!itemToFocus) return;
  itemToFocus.focus();
}
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let i = 2; i <= totalPages - 1; i++) {
      pagesToShow.add(i);
    }
  } else if (page < firstItemWithSiblings) {
    for (let i = 2; i <= Math.min(firstItemWithSiblings, totalPages); i++) {
      pagesToShow.add(i);
    }
  } else if (page > lastItemWithSiblings) {
    for (let i = totalPages - 1; i >= Math.max(lastItemWithSiblings, 2); i--) {
      pagesToShow.add(i);
    }
  } else {
    for (let i = Math.max(page - siblingCount, 2); i <= Math.min(page + siblingCount, totalPages); i++) {
      pagesToShow.add(i);
    }
  }
  function addPage(value) {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  }
  function addEllipsis() {
    const id = useId();
    pageItems.push({ type: "ellipsis", key: `ellipsis-${id}` });
  }
  let lastNumber = 0;
  for (const p2 of Array.from(pagesToShow).sort((a2, b) => a2 - b)) {
    if (p2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(p2);
    lastNumber = p2;
  }
  return pageItems;
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte
Pagination[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte";
var root_279 = add_locations(from_html(`<div><!></div>`), Pagination[FILENAME], [[51, 1]]);
function Pagination($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination);
  let id = prop($$props, "id", 19, () => createId(uid)), perPage = prop($$props, "perPage", 3, 1), page = prop($$props, "page", 15, 1), ref = prop($$props, "ref", 15, null), siblingCount = prop($$props, "siblingCount", 3, 1), onPageChange = prop($$props, "onPageChange", 3, noop3), loop = prop($$props, "loop", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "count",
      "perPage",
      "page",
      "ref",
      "siblingCount",
      "onPageChange",
      "loop",
      "orientation",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = PaginationRootState.create({
    id: box.with(() => id()),
    count: box.with(() => $$props.count),
    perPage: box.with(() => perPage()),
    page: box.with(() => page(), (v) => {
      var _a;
      page(v);
      (_a = onPageChange()) == null ? void 0 : _a(v);
    }),
    loop: box.with(() => loop()),
    siblingCount: box.with(() => siblingCount()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_279();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination = hmr(Pagination, () => Pagination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination[HMR].source;
    set(Pagination[HMR].source, module.default[HMR].original);
  });
}
var pagination_default = Pagination;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte
Pagination_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte";
var root_280 = add_locations(from_html(`<button><!></button>`), Pagination_prev_button[FILENAME], [[35, 1]]);
function Pagination_prev_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_prev_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const prevButtonState = PaginationButtonState.create({
    type: "prev",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, prevButtonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_280();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_prev_button = hmr(Pagination_prev_button, () => Pagination_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_prev_button[HMR].source;
    set(Pagination_prev_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_prev_button_default = Pagination_prev_button;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte
Pagination_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte";
var root_281 = add_locations(from_html(`<button><!></button>`), Pagination_next_button[FILENAME], [[35, 1]]);
function Pagination_next_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_next_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const nextButtonState = PaginationButtonState.create({
    type: "next",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, nextButtonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_281();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_next_button = hmr(Pagination_next_button, () => Pagination_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_next_button[HMR].source;
    set(Pagination_next_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_next_button_default = Pagination_next_button;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte
Pagination_page[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte";
var root_282 = add_locations(from_html(`<button><!></button>`), Pagination_page[FILENAME], [[36, 1]]);
function Pagination_page($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_page);
  let id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "page",
      "child",
      "children",
      "type",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const pageState = PaginationPageState.create({
    id: box.with(() => id()),
    page: box.with(() => $$props.page),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, pageState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_282();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          snippet(node_3, () => $$props.children ?? noop);
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $$props.page.value));
          append($$anchor3, text2);
        };
        if_block(node_2, ($$render) => {
          if ($$props.children) $$render(consequent_1);
          else $$render(alternate_1, false);
        });
      }
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_page = hmr(Pagination_page, () => Pagination_page[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_page[HMR].source;
    set(Pagination_page[HMR].source, module.default[HMR].original);
  });
}
var pagination_page_default = Pagination_page;

// node_modules/bits-ui/dist/bits/pin-input/exports.js
var exports_exports24 = {};
__export(exports_exports24, {
  Cell: () => pin_input_cell_default,
  Root: () => pin_input_default
});

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte
Pin_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte";
var root10 = add_locations(from_html(`<div><!> <div><input/></div></div>`), Pin_input[FILENAME], [
  [60, 0, [[63, 1, [[64, 2]]]]]
]);
function Pin_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pin_input);
  let id = prop($$props, "id", 19, () => createId(uid)), inputId = prop($$props, "inputId", 19, () => `${createId(uid)}-input`), ref = prop($$props, "ref", 15, null), maxlength = prop($$props, "maxlength", 3, 6), textalign = prop($$props, "textalign", 3, "left"), inputmode = prop($$props, "inputmode", 3, "numeric"), onComplete = prop($$props, "onComplete", 3, noop3), pushPasswordManagerStrategy = prop($$props, "pushPasswordManagerStrategy", 3, "increase-width"), containerClass = prop($$props, "class", 3, ""), autocomplete = prop($$props, "autocomplete", 3, "one-time-code"), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "inputId",
      "ref",
      "maxlength",
      "textalign",
      "pattern",
      "inputmode",
      "onComplete",
      "pushPasswordManagerStrategy",
      "class",
      "children",
      "autocomplete",
      "disabled",
      "value",
      "onValueChange",
      "pasteTransformer"
    ],
    "restProps"
  );
  const rootState = PinInputRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    inputId: box.with(() => inputId()),
    autocomplete: box.with(() => autocomplete()),
    maxLength: box.with(() => maxlength()),
    textAlign: box.with(() => textalign()),
    disabled: box.with(() => disabled()),
    inputmode: box.with(() => inputmode()),
    pattern: box.with(() => $$props.pattern),
    onComplete: box.with(() => onComplete()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    pushPasswordManagerStrategy: box.with(() => pushPasswordManagerStrategy()),
    pasteTransformer: box.with(() => $$props.pasteTransformer)
  });
  const mergedInputProps = tag(user_derived(() => mergeProps(restProps, rootState.inputProps)), "mergedInputProps");
  const mergedRootProps = tag(user_derived(() => mergeProps(rootState.rootProps, { class: containerClass() })), "mergedRootProps");
  const mergedInputWrapperProps = tag(user_derived(() => mergeProps(rootState.inputWrapperProps, {})), "mergedInputWrapperProps");
  var div = root10();
  attribute_effect(div, () => ({ ...get(mergedRootProps) }));
  var node = child(div);
  snippet(node, () => $$props.children ?? noop, () => rootState.snippetProps);
  var div_1 = sibling(node, 2);
  attribute_effect(div_1, () => ({ ...get(mergedInputWrapperProps) }));
  var input = child(div_1);
  remove_input_defaults(input);
  attribute_effect(input, () => ({ ...get(mergedInputProps) }));
  reset(div_1);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input = hmr(Pin_input, () => Pin_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input[HMR].source;
    set(Pin_input[HMR].source, module.default[HMR].original);
  });
}
var pin_input_default = Pin_input;

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte
Pin_input_cell[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte";
var root_283 = add_locations(from_html(`<div><!></div>`), Pin_input_cell[FILENAME], [[33, 1]]);
function Pin_input_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pin_input_cell);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "cell",
      "child",
      "children"
    ],
    "restProps"
  );
  const cellState = PinInputCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    cell: box.with(() => $$props.cell)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_283();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input_cell = hmr(Pin_input_cell, () => Pin_input_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input_cell[HMR].source;
    set(Pin_input_cell[HMR].source, module.default[HMR].original);
  });
}
var pin_input_cell_default = Pin_input_cell;

// node_modules/bits-ui/dist/bits/popover/exports.js
var exports_exports25 = {};
__export(exports_exports25, {
  Arrow: () => popover_arrow_default,
  Close: () => popover_close_default,
  Content: () => popover_content_default,
  ContentStatic: () => popover_content_static_default,
  Portal: () => portal_default,
  Root: () => popover_default,
  Trigger: () => popover_trigger_default
});

// node_modules/bits-ui/dist/bits/popover/components/popover.svelte
Popover[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover.svelte";
function Popover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  PopoverRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Popover, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover = hmr(Popover, () => Popover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover[HMR].source;
    set(Popover[HMR].source, module.default[HMR].original);
  });
}
var popover_default = Popover;

// node_modules/bits-ui/dist/bits/progress/exports.js
var exports_exports26 = {};
__export(exports_exports26, {
  Root: () => progress_default
});

// node_modules/bits-ui/dist/bits/progress/progress.svelte.js
var progressAttrs = createBitsAttrs({ component: "progress", parts: ["root"] });
var _props116;
var _ProgressRootState = class _ProgressRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _props116, tag(
      user_derived(() => ({
        role: "progressbar",
        value: this.opts.value.current,
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuenow": strict_equals(this.opts.value.current, null) ? void 0 : this.opts.value.current,
        "data-value": strict_equals(this.opts.value.current, null) ? void 0 : this.opts.value.current,
        "data-state": getProgressDataState(this.opts.value.current, this.opts.max.current),
        "data-max": this.opts.max.current,
        "data-min": this.opts.min.current,
        "data-indeterminate": strict_equals(this.opts.value.current, null) ? "" : void 0,
        [progressAttrs.root]: "",
        ...this.attachment
      })),
      "ProgressRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(opts) {
    return new _ProgressRootState(opts);
  }
  get props() {
    return get(__privateGet(this, _props116));
  }
  set props(value) {
    set(__privateGet(this, _props116), value);
  }
};
_props116 = new WeakMap();
var ProgressRootState = _ProgressRootState;
function getProgressDataState(value, max) {
  if (strict_equals(value, null)) return "indeterminate";
  return strict_equals(value, max) ? "loaded" : "loading";
}

// node_modules/bits-ui/dist/bits/progress/components/progress.svelte
Progress[FILENAME] = "node_modules/bits-ui/dist/bits/progress/components/progress.svelte";
var root_284 = add_locations(from_html(`<div><!></div>`), Progress[FILENAME], [[37, 1]]);
function Progress($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Progress);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "max",
      "min",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = ProgressRootState.create({
    value: box.with(() => value()),
    max: box.with(() => max()),
    min: box.with(() => min()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_284();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Progress = hmr(Progress, () => Progress[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Progress[HMR].source;
    set(Progress[HMR].source, module.default[HMR].original);
  });
}
var progress_default = Progress;

// node_modules/bits-ui/dist/bits/radio-group/exports.js
var exports_exports27 = {};
__export(exports_exports27, {
  Item: () => radio_group_item_default,
  Root: () => radio_group_default
});

// node_modules/bits-ui/dist/bits/radio-group/radio-group.svelte.js
var radioGroupAttrs = createBitsAttrs({
  component: "radio-group",
  parts: ["root", "item"]
});
var RadioGroupRootContext = new Context("RadioGroup.Root");
var _hasValue3, _props117;
var _RadioGroupRootState = class _RadioGroupRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _hasValue3, tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "RadioGroupRootState.hasValue"));
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props117, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "radiogroup",
        "aria-required": getAriaRequired(this.opts.required.current),
        "aria-disabled": getAriaDisabled(this.opts.disabled.current),
        "aria-readonly": this.opts.readonly.current ? "true" : void 0,
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-readonly": getDataReadonly(this.opts.readonly.current),
        "data-orientation": this.opts.orientation.current,
        [radioGroupAttrs.root]: "",
        ...this.attachment
      })),
      "RadioGroupRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: radioGroupAttrs.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  static create(opts) {
    return RadioGroupRootContext.set(new _RadioGroupRootState(opts));
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue3));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue3), value);
  }
  isChecked(value) {
    return strict_equals(this.opts.value.current, value);
  }
  setValue(value) {
    this.opts.value.current = value;
  }
  get props() {
    return get(__privateGet(this, _props117));
  }
  set props(value) {
    set(__privateGet(this, _props117), value);
  }
};
_hasValue3 = new WeakMap();
_props117 = new WeakMap();
var RadioGroupRootState = _RadioGroupRootState;
var _checked, _isDisabled11, _isReadonly, _isChecked2, _tabIndex2, _snippetProps22, _props118;
var _RadioGroupItemState = class _RadioGroupItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _checked, tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "RadioGroupItemState.checked"));
    __privateAdd(this, _isDisabled11, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "RadioGroupItemState.#isDisabled"));
    __privateAdd(this, _isReadonly, tag(user_derived(() => this.root.opts.readonly.current), "RadioGroupItemState.#isReadonly"));
    __privateAdd(this, _isChecked2, tag(user_derived(() => this.root.isChecked(this.opts.value.current)), "RadioGroupItemState.#isChecked"));
    __privateAdd(this, _tabIndex2, tag(state(-1), "RadioGroupItemState.#tabIndex"));
    __privateAdd(this, _snippetProps22, tag(user_derived(() => ({ checked: get(__privateGet(this, _isChecked2)) })), "RadioGroupItemState.snippetProps"));
    __privateAdd(this, _props118, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        disabled: get(__privateGet(this, _isDisabled11)) ? true : void 0,
        "data-value": this.opts.value.current,
        "data-orientation": this.root.opts.orientation.current,
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled11))),
        "data-readonly": getDataReadonly(get(__privateGet(this, _isReadonly))),
        "data-state": get(__privateGet(this, _isChecked2)) ? "checked" : "unchecked",
        "aria-checked": getAriaChecked(get(__privateGet(this, _isChecked2)), false),
        [radioGroupAttrs.item]: "",
        type: "button",
        role: "radio",
        tabindex: get(__privateGet(this, _tabIndex2)),
        //
        onkeydown: this.onkeydown,
        onfocus: this.onfocus,
        onclick: this.onclick,
        ...this.attachment
      })),
      "RadioGroupItemState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    if (strict_equals(this.opts.value.current, this.root.opts.value.current)) {
      this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
      set(__privateGet(this, _tabIndex2), 0);
    } else if (!this.root.opts.value.current) {
      set(__privateGet(this, _tabIndex2), 0);
    }
    user_effect(() => {
      set(__privateGet(this, _tabIndex2), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    watch(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        if (strict_equals(this.opts.value.current, this.root.opts.value.current)) {
          this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
          set(__privateGet(this, _tabIndex2), 0);
        }
      }
    );
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocus = this.onfocus.bind(this);
  }
  static create(opts) {
    return new _RadioGroupItemState(opts, RadioGroupRootContext.get());
  }
  get checked() {
    return get(__privateGet(this, _checked));
  }
  set checked(value) {
    set(__privateGet(this, _checked), value);
  }
  onclick(_) {
    if (this.opts.disabled.current || get(__privateGet(this, _isReadonly))) return;
    this.root.setValue(this.opts.value.current);
  }
  onfocus(_) {
    if (!this.root.hasValue || get(__privateGet(this, _isReadonly))) return;
    this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled11))) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      if (!get(__privateGet(this, _isReadonly))) {
        this.root.setValue(this.opts.value.current);
      }
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, true);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps22));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps22), value);
  }
  get props() {
    return get(__privateGet(this, _props118));
  }
  set props(value) {
    set(__privateGet(this, _props118), value);
  }
};
_checked = new WeakMap();
_isDisabled11 = new WeakMap();
_isReadonly = new WeakMap();
_isChecked2 = new WeakMap();
_tabIndex2 = new WeakMap();
_snippetProps22 = new WeakMap();
_props118 = new WeakMap();
var RadioGroupItemState = _RadioGroupItemState;
var _shouldRender9, _props119;
var _RadioGroupInputState = class _RadioGroupInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender9, tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "RadioGroupInputState.shouldRender"));
    __privateAdd(this, _props119, tag(
      user_derived(() => ({
        name: this.root.opts.name.current,
        value: this.root.opts.value.current,
        required: this.root.opts.required.current,
        disabled: this.root.opts.disabled.current
      })),
      "RadioGroupInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _RadioGroupInputState(RadioGroupRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender9));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender9), value);
  }
  get props() {
    return get(__privateGet(this, _props119));
  }
  set props(value) {
    set(__privateGet(this, _props119), value);
  }
};
_shouldRender9 = new WeakMap();
_props119 = new WeakMap();
var RadioGroupInputState = _RadioGroupInputState;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte
Radio_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte";
function Radio_group_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Radio_group_input);
  const inputState = RadioGroupInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => inputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => inputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_input = hmr(Radio_group_input, () => Radio_group_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_input[HMR].source;
    set(Radio_group_input[HMR].source, module.default[HMR].original);
  });
}
var radio_group_input_default = Radio_group_input;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte
Radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte";
var root_285 = add_locations(from_html(`<div><!></div>`), Radio_group[FILENAME], [[55, 1]]);
var root11 = add_locations(from_html(`<!> <!>`, 1), Radio_group[FILENAME], []);
function Radio_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Radio_group);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "vertical"), loop = prop($$props, "loop", 3, true), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "value",
      "ref",
      "orientation",
      "loop",
      "name",
      "required",
      "readonly",
      "id",
      "onValueChange"
    ],
    "restProps"
  );
  const rootState = RadioGroupRootState.create({
    orientation: box.with(() => orientation()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    name: box.with(() => name()),
    required: box.with(() => required()),
    readonly: box.with(() => readonly()),
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      if (strict_equals(v, value())) return;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = root11();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_285();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  radio_group_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group = hmr(Radio_group, () => Radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group[HMR].source;
    set(Radio_group[HMR].source, module.default[HMR].original);
  });
}
var radio_group_default = Radio_group;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte
Radio_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte";
var root_286 = add_locations(from_html(`<button><!></button>`), Radio_group_item[FILENAME], [[35, 1]]);
function Radio_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Radio_group_item);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "value",
      "disabled",
      "ref"
    ],
    "restProps"
  );
  const itemState = RadioGroupItemState.create({
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_286();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_item = hmr(Radio_group_item, () => Radio_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_item[HMR].source;
    set(Radio_group_item[HMR].source, module.default[HMR].original);
  });
}
var radio_group_item_default = Radio_group_item;

// node_modules/bits-ui/dist/bits/range-calendar/exports.js
var exports_exports28 = {};
__export(exports_exports28, {
  Cell: () => range_calendar_cell_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => range_calendar_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte
Range_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte";
var root_287 = add_locations(from_html(`<div><!></div>`), Range_calendar[FILENAME], [[148, 1]]);
function Range_calendar($$anchor, $$props) {
  var _a, _b, _c;
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "disableDaysOutsideMonth",
      "minDays",
      "maxDays",
      "onStartValueChange",
      "onEndValueChange",
      "excludeDisabled",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy((_a = value()) == null ? void 0 : _a.start)), "startValue");
  let endValue = tag(state(proxy((_b = value()) == null ? void 0 : _b.end)), "endValue");
  const defaultPlaceholder = getDefaultDate({ defaultValue: (_c = value()) == null ? void 0 : _c.start });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = RangeCalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    preventDeselect: box.with(() => preventDeselect()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    isDateDisabled: box.with(() => isDateDisabled()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: box.with(() => calendarLabel()),
    fixedWeeks: box.with(() => fixedWeeks()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    minDays: box.with(() => $$props.minDays),
    maxDays: box.with(() => $$props.maxDays),
    excludeDisabled: box.with(() => excludeDisabled()),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_287();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar = hmr(Range_calendar, () => Range_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar[HMR].source;
    set(Range_calendar[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_default = Range_calendar;

// node_modules/bits-ui/dist/bits/rating-group/exports.js
var exports_exports29 = {};
__export(exports_exports29, {
  Item: () => rating_group_item_default,
  Root: () => rating_group_default
});

// node_modules/bits-ui/dist/bits/rating-group/rating-group.svelte.js
var ratingGroupAttrs = createBitsAttrs({
  component: "rating-group",
  parts: ["root", "item"]
});
var RatingGroupRootContext = new Context("RatingGroup.Root");
var _hoverValue, _keySequence, _keySequenceTimeout, _hasValue4, _valueToUse, _isRTL, _ariaValuetext, _items, _RatingGroupRootState_instances, adjustValue_fn, handleDecimalInput_fn, startDecimalListening_fn, clearKeySequence_fn, _snippetProps23, _props120;
var _RatingGroupRootState = class _RatingGroupRootState {
  constructor(opts) {
    __privateAdd(this, _RatingGroupRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _hoverValue, tag(state(null), "RatingGroupRootState.#hoverValue"));
    __privateAdd(this, _keySequence, tag(state(""), "RatingGroupRootState.#keySequence"));
    __privateAdd(this, _keySequenceTimeout, null);
    __publicField(this, "domContext");
    __privateAdd(this, _hasValue4, tag(user_derived(() => this.opts.value.current > 0), "RatingGroupRootState.hasValue"));
    __privateAdd(this, _valueToUse, tag(user_derived(() => get(__privateGet(this, _hoverValue)) ?? this.opts.value.current), "RatingGroupRootState.valueToUse"));
    __privateAdd(this, _isRTL, tag(
      user_derived(() => {
        const element2 = this.opts.ref.current;
        if (!element2) return false;
        const style = getComputedStyle(element2);
        return strict_equals(style.direction, "rtl");
      }),
      "RatingGroupRootState.isRTL"
    ));
    __privateAdd(this, _ariaValuetext, tag(
      user_derived(() => {
        return strict_equals(typeof this.opts.ariaValuetext.current, "function") ? this.opts.ariaValuetext.current(this.opts.value.current, this.opts.max.current) : this.opts.ariaValuetext.current;
      }),
      "RatingGroupRootState.ariaValuetext"
    ));
    __privateAdd(this, _items, tag(
      user_derived(() => {
        const value = this.valueToUse;
        return Array.from({ length: this.opts.max.current }, (_, i) => {
          const itemValue = i + 1;
          const halfValue = itemValue - 0.5;
          const state2 = value >= itemValue ? "active" : this.opts.allowHalf.current && value >= halfValue ? "partial" : "inactive";
          return { index: i, state: state2 };
        });
      }),
      "RatingGroupRootState.items"
    ));
    __publicField(this, "handlers", {
      [kbd_constants_exports.ARROW_UP]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.opts.allowHalf.current ? 0.5 : 1);
      },
      [kbd_constants_exports.ARROW_RIGHT]: () => {
        this.setHoverValue(null);
        const increment = this.opts.allowHalf.current ? 0.5 : 1;
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.isRTL ? -increment : increment);
      },
      [kbd_constants_exports.ARROW_DOWN]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.opts.allowHalf.current ? -0.5 : -1);
      },
      [kbd_constants_exports.ARROW_LEFT]: () => {
        this.setHoverValue(null);
        const increment = this.opts.allowHalf.current ? 0.5 : 1;
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, this.isRTL ? increment : -increment);
      },
      [kbd_constants_exports.HOME]: () => {
        this.setHoverValue(null);
        this.setValue(this.opts.min.current);
      },
      [kbd_constants_exports.END]: () => {
        this.setHoverValue(null);
        this.setValue(this.opts.max.current);
      },
      [kbd_constants_exports.PAGE_UP]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, 1);
      },
      [kbd_constants_exports.PAGE_DOWN]: () => {
        this.setHoverValue(null);
        __privateMethod(this, _RatingGroupRootState_instances, adjustValue_fn).call(this, -1);
      }
    });
    __privateAdd(this, _snippetProps23, tag(
      user_derived(() => ({
        items: this.items,
        value: this.opts.value.current,
        max: this.opts.max.current
      })),
      "RatingGroupRootState.snippetProps"
    ));
    __privateAdd(this, _props120, tag(
      user_derived(() => {
        return {
          id: this.opts.id.current,
          role: "slider",
          "aria-valuenow": this.opts.value.current,
          "aria-valuemin": this.opts.min.current,
          "aria-valuemax": this.opts.max.current,
          "aria-valuetext": this.ariaValuetext,
          "aria-orientation": this.opts.orientation.current,
          "aria-required": getAriaRequired(this.opts.required.current),
          "aria-disabled": this.opts.disabled.current ? "true" : void 0,
          "aria-label": "Rating",
          "data-disabled": getDataDisabled(this.opts.disabled.current),
          "data-readonly": this.opts.readonly.current ? "" : void 0,
          "data-orientation": this.opts.orientation.current,
          tabindex: this.opts.disabled.current ? -1 : 0,
          [ratingGroupAttrs.root]: "",
          onkeydown: this.onkeydown,
          onpointerleave: this.onpointerleave,
          ...this.attachment
        };
      }),
      "RatingGroupRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.domContext = new DOMContext(this.opts.ref);
  }
  static create(opts) {
    return RatingGroupRootContext.set(new _RatingGroupRootState(opts));
  }
  get hasValue() {
    return get(__privateGet(this, _hasValue4));
  }
  set hasValue(value) {
    set(__privateGet(this, _hasValue4), value);
  }
  get valueToUse() {
    return get(__privateGet(this, _valueToUse));
  }
  set valueToUse(value) {
    set(__privateGet(this, _valueToUse), value);
  }
  get isRTL() {
    return get(__privateGet(this, _isRTL));
  }
  set isRTL(value) {
    set(__privateGet(this, _isRTL), value);
  }
  get ariaValuetext() {
    return get(__privateGet(this, _ariaValuetext));
  }
  set ariaValuetext(value) {
    set(__privateGet(this, _ariaValuetext), value);
  }
  get items() {
    return get(__privateGet(this, _items));
  }
  set items(value) {
    set(__privateGet(this, _items), value);
  }
  isActive(itemIndex) {
    return this.valueToUse >= itemIndex + 1;
  }
  isPartial(itemIndex) {
    if (!this.opts.allowHalf.current) return false;
    const itemValue = itemIndex + 1;
    return this.valueToUse >= itemValue - 0.5 && this.valueToUse < itemValue;
  }
  setHoverValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current || !this.opts.hoverPreview.current) return;
    set(__privateGet(this, _hoverValue), strict_equals(value, null) ? null : Math.max(this.opts.min.current, Math.min(this.opts.max.current, value)), true);
  }
  setValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current) return;
    this.opts.value.current = Math.max(this.opts.min.current, Math.min(this.opts.max.current, value));
  }
  calculateRatingFromPointer(itemIndex, event) {
    const ratingValue = itemIndex + 1;
    if (!this.opts.allowHalf.current) return ratingValue;
    const rect = event.currentTarget.getBoundingClientRect();
    const style = getComputedStyle(event.currentTarget);
    const isHorizontal = strict_equals(this.opts.orientation.current, "horizontal");
    const position = isHorizontal ? (event.clientX - rect.left) / rect.width : (event.clientY - rect.top) / rect.height;
    const normalizedPosition = strict_equals(style.direction, "rtl") ? 1 - position : position;
    return normalizedPosition < 0.5 ? ratingValue - 0.5 : ratingValue;
  }
  onpointerleave() {
    this.setHoverValue(null);
  }
  onkeydown(e) {
    var _a, _b;
    if (this.opts.disabled.current || this.opts.readonly.current) return;
    if (this.handlers[e.key]) {
      e.preventDefault();
      __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
      (_b = (_a = this.handlers)[e.key]) == null ? void 0 : _b.call(_a);
      return;
    }
    if (this.opts.allowHalf.current && __privateMethod(this, _RatingGroupRootState_instances, handleDecimalInput_fn).call(this, e)) return;
    const num = parseInt(e.key || "");
    if (!isNaN(num) && e.key) {
      e.preventDefault();
      if (num >= this.opts.min.current && num <= this.opts.max.current) {
        this.setValue(num);
        if (this.opts.allowHalf.current) {
          __privateMethod(this, _RatingGroupRootState_instances, startDecimalListening_fn).call(this, num);
        }
      }
      return;
    }
    __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps23));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps23), value);
  }
  get props() {
    return get(__privateGet(this, _props120));
  }
  set props(value) {
    set(__privateGet(this, _props120), value);
  }
};
_hoverValue = new WeakMap();
_keySequence = new WeakMap();
_keySequenceTimeout = new WeakMap();
_hasValue4 = new WeakMap();
_valueToUse = new WeakMap();
_isRTL = new WeakMap();
_ariaValuetext = new WeakMap();
_items = new WeakMap();
_RatingGroupRootState_instances = new WeakSet();
adjustValue_fn = function(delta) {
  this.setValue(this.opts.value.current + delta);
};
handleDecimalInput_fn = function(e) {
  if (!e.key) return false;
  if (strict_equals(e.key, ".")) {
    e.preventDefault();
    set(__privateGet(this, _keySequence), get(__privateGet(this, _keySequence)) + e.key);
    return true;
  }
  if (strict_equals(e.key, "5") && get(__privateGet(this, _keySequence)).match(/^\d+\.$/)) {
    e.preventDefault();
    set(__privateGet(this, _keySequence), get(__privateGet(this, _keySequence)) + e.key);
    const match = get(__privateGet(this, _keySequence)).match(/^(\d+)\.5$/);
    if (match == null ? void 0 : match[1]) {
      const value = parseFloat(get(__privateGet(this, _keySequence)));
      if (value >= this.opts.min.current && value <= this.opts.max.current) {
        this.setValue(value);
        __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this);
      }
    }
    return true;
  }
  return false;
};
startDecimalListening_fn = function(baseValue) {
  set(__privateGet(this, _keySequence), baseValue.toString(), true);
  if (__privateGet(this, _keySequenceTimeout)) {
    this.domContext.clearTimeout(__privateGet(this, _keySequenceTimeout));
  }
  __privateSet(this, _keySequenceTimeout, this.domContext.setTimeout(() => __privateMethod(this, _RatingGroupRootState_instances, clearKeySequence_fn).call(this), 1e3));
};
clearKeySequence_fn = function() {
  set(__privateGet(this, _keySequence), "");
  if (__privateGet(this, _keySequenceTimeout)) {
    this.domContext.clearTimeout(__privateGet(this, _keySequenceTimeout));
    __privateSet(this, _keySequenceTimeout, null);
  }
};
_snippetProps23 = new WeakMap();
_props120 = new WeakMap();
var RatingGroupRootState = _RatingGroupRootState;
var _isDisabled12, _isActive2, _isPartial, _state2, _snippetProps24, _props121;
var _RatingGroupItemState = class _RatingGroupItemState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled12, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "RatingGroupItemState.#isDisabled"));
    __privateAdd(this, _isActive2, tag(user_derived(() => this.root.isActive(this.opts.index.current)), "RatingGroupItemState.#isActive"));
    __privateAdd(this, _isPartial, tag(user_derived(() => this.root.isPartial(this.opts.index.current)), "RatingGroupItemState.#isPartial"));
    __privateAdd(this, _state2, tag(
      user_derived(() => {
        if (get(__privateGet(this, _isActive2))) return "active";
        if (get(__privateGet(this, _isPartial))) return "partial";
        return "inactive";
      }),
      "RatingGroupItemState.#state"
    ));
    __privateAdd(this, _snippetProps24, tag(
      user_derived(() => {
        return { state: get(__privateGet(this, _state2)) };
      }),
      "RatingGroupItemState.snippetProps"
    ));
    __privateAdd(this, _props121, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "presentation",
        "data-value": this.opts.index.current + 1,
        "data-orientation": this.root.opts.orientation.current,
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled12))),
        "data-readonly": this.root.opts.readonly.current ? "" : void 0,
        "data-state": get(__privateGet(this, _state2)),
        [ratingGroupAttrs.item]: "",
        //
        onclick: this.onclick,
        onpointermove: this.onpointermove,
        ...this.attachment
      })),
      "RatingGroupItemState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  static create(opts) {
    return new _RatingGroupItemState(opts, RatingGroupRootContext.get());
  }
  onclick(e) {
    if (get(__privateGet(this, _isDisabled12)) || this.root.opts.readonly.current) return;
    if (strict_equals(this.opts.index.current, 0) && strict_equals(this.root.opts.min.current, 0) && this.root.opts.value.current > 0) {
      const newValue2 = this.root.calculateRatingFromPointer(this.opts.index.current, e);
      const currentValue = this.root.opts.value.current;
      if (strict_equals(newValue2, currentValue)) {
        this.root.setValue(0);
        if (this.root.opts.ref.current) {
          this.root.opts.ref.current.focus();
        }
        return;
      }
    }
    const newValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setValue(newValue);
    if (this.root.opts.ref.current) {
      this.root.opts.ref.current.focus();
    }
  }
  onpointermove(e) {
    if (get(__privateGet(this, _isDisabled12)) || this.root.opts.readonly.current || !this.root.opts.hoverPreview.current) return;
    if (strict_equals(e.pointerType, "touch")) return;
    const hoverValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setHoverValue(hoverValue);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps24));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps24), value);
  }
  get props() {
    return get(__privateGet(this, _props121));
  }
  set props(value) {
    set(__privateGet(this, _props121), value);
  }
};
_isDisabled12 = new WeakMap();
_isActive2 = new WeakMap();
_isPartial = new WeakMap();
_state2 = new WeakMap();
_snippetProps24 = new WeakMap();
_props121 = new WeakMap();
var RatingGroupItemState = _RatingGroupItemState;
var _shouldRender10, _props122;
var _RatingGroupHiddenInputState = class _RatingGroupHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender10, tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "RatingGroupHiddenInputState.shouldRender"));
    __privateAdd(this, _props122, tag(
      user_derived(() => ({
        name: this.root.opts.name.current,
        value: this.root.opts.value.current,
        required: this.root.opts.required.current,
        disabled: this.root.opts.disabled.current
      })),
      "RatingGroupHiddenInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _RatingGroupHiddenInputState(RatingGroupRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender10));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender10), value);
  }
  get props() {
    return get(__privateGet(this, _props122));
  }
  set props(value) {
    set(__privateGet(this, _props122), value);
  }
};
_shouldRender10 = new WeakMap();
_props122 = new WeakMap();
var RatingGroupHiddenInputState = _RatingGroupHiddenInputState;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-input.svelte
Rating_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group-input.svelte";
function Rating_group_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Rating_group_input);
  const inputState = RatingGroupHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => inputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => inputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group_input = hmr(Rating_group_input, () => Rating_group_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group_input[HMR].source;
    set(Rating_group_input[HMR].source, module.default[HMR].original);
  });
}
var rating_group_input_default = Rating_group_input;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group.svelte
Rating_group[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group.svelte";
var root_288 = add_locations(from_html(`<div><!></div>`), Rating_group[FILENAME], [[75, 1]]);
var root12 = add_locations(from_html(`<!> <!>`, 1), Rating_group[FILENAME], []);
function Rating_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Rating_group);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, 0), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "horizontal"), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), min = prop($$props, "min", 3, 0), max = prop($$props, "max", 3, 5), allowHalf = prop($$props, "allowHalf", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), hoverPreview = prop($$props, "hoverPreview", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "value",
      "ref",
      "orientation",
      "name",
      "required",
      "min",
      "max",
      "allowHalf",
      "readonly",
      "id",
      "onValueChange",
      "aria-label",
      "aria-valuetext",
      "hoverPreview"
    ],
    "restProps"
  );
  if (value() < min() || value() > max()) {
    value(Math.max(min(), Math.min(max(), value())));
  }
  const ariaValuetext = tag(
    user_derived(() => {
      if ($$props["aria-valuetext"]) return $$props["aria-valuetext"];
      return (value2, max2) => `${value2} out of ${max2}`;
    }),
    "ariaValuetext"
  );
  const rootState = RatingGroupRootState.create({
    orientation: box.with(() => orientation()),
    disabled: box.with(() => disabled()),
    name: box.with(() => name()),
    required: box.with(() => required()),
    min: box.with(() => min()),
    max: box.with(() => max()),
    allowHalf: box.with(() => allowHalf()),
    readonly: box.with(() => readonly()),
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      var _a;
      if (strict_equals(v, value())) return;
      value(v);
      (_a = onValueChange()) == null ? void 0 : _a(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v)),
    ariaValuetext: box.with(() => get(ariaValuetext)),
    hoverPreview: box.with(() => hoverPreview())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { "aria-label": $$props["aria-label"] })), "mergedProps");
  var fragment = root12();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_288();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  rating_group_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group = hmr(Rating_group, () => Rating_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group[HMR].source;
    set(Rating_group[HMR].source, module.default[HMR].original);
  });
}
var rating_group_default = Rating_group;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-item.svelte
Rating_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group-item.svelte";
var root_289 = add_locations(from_html(`<div><!></div>`), Rating_group_item[FILENAME], [[35, 1]]);
function Rating_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Rating_group_item);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "index",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const itemState = RatingGroupItemState.create({
    disabled: box.with(() => Boolean(disabled())),
    index: box.with(() => $$props.index),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_289();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group_item = hmr(Rating_group_item, () => Rating_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group_item[HMR].source;
    set(Rating_group_item[HMR].source, module.default[HMR].original);
  });
}
var rating_group_item_default = Rating_group_item;

// node_modules/bits-ui/dist/bits/scroll-area/exports.js
var exports_exports30 = {};
__export(exports_exports30, {
  Corner: () => scroll_area_corner_default,
  Root: () => scroll_area_default,
  Scrollbar: () => scroll_area_scrollbar_default,
  Thumb: () => scroll_area_thumb_default,
  Viewport: () => scroll_area_viewport_default
});

// node_modules/bits-ui/dist/internal/clamp.js
function clamp(n2, min, max) {
  return Math.min(max, Math.max(min, n2));
}

// node_modules/bits-ui/dist/bits/scroll-area/scroll-area.svelte.js
var scrollAreaAttrs = createBitsAttrs({
  component: "scroll-area",
  parts: [
    "root",
    "viewport",
    "corner",
    "thumb",
    "scrollbar"
  ]
});
var ScrollAreaRootContext = new Context("ScrollArea.Root");
var ScrollAreaScrollbarContext = new Context("ScrollArea.Scrollbar");
var ScrollAreaScrollbarVisibleContext = new Context("ScrollArea.ScrollbarVisible");
var ScrollAreaScrollbarAxisContext = new Context("ScrollArea.ScrollbarAxis");
var ScrollAreaScrollbarSharedContext = new Context("ScrollArea.ScrollbarShared");
var _scrollAreaNode, _viewportNode3, _contentNode10, _scrollbarXNode, _scrollbarYNode, _cornerWidth, _cornerHeight, _scrollbarXEnabled, _scrollbarYEnabled, _props123;
var _ScrollAreaRootState = class _ScrollAreaRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _scrollAreaNode, tag(state(null), "ScrollAreaRootState.scrollAreaNode"));
    __privateAdd(this, _viewportNode3, tag(state(null), "ScrollAreaRootState.viewportNode"));
    __privateAdd(this, _contentNode10, tag(state(null), "ScrollAreaRootState.contentNode"));
    __privateAdd(this, _scrollbarXNode, tag(state(null), "ScrollAreaRootState.scrollbarXNode"));
    __privateAdd(this, _scrollbarYNode, tag(state(null), "ScrollAreaRootState.scrollbarYNode"));
    __privateAdd(this, _cornerWidth, tag(state(0), "ScrollAreaRootState.cornerWidth"));
    __privateAdd(this, _cornerHeight, tag(state(0), "ScrollAreaRootState.cornerHeight"));
    __privateAdd(this, _scrollbarXEnabled, tag(state(false), "ScrollAreaRootState.scrollbarXEnabled"));
    __privateAdd(this, _scrollbarYEnabled, tag(state(false), "ScrollAreaRootState.scrollbarYEnabled"));
    __publicField(this, "domContext");
    __privateAdd(this, _props123, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        dir: this.opts.dir.current,
        style: {
          position: "relative",
          "--bits-scroll-area-corner-height": `${this.cornerHeight}px`,
          "--bits-scroll-area-corner-width": `${this.cornerWidth}px`
        },
        [scrollAreaAttrs.root]: "",
        ...this.attachment
      })),
      "ScrollAreaRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref, (v) => this.scrollAreaNode = v);
    this.domContext = new DOMContext(opts.ref);
  }
  static create(opts) {
    return ScrollAreaRootContext.set(new _ScrollAreaRootState(opts));
  }
  get scrollAreaNode() {
    return get(__privateGet(this, _scrollAreaNode));
  }
  set scrollAreaNode(value) {
    set(__privateGet(this, _scrollAreaNode), value, true);
  }
  get viewportNode() {
    return get(__privateGet(this, _viewportNode3));
  }
  set viewportNode(value) {
    set(__privateGet(this, _viewportNode3), value, true);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode10));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode10), value, true);
  }
  get scrollbarXNode() {
    return get(__privateGet(this, _scrollbarXNode));
  }
  set scrollbarXNode(value) {
    set(__privateGet(this, _scrollbarXNode), value, true);
  }
  get scrollbarYNode() {
    return get(__privateGet(this, _scrollbarYNode));
  }
  set scrollbarYNode(value) {
    set(__privateGet(this, _scrollbarYNode), value, true);
  }
  get cornerWidth() {
    return get(__privateGet(this, _cornerWidth));
  }
  set cornerWidth(value) {
    set(__privateGet(this, _cornerWidth), value, true);
  }
  get cornerHeight() {
    return get(__privateGet(this, _cornerHeight));
  }
  set cornerHeight(value) {
    set(__privateGet(this, _cornerHeight), value, true);
  }
  get scrollbarXEnabled() {
    return get(__privateGet(this, _scrollbarXEnabled));
  }
  set scrollbarXEnabled(value) {
    set(__privateGet(this, _scrollbarXEnabled), value, true);
  }
  get scrollbarYEnabled() {
    return get(__privateGet(this, _scrollbarYEnabled));
  }
  set scrollbarYEnabled(value) {
    set(__privateGet(this, _scrollbarYEnabled), value, true);
  }
  get props() {
    return get(__privateGet(this, _props123));
  }
  set props(value) {
    set(__privateGet(this, _props123), value);
  }
};
_scrollAreaNode = new WeakMap();
_viewportNode3 = new WeakMap();
_contentNode10 = new WeakMap();
_scrollbarXNode = new WeakMap();
_scrollbarYNode = new WeakMap();
_cornerWidth = new WeakMap();
_cornerHeight = new WeakMap();
_scrollbarXEnabled = new WeakMap();
_scrollbarYEnabled = new WeakMap();
_props123 = new WeakMap();
var ScrollAreaRootState = _ScrollAreaRootState;
var _contentId5, _contentRef, _props124, _contentProps;
var _ScrollAreaViewportState = class _ScrollAreaViewportState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _contentId5, box(useId()));
    __privateAdd(this, _contentRef, box(null));
    __publicField(this, "contentAttachment", attachRef(__privateGet(this, _contentRef), (v) => this.root.contentNode = v));
    __privateAdd(this, _props124, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: {
          overflowX: this.root.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: this.root.scrollbarYEnabled ? "scroll" : "hidden"
        },
        [scrollAreaAttrs.viewport]: "",
        ...this.attachment
      })),
      "ScrollAreaViewportState.props"
    ));
    __privateAdd(this, _contentProps, tag(
      user_derived(() => ({
        id: __privateGet(this, _contentId5).current,
        "data-scroll-area-content": "",
        /**
         * When horizontal scrollbar is visible: this element should be at least
         * as wide as its children for size calculations to work correctly.
         *
         * When horizontal scrollbar is NOT visible: this element's width should
         * be constrained by the parent container to enable `text-overflow: ellipsis`
         */
        style: {
          minWidth: this.root.scrollbarXEnabled ? "fit-content" : void 0
        },
        ...this.contentAttachment
      })),
      "ScrollAreaViewportState.contentProps"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.viewportNode = v);
  }
  static create(opts) {
    return new _ScrollAreaViewportState(opts, ScrollAreaRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props124));
  }
  set props(value) {
    set(__privateGet(this, _props124), value);
  }
  get contentProps() {
    return get(__privateGet(this, _contentProps));
  }
  set contentProps(value) {
    set(__privateGet(this, _contentProps), value);
  }
};
_contentId5 = new WeakMap();
_contentRef = new WeakMap();
_props124 = new WeakMap();
_contentProps = new WeakMap();
var ScrollAreaViewportState = _ScrollAreaViewportState;
var _isHorizontal2, _hasThumb;
var _ScrollAreaScrollbarState = class _ScrollAreaScrollbarState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __privateAdd(this, _isHorizontal2, tag(user_derived(() => strict_equals(this.opts.orientation.current, "horizontal")), "ScrollAreaScrollbarState.isHorizontal"));
    __privateAdd(this, _hasThumb, tag(state(false), "ScrollAreaScrollbarState.hasThumb"));
    this.opts = opts;
    this.root = root18;
    watch(() => this.isHorizontal, (isHorizontal) => {
      if (isHorizontal) {
        this.root.scrollbarXEnabled = true;
        return () => {
          this.root.scrollbarXEnabled = false;
        };
      } else {
        this.root.scrollbarYEnabled = true;
        return () => {
          this.root.scrollbarYEnabled = false;
        };
      }
    });
  }
  static create(opts) {
    return ScrollAreaScrollbarContext.set(new _ScrollAreaScrollbarState(opts, ScrollAreaRootContext.get()));
  }
  get isHorizontal() {
    return get(__privateGet(this, _isHorizontal2));
  }
  set isHorizontal(value) {
    set(__privateGet(this, _isHorizontal2), value);
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb));
  }
  set hasThumb(value) {
    set(__privateGet(this, _hasThumb), value, true);
  }
};
_isHorizontal2 = new WeakMap();
_hasThumb = new WeakMap();
var ScrollAreaScrollbarState = _ScrollAreaScrollbarState;
var _isVisible3, _props125;
var _ScrollAreaScrollbarHoverState = class _ScrollAreaScrollbarHoverState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _isVisible3, tag(state(false), "ScrollAreaScrollbarHoverState.isVisible"));
    __privateAdd(this, _props125, tag(
      user_derived(() => ({
        "data-state": this.isVisible ? "visible" : "hidden"
      })),
      "ScrollAreaScrollbarHoverState.props"
    ));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      const scrollAreaNode = this.root.scrollAreaNode;
      const hideDelay = this.root.opts.scrollHideDelay.current;
      let hideTimer = 0;
      if (!scrollAreaNode) return;
      const handlePointerEnter = () => {
        this.root.domContext.clearTimeout(hideTimer);
        untrack(() => this.isVisible = true);
      };
      const handlePointerLeave = () => {
        if (hideTimer) this.root.domContext.clearTimeout(hideTimer);
        hideTimer = this.root.domContext.setTimeout(
          () => {
            untrack(() => {
              this.scrollbar.hasThumb = false;
              this.isVisible = false;
            });
          },
          hideDelay
        );
      };
      const unsubListeners = executeCallbacks(on(scrollAreaNode, "pointerenter", handlePointerEnter), on(scrollAreaNode, "pointerleave", handlePointerLeave));
      return () => {
        this.root.domContext.getWindow().clearTimeout(hideTimer);
        unsubListeners();
      };
    });
  }
  static create() {
    return new _ScrollAreaScrollbarHoverState(ScrollAreaScrollbarContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible3));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible3), value, true);
  }
  get props() {
    return get(__privateGet(this, _props125));
  }
  set props(value) {
    set(__privateGet(this, _props125), value);
  }
};
_isVisible3 = new WeakMap();
_props125 = new WeakMap();
var ScrollAreaScrollbarHoverState = _ScrollAreaScrollbarHoverState;
var _isHidden, _props126;
var _ScrollAreaScrollbarScrollState = class _ScrollAreaScrollbarScrollState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __publicField(this, "machine", new StateMachine("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }));
    __privateAdd(this, _isHidden, tag(user_derived(() => strict_equals(this.machine.state.current, "hidden")), "ScrollAreaScrollbarScrollState.isHidden"));
    __privateAdd(this, _props126, tag(
      user_derived(() => ({
        "data-state": strict_equals(this.machine.state.current, "hidden") ? "hidden" : "visible",
        onpointerenter: this.onpointerenter,
        onpointerleave: this.onpointerleave
      })),
      "ScrollAreaScrollbarScrollState.props"
    ));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const debounceScrollend = useDebounce(() => this.machine.dispatch("SCROLL_END"), 100);
    user_effect(() => {
      const _state3 = this.machine.state.current;
      const scrollHideDelay = this.root.opts.scrollHideDelay.current;
      if (strict_equals(_state3, "idle")) {
        const hideTimer = this.root.domContext.setTimeout(() => this.machine.dispatch("HIDE"), scrollHideDelay);
        return () => this.root.domContext.clearTimeout(hideTimer);
      }
    });
    user_effect(() => {
      const viewportNode = this.root.viewportNode;
      if (!viewportNode) return;
      const scrollDirection = this.scrollbar.isHorizontal ? "scrollLeft" : "scrollTop";
      let prevScrollPos = viewportNode[scrollDirection];
      const handleScroll = () => {
        const scrollPos = viewportNode[scrollDirection];
        const hasScrollInDirectionChanged = strict_equals(prevScrollPos, scrollPos, false);
        if (hasScrollInDirectionChanged) {
          this.machine.dispatch("SCROLL");
          debounceScrollend();
        }
        prevScrollPos = scrollPos;
      };
      const unsubListener = addEventListener(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  static create() {
    return new _ScrollAreaScrollbarScrollState(ScrollAreaScrollbarContext.get());
  }
  get isHidden() {
    return get(__privateGet(this, _isHidden));
  }
  set isHidden(value) {
    set(__privateGet(this, _isHidden), value);
  }
  onpointerenter(_) {
    this.machine.dispatch("POINTER_ENTER");
  }
  onpointerleave(_) {
    this.machine.dispatch("POINTER_LEAVE");
  }
  get props() {
    return get(__privateGet(this, _props126));
  }
  set props(value) {
    set(__privateGet(this, _props126), value);
  }
};
_isHidden = new WeakMap();
_props126 = new WeakMap();
var ScrollAreaScrollbarScrollState = _ScrollAreaScrollbarScrollState;
var _isVisible4, _props127;
var _ScrollAreaScrollbarAutoState = class _ScrollAreaScrollbarAutoState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _isVisible4, tag(state(false), "ScrollAreaScrollbarAutoState.isVisible"));
    __privateAdd(this, _props127, tag(
      user_derived(() => ({
        "data-state": this.isVisible ? "visible" : "hidden"
      })),
      "ScrollAreaScrollbarAutoState.props"
    ));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const handleResize = useDebounce(
      () => {
        const viewportNode = this.root.viewportNode;
        if (!viewportNode) return;
        const isOverflowX = viewportNode.offsetWidth < viewportNode.scrollWidth;
        const isOverflowY = viewportNode.offsetHeight < viewportNode.scrollHeight;
        this.isVisible = this.scrollbar.isHorizontal ? isOverflowX : isOverflowY;
      },
      10
    );
    new SvelteResizeObserver(() => this.root.viewportNode, handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, handleResize);
  }
  static create() {
    return new _ScrollAreaScrollbarAutoState(ScrollAreaScrollbarContext.get());
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible4));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible4), value, true);
  }
  get props() {
    return get(__privateGet(this, _props127));
  }
  set props(value) {
    set(__privateGet(this, _props127), value);
  }
};
_isVisible4 = new WeakMap();
_props127 = new WeakMap();
var ScrollAreaScrollbarAutoState = _ScrollAreaScrollbarAutoState;
var _thumbNode, _pointerOffset, _sizes, _thumbRatio, _hasThumb2, _prevTransformStyle;
var _ScrollAreaScrollbarVisibleState = class _ScrollAreaScrollbarVisibleState {
  constructor(scrollbar) {
    __publicField(this, "scrollbar");
    __publicField(this, "root");
    __privateAdd(this, _thumbNode, tag(state(null), "ScrollAreaScrollbarVisibleState.thumbNode"));
    __privateAdd(this, _pointerOffset, tag(state(0), "ScrollAreaScrollbarVisibleState.pointerOffset"));
    __privateAdd(this, _sizes, tag(
      state({
        content: 0,
        viewport: 0,
        scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
      }),
      "ScrollAreaScrollbarVisibleState.sizes"
    ));
    __privateAdd(this, _thumbRatio, tag(user_derived(() => getThumbRatio(this.sizes.viewport, this.sizes.content)), "ScrollAreaScrollbarVisibleState.thumbRatio"));
    __privateAdd(this, _hasThumb2, tag(user_derived(() => Boolean(this.thumbRatio > 0 && this.thumbRatio < 1)), "ScrollAreaScrollbarVisibleState.hasThumb"));
    __privateAdd(this, _prevTransformStyle, tag(state(""), "ScrollAreaScrollbarVisibleState.prevTransformStyle"));
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      this.scrollbar.hasThumb = this.hasThumb;
    });
    user_effect(() => {
      if (!this.scrollbar.hasThumb && this.thumbNode) {
        this.prevTransformStyle = this.thumbNode.style.transform;
      }
    });
  }
  static create() {
    return ScrollAreaScrollbarVisibleContext.set(new _ScrollAreaScrollbarVisibleState(ScrollAreaScrollbarContext.get()));
  }
  get thumbNode() {
    return get(__privateGet(this, _thumbNode));
  }
  set thumbNode(value) {
    set(__privateGet(this, _thumbNode), value, true);
  }
  get pointerOffset() {
    return get(__privateGet(this, _pointerOffset));
  }
  set pointerOffset(value) {
    set(__privateGet(this, _pointerOffset), value, true);
  }
  get sizes() {
    return get(__privateGet(this, _sizes));
  }
  set sizes(value) {
    set(__privateGet(this, _sizes), value);
  }
  get thumbRatio() {
    return get(__privateGet(this, _thumbRatio));
  }
  set thumbRatio(value) {
    set(__privateGet(this, _thumbRatio), value);
  }
  get hasThumb() {
    return get(__privateGet(this, _hasThumb2));
  }
  set hasThumb(value) {
    set(__privateGet(this, _hasThumb2), value);
  }
  get prevTransformStyle() {
    return get(__privateGet(this, _prevTransformStyle));
  }
  set prevTransformStyle(value) {
    set(__privateGet(this, _prevTransformStyle), value, true);
  }
  setSizes(sizes) {
    this.sizes = sizes;
  }
  getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer({
      pointerPos,
      pointerOffset: this.pointerOffset,
      sizes: this.sizes,
      dir
    });
  }
  onThumbPointerUp() {
    this.pointerOffset = 0;
  }
  onThumbPointerDown(pointerPos) {
    this.pointerOffset = pointerPos;
  }
  xOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollLeft;
    const offset2 = getThumbOffsetFromScroll({
      scrollPos,
      sizes: this.sizes,
      dir: this.root.opts.dir.current
    });
    const transformStyle = `translate3d(${offset2}px, 0, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  xOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = scrollPos;
  }
  xOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
  yOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollTop;
    const offset2 = getThumbOffsetFromScroll({ scrollPos, sizes: this.sizes });
    const transformStyle = `translate3d(0, ${offset2}px, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  yOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = scrollPos;
  }
  yOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
};
_thumbNode = new WeakMap();
_pointerOffset = new WeakMap();
_sizes = new WeakMap();
_thumbRatio = new WeakMap();
_hasThumb2 = new WeakMap();
_prevTransformStyle = new WeakMap();
var ScrollAreaScrollbarVisibleState = _ScrollAreaScrollbarVisibleState;
var _computedStyle, _thumbSize, _props128;
var _ScrollAreaScrollbarXState = class _ScrollAreaScrollbarXState {
  constructor(opts, scrollbarVis) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __publicField(this, "scrollbar");
    __publicField(this, "attachment");
    __privateAdd(this, _computedStyle, tag(state(), "ScrollAreaScrollbarXState.computedStyle"));
    __publicField(this, "onThumbPointerDown", (pointerPos) => {
      this.scrollbarVis.onThumbPointerDown(pointerPos.x);
    });
    __publicField(this, "onDragScroll", (pointerPos) => {
      this.scrollbarVis.xOnDragScroll(pointerPos.x);
    });
    __publicField(this, "onThumbPointerUp", () => {
      this.scrollbarVis.onThumbPointerUp();
    });
    __publicField(this, "onThumbPositionChange", () => {
      this.scrollbarVis.xOnThumbPositionChange();
    });
    __publicField(this, "onWheelScroll", (e, maxScrollPos) => {
      if (!this.root.viewportNode) return;
      const scrollPos = this.root.viewportNode.scrollLeft + e.deltaX;
      this.scrollbarVis.xOnWheelScroll(scrollPos);
      if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
        e.preventDefault();
      }
    });
    __publicField(this, "onResize", () => {
      if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
      this.scrollbarVis.setSizes({
        content: this.root.viewportNode.scrollWidth,
        viewport: this.root.viewportNode.offsetWidth,
        scrollbar: {
          size: this.scrollbar.opts.ref.current.clientWidth,
          paddingStart: toInt(this.computedStyle.paddingLeft),
          paddingEnd: toInt(this.computedStyle.paddingRight)
        }
      });
    });
    __privateAdd(this, _thumbSize, tag(
      user_derived(() => {
        return getThumbSize(this.scrollbarVis.sizes);
      }),
      "ScrollAreaScrollbarXState.thumbSize"
    ));
    __privateAdd(this, _props128, tag(
      user_derived(() => ({
        id: this.scrollbar.opts.id.current,
        "data-orientation": "horizontal",
        style: {
          bottom: 0,
          left: strict_equals(this.root.opts.dir.current, "rtl") ? "var(--bits-scroll-area-corner-width)" : 0,
          right: strict_equals(this.root.opts.dir.current, "ltr") ? "var(--bits-scroll-area-corner-width)" : 0,
          "--bits-scroll-area-thumb-width": `${this.thumbSize}px`
        },
        ...this.attachment
      })),
      "ScrollAreaScrollbarXState.props"
    ));
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarXNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
  }
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarXState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle), value, true);
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize));
  }
  set thumbSize(value) {
    set(__privateGet(this, _thumbSize), value);
  }
  get props() {
    return get(__privateGet(this, _props128));
  }
  set props(value) {
    set(__privateGet(this, _props128), value);
  }
};
_computedStyle = new WeakMap();
_thumbSize = new WeakMap();
_props128 = new WeakMap();
var ScrollAreaScrollbarXState = _ScrollAreaScrollbarXState;
var _computedStyle2, _thumbSize2, _props129;
var _ScrollAreaScrollbarYState = class _ScrollAreaScrollbarYState {
  constructor(opts, scrollbarVis) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarVis");
    __publicField(this, "root");
    __publicField(this, "scrollbar");
    __publicField(this, "attachment");
    __privateAdd(this, _computedStyle2, tag(state(), "ScrollAreaScrollbarYState.computedStyle"));
    __privateAdd(this, _thumbSize2, tag(
      user_derived(() => {
        return getThumbSize(this.scrollbarVis.sizes);
      }),
      "ScrollAreaScrollbarYState.thumbSize"
    ));
    __privateAdd(this, _props129, tag(
      user_derived(() => ({
        id: this.scrollbar.opts.id.current,
        "data-orientation": "vertical",
        style: {
          top: 0,
          right: strict_equals(this.root.opts.dir.current, "ltr") ? 0 : void 0,
          left: strict_equals(this.root.opts.dir.current, "rtl") ? 0 : void 0,
          bottom: "var(--bits-scroll-area-corner-height)",
          "--bits-scroll-area-thumb-height": `${this.thumbSize}px`
        },
        ...this.attachment
      })),
      "ScrollAreaScrollbarYState.props"
    ));
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarYNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
    this.onThumbPointerDown = this.onThumbPointerDown.bind(this);
    this.onDragScroll = this.onDragScroll.bind(this);
    this.onThumbPointerUp = this.onThumbPointerUp.bind(this);
    this.onThumbPositionChange = this.onThumbPositionChange.bind(this);
    this.onWheelScroll = this.onWheelScroll.bind(this);
    this.onResize = this.onResize.bind(this);
  }
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarYState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  get computedStyle() {
    return get(__privateGet(this, _computedStyle2));
  }
  set computedStyle(value) {
    set(__privateGet(this, _computedStyle2), value, true);
  }
  onThumbPointerDown(pointerPos) {
    this.scrollbarVis.onThumbPointerDown(pointerPos.y);
  }
  onDragScroll(pointerPos) {
    this.scrollbarVis.yOnDragScroll(pointerPos.y);
  }
  onThumbPointerUp() {
    this.scrollbarVis.onThumbPointerUp();
  }
  onThumbPositionChange() {
    this.scrollbarVis.yOnThumbPositionChange();
  }
  onWheelScroll(e, maxScrollPos) {
    if (!this.root.viewportNode) return;
    const scrollPos = this.root.viewportNode.scrollTop + e.deltaY;
    this.scrollbarVis.yOnWheelScroll(scrollPos);
    if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
      e.preventDefault();
    }
  }
  onResize() {
    if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
    this.scrollbarVis.setSizes({
      content: this.root.viewportNode.scrollHeight,
      viewport: this.root.viewportNode.offsetHeight,
      scrollbar: {
        size: this.scrollbar.opts.ref.current.clientHeight,
        paddingStart: toInt(this.computedStyle.paddingTop),
        paddingEnd: toInt(this.computedStyle.paddingBottom)
      }
    });
  }
  get thumbSize() {
    return get(__privateGet(this, _thumbSize2));
  }
  set thumbSize(value) {
    set(__privateGet(this, _thumbSize2), value);
  }
  get props() {
    return get(__privateGet(this, _props129));
  }
  set props(value) {
    set(__privateGet(this, _props129), value);
  }
};
_computedStyle2 = new WeakMap();
_thumbSize2 = new WeakMap();
_props129 = new WeakMap();
var ScrollAreaScrollbarYState = _ScrollAreaScrollbarYState;
var _rect, _prevWebkitUserSelect, _maxScrollPos, _props130;
var _ScrollAreaScrollbarSharedState = class _ScrollAreaScrollbarSharedState {
  constructor(scrollbarState) {
    __publicField(this, "scrollbarState");
    __publicField(this, "root");
    __publicField(this, "scrollbarVis");
    __publicField(this, "scrollbar");
    __privateAdd(this, _rect, tag(state(null), "ScrollAreaScrollbarSharedState.rect"));
    __privateAdd(this, _prevWebkitUserSelect, tag(state(""), "ScrollAreaScrollbarSharedState.prevWebkitUserSelect"));
    __publicField(this, "handleResize");
    __publicField(this, "handleThumbPositionChange");
    __publicField(this, "handleWheelScroll");
    __publicField(this, "handleThumbPointerDown");
    __publicField(this, "handleThumbPointerUp");
    __privateAdd(this, _maxScrollPos, tag(user_derived(() => this.scrollbarVis.sizes.content - this.scrollbarVis.sizes.viewport), "ScrollAreaScrollbarSharedState.maxScrollPos"));
    __privateAdd(this, _props130, tag(
      user_derived(() => mergeProps({
        ...this.scrollbarState.props,
        style: {
          position: "absolute",
          ...this.scrollbarState.props.style
        },
        [scrollAreaAttrs.scrollbar]: "",
        onpointerdown: this.onpointerdown,
        onpointermove: this.onpointermove,
        onpointerup: this.onpointerup
      })),
      "ScrollAreaScrollbarSharedState.props"
    ));
    this.scrollbarState = scrollbarState;
    this.root = scrollbarState.root;
    this.scrollbarVis = scrollbarState.scrollbarVis;
    this.scrollbar = scrollbarState.scrollbarVis.scrollbar;
    this.handleResize = useDebounce(() => this.scrollbarState.onResize(), 10);
    this.handleThumbPositionChange = this.scrollbarState.onThumbPositionChange;
    this.handleWheelScroll = this.scrollbarState.onWheelScroll;
    this.handleThumbPointerDown = this.scrollbarState.onThumbPointerDown;
    this.handleThumbPointerUp = this.scrollbarState.onThumbPointerUp;
    user_effect(() => {
      const maxScrollPos = this.maxScrollPos;
      const scrollbarNode = this.scrollbar.opts.ref.current;
      this.root.viewportNode;
      const handleWheel = (e) => {
        const node = e.target;
        const isScrollbarWheel = scrollbarNode == null ? void 0 : scrollbarNode.contains(node);
        if (isScrollbarWheel) this.handleWheelScroll(e, maxScrollPos);
      };
      const unsubListener = addEventListener(this.root.domContext.getDocument(), "wheel", handleWheel, { passive: false });
      return unsubListener;
    });
    user_pre_effect(() => {
      this.scrollbarVis.sizes;
      untrack(() => this.handleThumbPositionChange());
    });
    new SvelteResizeObserver(() => this.scrollbar.opts.ref.current, this.handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, this.handleResize);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create() {
    return ScrollAreaScrollbarSharedContext.set(new _ScrollAreaScrollbarSharedState(ScrollAreaScrollbarAxisContext.get()));
  }
  get rect() {
    return get(__privateGet(this, _rect));
  }
  set rect(value) {
    set(__privateGet(this, _rect), value);
  }
  get prevWebkitUserSelect() {
    return get(__privateGet(this, _prevWebkitUserSelect));
  }
  set prevWebkitUserSelect(value) {
    set(__privateGet(this, _prevWebkitUserSelect), value, true);
  }
  get maxScrollPos() {
    return get(__privateGet(this, _maxScrollPos));
  }
  set maxScrollPos(value) {
    set(__privateGet(this, _maxScrollPos), value);
  }
  handleDragScroll(e) {
    if (!this.rect) return;
    const x = e.clientX - this.rect.left;
    const y = e.clientY - this.rect.top;
    this.scrollbarState.onDragScroll({ x, y });
  }
  onpointerdown(e) {
    var _a;
    if (strict_equals(e.button, 0, false)) return;
    const target = e.target;
    target.setPointerCapture(e.pointerId);
    this.rect = ((_a = this.scrollbar.opts.ref.current) == null ? void 0 : _a.getBoundingClientRect()) ?? null;
    this.prevWebkitUserSelect = this.root.domContext.getDocument().body.style.webkitUserSelect;
    this.root.domContext.getDocument().body.style.webkitUserSelect = "none";
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "auto";
    this.handleDragScroll(e);
  }
  onpointermove(e) {
    this.handleDragScroll(e);
  }
  onpointerup(e) {
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    this.root.domContext.getDocument().body.style.webkitUserSelect = this.prevWebkitUserSelect;
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "";
    this.rect = null;
  }
  get props() {
    return get(__privateGet(this, _props130));
  }
  set props(value) {
    set(__privateGet(this, _props130), value);
  }
};
_rect = new WeakMap();
_prevWebkitUserSelect = new WeakMap();
_maxScrollPos = new WeakMap();
_props130 = new WeakMap();
var ScrollAreaScrollbarSharedState = _ScrollAreaScrollbarSharedState;
var _root3, _removeUnlinkedScrollListener, _debounceScrollEnd, _props131;
var _ScrollAreaThumbImplState = class _ScrollAreaThumbImplState {
  constructor(opts, scrollbarState) {
    __publicField(this, "opts");
    __publicField(this, "scrollbarState");
    __publicField(this, "attachment");
    __privateAdd(this, _root3);
    __privateAdd(this, _removeUnlinkedScrollListener, tag(state(), "ScrollAreaThumbImplState.#removeUnlinkedScrollListener"));
    __privateAdd(this, _debounceScrollEnd, useDebounce(
      () => {
        if (get(__privateGet(this, _removeUnlinkedScrollListener))) {
          get(__privateGet(this, _removeUnlinkedScrollListener))();
          set(__privateGet(this, _removeUnlinkedScrollListener), void 0);
        }
      },
      100
    ));
    __privateAdd(this, _props131, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": this.scrollbarState.scrollbarVis.hasThumb ? "visible" : "hidden",
        style: {
          width: "var(--bits-scroll-area-thumb-width)",
          height: "var(--bits-scroll-area-thumb-height)",
          transform: this.scrollbarState.scrollbarVis.prevTransformStyle
        },
        onpointerdowncapture: this.onpointerdowncapture,
        onpointerup: this.onpointerup,
        [scrollAreaAttrs.thumb]: "",
        ...this.attachment
      })),
      "ScrollAreaThumbImplState.props"
    ));
    this.opts = opts;
    this.scrollbarState = scrollbarState;
    __privateSet(this, _root3, scrollbarState.root);
    this.attachment = attachRef(this.opts.ref, (v) => this.scrollbarState.scrollbarVis.thumbNode = v);
    user_effect(() => {
      const viewportNode = __privateGet(this, _root3).viewportNode;
      if (!viewportNode) return;
      const handleScroll = () => {
        __privateGet(this, _debounceScrollEnd).call(this);
        if (!get(__privateGet(this, _removeUnlinkedScrollListener))) {
          const listener = addUnlinkedScrollListener(viewportNode, this.scrollbarState.handleThumbPositionChange);
          set(__privateGet(this, _removeUnlinkedScrollListener), listener, true);
          this.scrollbarState.handleThumbPositionChange();
        }
      };
      untrack(() => this.scrollbarState.handleThumbPositionChange());
      const unsubListener = addEventListener(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerdowncapture = this.onpointerdowncapture.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  static create(opts) {
    return new _ScrollAreaThumbImplState(opts, ScrollAreaScrollbarSharedContext.get());
  }
  onpointerdowncapture(e) {
    const thumb = e.target;
    if (!thumb) return;
    const thumbRect = thumb.getBoundingClientRect();
    const x = e.clientX - thumbRect.left;
    const y = e.clientY - thumbRect.top;
    this.scrollbarState.handleThumbPointerDown({ x, y });
  }
  onpointerup(_) {
    this.scrollbarState.handleThumbPointerUp();
  }
  get props() {
    return get(__privateGet(this, _props131));
  }
  set props(value) {
    set(__privateGet(this, _props131), value);
  }
};
_root3 = new WeakMap();
_removeUnlinkedScrollListener = new WeakMap();
_debounceScrollEnd = new WeakMap();
_props131 = new WeakMap();
var ScrollAreaThumbImplState = _ScrollAreaThumbImplState;
var _width3, _height3, _hasSize, _props132;
var _ScrollAreaCornerImplState = class _ScrollAreaCornerImplState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _width3, tag(state(0), "ScrollAreaCornerImplState.#width"));
    __privateAdd(this, _height3, tag(state(0), "ScrollAreaCornerImplState.#height"));
    __privateAdd(this, _hasSize, tag(user_derived(() => Boolean(get(__privateGet(this, _width3)) && get(__privateGet(this, _height3)))), "ScrollAreaCornerImplState.hasSize"));
    __privateAdd(this, _props132, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        style: {
          width: get(__privateGet(this, _width3)),
          height: get(__privateGet(this, _height3)),
          position: "absolute",
          right: strict_equals(this.root.opts.dir.current, "ltr") ? 0 : void 0,
          left: strict_equals(this.root.opts.dir.current, "rtl") ? 0 : void 0,
          bottom: 0
        },
        [scrollAreaAttrs.corner]: "",
        ...this.attachment
      })),
      "ScrollAreaCornerImplState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.root.scrollbarXNode, () => {
      var _a;
      const height = ((_a = this.root.scrollbarXNode) == null ? void 0 : _a.offsetHeight) || 0;
      this.root.cornerHeight = height;
      set(__privateGet(this, _height3), height, true);
    });
    new SvelteResizeObserver(() => this.root.scrollbarYNode, () => {
      var _a;
      const width = ((_a = this.root.scrollbarYNode) == null ? void 0 : _a.offsetWidth) || 0;
      this.root.cornerWidth = width;
      set(__privateGet(this, _width3), width, true);
    });
  }
  static create(opts) {
    return new _ScrollAreaCornerImplState(opts, ScrollAreaRootContext.get());
  }
  get hasSize() {
    return get(__privateGet(this, _hasSize));
  }
  set hasSize(value) {
    set(__privateGet(this, _hasSize), value);
  }
  get props() {
    return get(__privateGet(this, _props132));
  }
  set props(value) {
    set(__privateGet(this, _props132), value);
  }
};
_width3 = new WeakMap();
_height3 = new WeakMap();
_hasSize = new WeakMap();
_props132 = new WeakMap();
var ScrollAreaCornerImplState = _ScrollAreaCornerImplState;
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer({
  pointerPos,
  pointerOffset,
  sizes,
  dir = "ltr"
}) {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll({ scrollPos, sizes, dir = "ltr" }) {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (strict_equals(input[0], input[1]) || strict_equals(output[0], output[1])) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function addUnlinkedScrollListener(node, handler) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  const win = getWindow(node);
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = strict_equals(prevPosition.left, position.left, false);
    const isVerticalScroll = strict_equals(prevPosition.top, position.top, false);
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = win.requestAnimationFrame(loop);
  })();
  return () => win.cancelAnimationFrame(rAF);
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte
Scroll_area[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte";
var root_290 = add_locations(from_html(`<div><!></div>`), Scroll_area[FILENAME], [[37, 1]]);
function Scroll_area($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "hover"), dir = prop($$props, "dir", 3, "ltr"), scrollHideDelay = prop($$props, "scrollHideDelay", 3, 600), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "type",
      "dir",
      "scrollHideDelay",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = ScrollAreaRootState.create({
    type: box.with(() => type()),
    dir: box.with(() => dir()),
    scrollHideDelay: box.with(() => scrollHideDelay()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_290();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area = hmr(Scroll_area, () => Scroll_area[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area[HMR].source;
    set(Scroll_area[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_default = Scroll_area;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte
Scroll_area_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte";
var root13 = add_locations(from_html(`<div><div><!></div></div>`), Scroll_area_viewport[FILENAME], [[28, 0, [[29, 1]]]]);
var $$css2 = {
  hash: "s-fbvr5voIYKY7",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\n	[data-scroll-area-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n	[data-scroll-area-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n\n	:where([data-scroll-area-viewport]) {\n		display: flex;\n		flex-direction: column;\n		align-items: stretch;\n	}\n	:where([data-scroll-area-content]) {\n		flex-grow: 1;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLWFyZWEtdmlld3BvcnQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbInNjcm9sbC1hcmVhLXZpZXdwb3J0LnN2ZWx0ZSJdfQ== */"
};
function Scroll_area_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_viewport);
  append_styles($$anchor, $$css2);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children"
    ],
    "restProps"
  );
  const viewportState = ScrollAreaViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  const mergedContentProps = tag(user_derived(() => mergeProps({}, viewportState.contentProps)), "mergedContentProps");
  var div = root13();
  attribute_effect(div, () => ({ ...get(mergedProps) }));
  var div_1 = child(div);
  attribute_effect(div_1, () => ({ ...get(mergedContentProps) }));
  var node = child(div_1);
  snippet(node, () => $$props.children ?? noop);
  reset(div_1);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_viewport = hmr(Scroll_area_viewport, () => Scroll_area_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-fbvr5voIYKY7");
    module.default[HMR].source = Scroll_area_viewport[HMR].source;
    set(Scroll_area_viewport[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_viewport_default = Scroll_area_viewport;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte
Scroll_area_scrollbar_shared[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte";
var root_291 = add_locations(from_html(`<div><!></div>`), Scroll_area_scrollbar_shared[FILENAME], [[16, 1]]);
function Scroll_area_scrollbar_shared($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_shared);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollbarSharedState = ScrollAreaScrollbarSharedState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarSharedState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_291();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_shared = hmr(Scroll_area_scrollbar_shared, () => Scroll_area_scrollbar_shared[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_shared[HMR].source;
    set(Scroll_area_scrollbar_shared[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_shared_default = Scroll_area_scrollbar_shared;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte
Scroll_area_scrollbar_x[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte";
function Scroll_area_scrollbar_x($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_x);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarXState = ScrollAreaScrollbarXState.create({ mounted: box.with(() => isMounted.current) });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarXState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_x = hmr(Scroll_area_scrollbar_x, () => Scroll_area_scrollbar_x[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_x[HMR].source;
    set(Scroll_area_scrollbar_x[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_x_default = Scroll_area_scrollbar_x;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte
Scroll_area_scrollbar_y[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte";
function Scroll_area_scrollbar_y($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_y);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarYState = ScrollAreaScrollbarYState.create({ mounted: box.with(() => isMounted.current) });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarYState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps)));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_y = hmr(Scroll_area_scrollbar_y, () => Scroll_area_scrollbar_y[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_y[HMR].source;
    set(Scroll_area_scrollbar_y[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_y_default = Scroll_area_scrollbar_y;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte
Scroll_area_scrollbar_visible[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte";
function Scroll_area_scrollbar_visible($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_visible);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const scrollbarVisibleState = ScrollAreaScrollbarVisibleState.create();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_x_default(node_1, spread_props(() => restProps));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      scroll_area_scrollbar_y_default(node_2, spread_props(() => restProps));
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (strict_equals(scrollbarVisibleState.scrollbar.opts.orientation.current, "horizontal")) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_visible = hmr(Scroll_area_scrollbar_visible, () => Scroll_area_scrollbar_visible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_visible[HMR].source;
    set(Scroll_area_scrollbar_visible[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_visible_default = Scroll_area_scrollbar_visible;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte
Scroll_area_scrollbar_auto[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte";
function Scroll_area_scrollbar_auto($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_auto);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarAutoState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => forceMount() || scrollbarAutoState.isVisible);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_auto, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarAutoState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_auto = hmr(Scroll_area_scrollbar_auto, () => Scroll_area_scrollbar_auto[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_auto[HMR].source;
    set(Scroll_area_scrollbar_auto[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_auto_default = Scroll_area_scrollbar_auto;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte
Scroll_area_scrollbar_scroll[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte";
function Scroll_area_scrollbar_scroll($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_scroll);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarScrollState = ScrollAreaScrollbarScrollState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarScrollState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => forceMount() || !scrollbarScrollState.isHidden);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_scroll, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, spread_props(() => get(mergedProps), {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarScrollState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_scroll = hmr(Scroll_area_scrollbar_scroll, () => Scroll_area_scrollbar_scroll[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_scroll[HMR].source;
    set(Scroll_area_scrollbar_scroll[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_scroll_default = Scroll_area_scrollbar_scroll;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte
Scroll_area_scrollbar_hover[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte";
function Scroll_area_scrollbar_hover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_hover);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarHoverState = ScrollAreaScrollbarHoverState.create();
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = tag(
    user_derived(() => mergeProps(restProps, scrollbarHoverState.props, scrollbarAutoState.props, {
      "data-state": scrollbarHoverState.isVisible ? "visible" : "hidden"
    })),
    "mergedProps"
  );
  const open = tag(user_derived(() => forceMount() || scrollbarHoverState.isVisible && scrollbarAutoState.isVisible), "open");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_hover, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps)));
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return get(open);
      },
      get ref() {
        return scrollbarAutoState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_hover = hmr(Scroll_area_scrollbar_hover, () => Scroll_area_scrollbar_hover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_hover[HMR].source;
    set(Scroll_area_scrollbar_hover[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_hover_default = Scroll_area_scrollbar_hover;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte
Scroll_area_scrollbar[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte";
function Scroll_area_scrollbar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation"
    ],
    "restProps"
  );
  const scrollbarState = ScrollAreaScrollbarState.create({
    orientation: box.with(() => $$props.orientation),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const type = tag(user_derived(() => scrollbarState.root.opts.type.current), "type");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      scroll_area_scrollbar_hover_default(node_1, spread_props(() => restProps, {
        get id() {
          return id();
        }
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2, $$elseif) => {
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          scroll_area_scrollbar_scroll_default(node_2, spread_props(() => restProps, {
            get id() {
              return id();
            }
          }));
          append($$anchor3, fragment_2);
        };
        var alternate_1 = ($$anchor3, $$elseif2) => {
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              scroll_area_scrollbar_auto_default(node_3, spread_props(() => restProps, {
                get id() {
                  return id();
                }
              }));
              append($$anchor4, fragment_3);
            };
            var alternate_2 = ($$anchor4, $$elseif3) => {
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  scroll_area_scrollbar_visible_default(node_4, spread_props(() => restProps, {
                    get id() {
                      return id();
                    }
                  }));
                  append($$anchor5, fragment_4);
                };
                if_block(
                  $$anchor4,
                  ($$render) => {
                    if (strict_equals(get(type), "always")) $$render(consequent_3);
                  },
                  $$elseif3
                );
              }
            };
            if_block(
              $$anchor3,
              ($$render) => {
                if (strict_equals(get(type), "auto")) $$render(consequent_2);
                else $$render(alternate_2, false);
              },
              $$elseif2
            );
          }
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (strict_equals(get(type), "scroll")) $$render(consequent_1);
            else $$render(alternate_1, false);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (strict_equals(get(type), "hover")) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar = hmr(Scroll_area_scrollbar, () => Scroll_area_scrollbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar[HMR].source;
    set(Scroll_area_scrollbar[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_default = Scroll_area_scrollbar;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte
Scroll_area_thumb_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte";
var root_292 = add_locations(from_html(`<div><!></div>`), Scroll_area_thumb_impl[FILENAME], [[42, 1]]);
function Scroll_area_thumb_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_thumb_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "present"
    ],
    "restProps"
  );
  const isMounted = new IsMounted();
  const thumbState = ScrollAreaThumbImplState.create({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v)),
    mounted: box.with(() => isMounted.current)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props, { style: { hidden: !$$props.present } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_292();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb_impl = hmr(Scroll_area_thumb_impl, () => Scroll_area_thumb_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb_impl[HMR].source;
    set(Scroll_area_thumb_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_impl_default = Scroll_area_thumb_impl;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte
Scroll_area_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte";
function Scroll_area_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_thumb);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount"
    ],
    "restProps"
  );
  const scrollbarState = ScrollAreaScrollbarVisibleContext.get();
  var fragment = comment();
  var node = first_child(fragment);
  const expression = user_derived(() => forceMount() || scrollbarState.hasThumb);
  {
    const presence = wrap_snippet(Scroll_area_thumb, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0 == null ? void 0 : $$arg0().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", scroll_area_thumb_impl_default, ref);
        scroll_area_thumb_impl_default(node_1, spread_props(() => restProps, {
          get id() {
            return id();
          },
          get present() {
            return present();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          }
        }));
      }
      append($$anchor2, fragment_1);
    });
    presence_layer_default(node, {
      get open() {
        return get(expression);
      },
      get ref() {
        return scrollbarState.scrollbar.opts.ref;
      },
      presence,
      $$slots: { presence: true }
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb = hmr(Scroll_area_thumb, () => Scroll_area_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb[HMR].source;
    set(Scroll_area_thumb[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_default = Scroll_area_thumb;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte
Scroll_area_corner_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte";
var root_293 = add_locations(from_html(`<div><!></div>`), Scroll_area_corner_impl[FILENAME], [[30, 1]]);
function Scroll_area_corner_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_corner_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const cornerState = ScrollAreaCornerImplState.create({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cornerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_293();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner_impl = hmr(Scroll_area_corner_impl, () => Scroll_area_corner_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner_impl[HMR].source;
    set(Scroll_area_corner_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_impl_default = Scroll_area_corner_impl;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte
Scroll_area_corner[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte";
function Scroll_area_corner($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_corner);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id"
    ],
    "restProps"
  );
  const scrollAreaState = ScrollAreaRootContext.get();
  const hasBothScrollbarsVisible = tag(user_derived(() => Boolean(scrollAreaState.scrollbarXNode && scrollAreaState.scrollbarYNode)), "hasBothScrollbarsVisible");
  const hasCorner = tag(user_derived(() => strict_equals(scrollAreaState.opts.type.current, "scroll", false) && get(hasBothScrollbarsVisible)), "hasCorner");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", scroll_area_corner_impl_default, ref);
        scroll_area_corner_impl_default(node_1, spread_props(() => restProps, {
          get id() {
            return id();
          },
          get ref() {
            return ref();
          },
          set ref($$value) {
            ref($$value);
          }
        }));
      }
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (get(hasCorner)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner = hmr(Scroll_area_corner, () => Scroll_area_corner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner[HMR].source;
    set(Scroll_area_corner[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_default = Scroll_area_corner;

// node_modules/bits-ui/dist/bits/select/exports.js
var exports_exports31 = {};
__export(exports_exports31, {
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => select_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Trigger: () => select_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/bits/select/components/select.svelte
Select[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select.svelte";
var root14 = add_locations(from_html(`<!> <!>`, 1), Select[FILENAME], []);
function Select($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, false);
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  let inputValue = tag(state(""), "inputValue");
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: false,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect()),
    inputValue: box.with(() => get(inputValue), (v) => set(inputValue, v, true)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = root14();
  var node = first_child(fragment);
  floating_layer_default(node, {
    children: wrap_snippet(Select, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => rootState.opts.value.current, (item) => item);
          each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
            var fragment_4 = comment();
            var node_5 = first_child(fragment_4);
            select_hidden_input_default(node_5, {
              get value() {
                return item;
              },
              get autocomplete() {
                return $$props.autocomplete;
              }
            });
            append($$anchor4, fragment_4);
          });
          append($$anchor3, fragment_3);
        };
        if_block(node_3, ($$render) => {
          if (rootState.opts.value.current.length) $$render(consequent);
        });
      }
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.opts.value.current as string}", () => rootState.opts.value, () => "current", 89, 20);
      select_hidden_input_default(node_6, {
        get autocomplete() {
          return $$props.autocomplete;
        },
        get value() {
          return rootState.opts.value.current;
        },
        set value($$value) {
          rootState.opts.value.current = $$value;
        }
      });
      append($$anchor2, fragment_5);
    };
    if_block(node_2, ($$render) => {
      if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var select_default = Select;

// node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte
Select_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte";
var root_320 = add_locations(from_html(`<button><!></button>`), Select_trigger[FILENAME], [[34, 2]]);
function Select_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = SelectTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
    FloatingLayer_Anchor($$anchor2, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Select_trigger, ($$anchor3, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
            append($$anchor4, fragment_2);
          };
          var alternate = ($$anchor4) => {
            var button = root_320();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            snippet(node_3, () => $$props.children ?? noop);
            reset(button);
            append($$anchor4, button);
          };
          if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          });
        }
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_trigger = hmr(Select_trigger, () => Select_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_trigger[HMR].source;
    set(Select_trigger[HMR].source, module.default[HMR].original);
  });
}
var select_trigger_default = Select_trigger;

// node_modules/bits-ui/dist/bits/separator/exports.js
var exports_exports32 = {};
__export(exports_exports32, {
  Root: () => separator_default
});

// node_modules/bits-ui/dist/bits/slider/exports.js
var exports_exports33 = {};
__export(exports_exports33, {
  Range: () => slider_range_default,
  Root: () => slider_default,
  Thumb: () => slider_thumb_default,
  ThumbLabel: () => slider_thumb_label_default,
  Tick: () => slider_tick_default,
  TickLabel: () => slider_tick_label_default
});

// node_modules/bits-ui/dist/bits/slider/helpers.js
function getRangeStyles(direction, min, max) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${min}%`;
    styles.right = `${max}%`;
  } else if (direction === "rl") {
    styles.right = `${min}%`;
    styles.left = `${max}%`;
  } else if (direction === "bt") {
    styles.bottom = `${min}%`;
    styles.top = `${max}%`;
  } else {
    styles.top = `${min}%`;
    styles.bottom = `${max}%`;
  }
  return styles;
}
function getThumbStyles(direction, thumbPos) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${thumbPos}%`;
    styles.translate = "-50% 0";
  } else if (direction === "rl") {
    styles.right = `${thumbPos}%`;
    styles.translate = "50% 0";
  } else if (direction === "bt") {
    styles.bottom = `${thumbPos}%`;
    styles.translate = "0 50%";
  } else {
    styles.top = `${thumbPos}%`;
    styles.translate = "0 -50%";
  }
  return styles;
}
function getTickStyles(direction, tickPosition, offsetPercentage) {
  const style = {
    position: "absolute"
  };
  if (direction === "lr") {
    style.left = `${tickPosition}%`;
    style.translate = `${offsetPercentage}% 0`;
  } else if (direction === "rl") {
    style.right = `${tickPosition}%`;
    style.translate = `${-offsetPercentage}% 0`;
  } else if (direction === "bt") {
    style.bottom = `${tickPosition}%`;
    style.translate = `0 ${-offsetPercentage}%`;
  } else {
    style.top = `${tickPosition}%`;
    style.translate = `0 ${offsetPercentage}%`;
  }
  return style;
}
function getTickLabelStyles(direction, tickPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${tickPosition}%` : void 0;
    style.right = direction === "rl" ? `${tickPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${tickPosition}%`;
    } else {
      style.bottom = `${tickPosition}%`;
    }
    style.translate = "0 50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getThumbLabelStyles(direction, thumbPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${thumbPosition}%` : void 0;
    style.right = direction === "rl" ? `${thumbPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${thumbPosition}%`;
    } else {
      style.bottom = `${thumbPosition}%`;
    }
    style.translate = "0 -50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getDecimalPlaces(num) {
  if (Math.floor(num) === num)
    return 0;
  const str = num.toString();
  if (str.indexOf(".") !== -1 && str.indexOf("e-") === -1) {
    return str.split(".")[1].length;
  } else if (str.indexOf("e-") !== -1) {
    const parts = str.split("e-");
    return parseInt(parts[1], 10);
  }
  return 0;
}
function roundToPrecision(num, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
}
function normalizeSteps(step, min, max) {
  if (typeof step === "number") {
    const difference = max - min;
    let count = Math.ceil(difference / step);
    const precision = getDecimalPlaces(step);
    const factor = Math.pow(10, precision);
    const intDifference = Math.round(difference * factor);
    const intStep = Math.round(step * factor);
    if (intDifference % intStep === 0) {
      count++;
    }
    const steps = [];
    for (let i = 0; i < count; i++) {
      const value = min + i * step;
      const roundedValue = roundToPrecision(value, precision);
      steps.push(roundedValue);
    }
    return steps;
  }
  return [...new Set(step)].filter((value) => value >= min && value <= max).sort((a2, b) => a2 - b);
}
function snapValueToCustomSteps(value, steps) {
  if (steps.length === 0)
    return value;
  let closest = steps[0];
  let minDistance = Math.abs(value - closest);
  for (const step of steps) {
    const distance = Math.abs(value - step);
    if (distance < minDistance) {
      minDistance = distance;
      closest = step;
    }
  }
  return closest;
}
function getAdjacentStepValue(currentValue, steps, direction) {
  const currentIndex = steps.indexOf(currentValue);
  if (currentIndex === -1) {
    return snapValueToCustomSteps(currentValue, steps);
  }
  if (direction === "next") {
    return currentIndex < steps.length - 1 ? steps[currentIndex + 1] : currentValue;
  } else {
    return currentIndex > 0 ? steps[currentIndex - 1] : currentValue;
  }
}

// node_modules/bits-ui/dist/internal/math.js
function linearScale2(domain, range, clamp2 = true) {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const slope = (r1 - r0) / (d1 - d0);
  return (x) => {
    const result = r0 + slope * (x - d0);
    if (!clamp2)
      return result;
    if (result > Math.max(r0, r1))
      return Math.max(r0, r1);
    if (result < Math.min(r0, r1))
      return Math.min(r0, r1);
    return result;
  };
}

// node_modules/bits-ui/dist/bits/slider/slider.svelte.js
var sliderAttrs = createBitsAttrs({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
});
var SliderRootContext = new Context("Slider.Root");
var _isActive3, _direction, _normalizedSteps, _touchAction, _props133;
var SliderBaseRootState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _isActive3, tag(state(false), "SliderBaseRootState.isActive"));
    __privateAdd(this, _direction, tag(
      user_derived(() => {
        if (strict_equals(this.opts.orientation.current, "horizontal")) {
          return strict_equals(this.opts.dir.current, "rtl") ? "rl" : "lr";
        } else {
          return strict_equals(this.opts.dir.current, "rtl") ? "tb" : "bt";
        }
      }),
      "SliderBaseRootState.direction"
    ));
    __privateAdd(this, _normalizedSteps, tag(
      user_derived(() => {
        return normalizeSteps(this.opts.step.current, this.opts.min.current, this.opts.max.current);
      }),
      "SliderBaseRootState.normalizedSteps"
    ));
    __publicField(this, "domContext");
    __privateAdd(this, _touchAction, tag(
      user_derived(() => {
        if (this.opts.disabled.current) return void 0;
        return strict_equals(this.opts.orientation.current, "horizontal") ? "pan-y" : "pan-x";
      }),
      "SliderBaseRootState.#touchAction"
    ));
    __publicField(this, "getAllThumbs", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      return Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
    });
    __publicField(this, "getThumbScale", () => {
      var _a, _b, _c;
      const trackPadding = (_a = this.opts.trackPadding) == null ? void 0 : _a.current;
      if (strict_equals(trackPadding, void 0, false) && trackPadding > 0) {
        return [trackPadding, 100 - trackPadding];
      }
      if (strict_equals(this.opts.thumbPositioning.current, "exact")) {
        return [0, 100];
      }
      const isVertical = strict_equals(this.opts.orientation.current, "vertical");
      const activeThumb = this.getAllThumbs()[0];
      const thumbSize = isVertical ? activeThumb == null ? void 0 : activeThumb.offsetHeight : activeThumb == null ? void 0 : activeThumb.offsetWidth;
      if (strict_equals(thumbSize, void 0) || Number.isNaN(thumbSize) || strict_equals(thumbSize, 0)) return [0, 100];
      const trackSize = isVertical ? (_b = this.opts.ref.current) == null ? void 0 : _b.offsetHeight : (_c = this.opts.ref.current) == null ? void 0 : _c.offsetWidth;
      if (strict_equals(trackSize, void 0) || Number.isNaN(trackSize) || strict_equals(trackSize, 0)) return [0, 100];
      const percentPadding = thumbSize / 2 / trackSize * 100;
      const min = percentPadding;
      const max = 100 - percentPadding;
      return [min, max];
    });
    __publicField(this, "getPositionFromValue", (thumbValue) => {
      const thumbScale = this.getThumbScale();
      const scale = linearScale2([this.opts.min.current, this.opts.max.current], thumbScale);
      return scale(thumbValue);
    });
    __privateAdd(this, _props133, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        style: { touchAction: get(__privateGet(this, _touchAction)) },
        [sliderAttrs.root]: "",
        ...this.attachment
      })),
      "SliderBaseRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
  }
  get isActive() {
    return get(__privateGet(this, _isActive3));
  }
  set isActive(value) {
    set(__privateGet(this, _isActive3), value, true);
  }
  get direction() {
    return get(__privateGet(this, _direction));
  }
  set direction(value) {
    set(__privateGet(this, _direction), value);
  }
  get normalizedSteps() {
    return get(__privateGet(this, _normalizedSteps));
  }
  set normalizedSteps(value) {
    set(__privateGet(this, _normalizedSteps), value);
  }
  isThumbActive(_index) {
    return this.isActive;
  }
  get props() {
    return get(__privateGet(this, _props133));
  }
  set props(value) {
    set(__privateGet(this, _props133), value);
  }
};
_isActive3 = new WeakMap();
_direction = new WeakMap();
_normalizedSteps = new WeakMap();
_touchAction = new WeakMap();
_props133 = new WeakMap();
var _thumbsPropsArr, _thumbsRenderArr, _ticksPropsArr, _ticksRenderArr, _tickItemsArr, _thumbItemsArr, _snippetProps25;
var SliderSingleRootState = class extends SliderBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __publicField(this, "isTickValueSelected", (tickValue) => {
      return strict_equals(this.opts.value.current, tickValue);
    });
    __publicField(this, "updateValue", (newValue) => {
      this.opts.value.current = snapValueToCustomSteps(newValue, this.normalizedSteps);
    });
    __publicField(this, "handlePointerMove", (e) => {
      if (!this.isActive || this.opts.disabled.current) return;
      e.preventDefault();
      e.stopPropagation();
      const sliderNode = this.opts.ref.current;
      const activeThumb = this.getAllThumbs()[0];
      if (!sliderNode || !activeThumb) return;
      activeThumb.focus();
      const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
      if (strict_equals(this.direction, "lr")) {
        this.applyPosition({ clientXY: e.clientX, start: left, end: right });
      } else if (strict_equals(this.direction, "rl")) {
        this.applyPosition({ clientXY: e.clientX, start: right, end: left });
      } else if (strict_equals(this.direction, "bt")) {
        this.applyPosition({ clientXY: e.clientY, start: bottom, end: top });
      } else if (strict_equals(this.direction, "tb")) {
        this.applyPosition({ clientXY: e.clientY, start: top, end: bottom });
      }
    });
    __publicField(this, "handlePointerDown", (e) => {
      if (strict_equals(e.button, 0, false) || this.opts.disabled.current) return;
      const sliderNode = this.opts.ref.current;
      const closestThumb = this.getAllThumbs()[0];
      if (!closestThumb || !sliderNode) return;
      const target = e.composedPath()[0] ?? e.target;
      if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
      e.preventDefault();
      closestThumb.focus();
      this.isActive = true;
      this.handlePointerMove(e);
    });
    __publicField(this, "handlePointerUp", () => {
      if (this.opts.disabled.current) return;
      if (this.isActive) {
        this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
      }
      this.isActive = false;
    });
    __privateAdd(this, _thumbsPropsArr, tag(
      user_derived(() => {
        const currValue = this.opts.value.current;
        return Array.from({ length: 1 }, () => {
          const thumbValue = currValue;
          const thumbPosition = this.getPositionFromValue(thumbValue);
          const style = getThumbStyles(this.direction, thumbPosition);
          return {
            role: "slider",
            "aria-valuemin": this.opts.min.current,
            "aria-valuemax": this.opts.max.current,
            "aria-valuenow": thumbValue,
            "aria-disabled": getAriaDisabled(this.opts.disabled.current),
            "aria-orientation": getAriaOrientation(this.opts.orientation.current),
            "data-value": thumbValue,
            "data-orientation": getDataOrientation(this.opts.orientation.current),
            style,
            [sliderAttrs.thumb]: ""
          };
        });
      }),
      "SliderSingleRootState.thumbsPropsArr"
    ));
    __privateAdd(this, _thumbsRenderArr, tag(
      user_derived(() => {
        return this.thumbsPropsArr.map((_, i) => i);
      }),
      "SliderSingleRootState.thumbsRenderArr"
    ));
    __privateAdd(this, _ticksPropsArr, tag(
      user_derived(() => {
        const steps = this.normalizedSteps;
        const currValue = this.opts.value.current;
        return steps.map((tickValue, i) => {
          const tickPosition = this.getPositionFromValue(tickValue);
          const isFirst = strict_equals(i, 0);
          const isLast = strict_equals(i, steps.length - 1);
          const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
          const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
          const bounded = tickValue <= currValue;
          return {
            "data-disabled": getDataDisabled(this.opts.disabled.current),
            "data-orientation": getDataOrientation(this.opts.orientation.current),
            "data-bounded": bounded ? "" : void 0,
            "data-value": tickValue,
            "data-selected": this.isTickValueSelected(tickValue) ? "" : void 0,
            style,
            [sliderAttrs.tick]: ""
          };
        });
      }),
      "SliderSingleRootState.ticksPropsArr"
    ));
    __privateAdd(this, _ticksRenderArr, tag(
      user_derived(() => {
        return this.ticksPropsArr.map((_, i) => i);
      }),
      "SliderSingleRootState.ticksRenderArr"
    ));
    __privateAdd(this, _tickItemsArr, tag(
      user_derived(() => {
        return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
      }),
      "SliderSingleRootState.tickItemsArr"
    ));
    __privateAdd(this, _thumbItemsArr, tag(
      user_derived(() => {
        const currValue = this.opts.value.current;
        return [{ value: currValue, index: 0 }];
      }),
      "SliderSingleRootState.thumbItemsArr"
    ));
    __privateAdd(this, _snippetProps25, tag(
      user_derived(() => ({
        ticks: this.ticksRenderArr,
        thumbs: this.thumbsRenderArr,
        tickItems: this.tickItemsArr,
        thumbItems: this.thumbItemsArr
      })),
      "SliderSingleRootState.snippetProps"
    ));
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (!isValidValue(value)) {
          this.opts.value.current = gcv(value);
        }
      }
    );
  }
  applyPosition({ clientXY, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min);
    } else if (val > max) {
      this.updateValue(max);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue);
    }
  }
  get thumbsPropsArr() {
    return get(__privateGet(this, _thumbsPropsArr));
  }
  set thumbsPropsArr(value) {
    set(__privateGet(this, _thumbsPropsArr), value);
  }
  get thumbsRenderArr() {
    return get(__privateGet(this, _thumbsRenderArr));
  }
  set thumbsRenderArr(value) {
    set(__privateGet(this, _thumbsRenderArr), value);
  }
  get ticksPropsArr() {
    return get(__privateGet(this, _ticksPropsArr));
  }
  set ticksPropsArr(value) {
    set(__privateGet(this, _ticksPropsArr), value);
  }
  get ticksRenderArr() {
    return get(__privateGet(this, _ticksRenderArr));
  }
  set ticksRenderArr(value) {
    set(__privateGet(this, _ticksRenderArr), value);
  }
  get tickItemsArr() {
    return get(__privateGet(this, _tickItemsArr));
  }
  set tickItemsArr(value) {
    set(__privateGet(this, _tickItemsArr), value);
  }
  get thumbItemsArr() {
    return get(__privateGet(this, _thumbItemsArr));
  }
  set thumbItemsArr(value) {
    set(__privateGet(this, _thumbItemsArr), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps25));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps25), value);
  }
};
_thumbsPropsArr = new WeakMap();
_thumbsRenderArr = new WeakMap();
_ticksPropsArr = new WeakMap();
_ticksRenderArr = new WeakMap();
_tickItemsArr = new WeakMap();
_thumbItemsArr = new WeakMap();
_snippetProps25 = new WeakMap();
var _activeThumb, _currentThumbIdx, _getClosestThumb, _thumbsPropsArr2, _thumbsRenderArr2, _ticksPropsArr2, _ticksRenderArr2, _tickItemsArr2, _thumbItemsArr2, _snippetProps26;
var SliderMultiRootState = class extends SliderBaseRootState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _activeThumb, tag(state(null), "SliderMultiRootState.activeThumb"));
    __privateAdd(this, _currentThumbIdx, tag(state(0), "SliderMultiRootState.currentThumbIdx"));
    __publicField(this, "isTickValueSelected", (tickValue) => {
      return this.opts.value.current.includes(tickValue);
    });
    __privateAdd(this, _getClosestThumb, (e) => {
      const thumbs = this.getAllThumbs();
      if (!thumbs.length) return;
      for (const thumb of thumbs) {
        thumb.blur();
      }
      const distances = thumbs.map((thumb) => {
        if (strict_equals(this.opts.orientation.current, "horizontal")) {
          const { left, right } = thumb.getBoundingClientRect();
          return Math.abs(e.clientX - (left + right) / 2);
        } else {
          const { top, bottom } = thumb.getBoundingClientRect();
          return Math.abs(e.clientY - (top + bottom) / 2);
        }
      });
      const node = thumbs[distances.indexOf(Math.min(...distances))];
      const idx = thumbs.indexOf(node);
      return { node, idx };
    });
    __publicField(this, "handlePointerMove", (e) => {
      if (!this.isActive || this.opts.disabled.current) return;
      e.preventDefault();
      e.stopPropagation();
      const sliderNode = this.opts.ref.current;
      const activeThumb = this.activeThumb;
      if (!sliderNode || !activeThumb) return;
      activeThumb.node.focus();
      const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
      const direction = this.direction;
      if (strict_equals(direction, "lr")) {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: left,
          end: right
        });
      } else if (strict_equals(direction, "rl")) {
        this.applyPosition({
          clientXY: e.clientX,
          activeThumbIdx: activeThumb.idx,
          start: right,
          end: left
        });
      } else if (strict_equals(direction, "bt")) {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: bottom,
          end: top
        });
      } else if (strict_equals(direction, "tb")) {
        this.applyPosition({
          clientXY: e.clientY,
          activeThumbIdx: activeThumb.idx,
          start: top,
          end: bottom
        });
      }
    });
    __publicField(this, "handlePointerDown", (e) => {
      if (strict_equals(e.button, 0, false) || this.opts.disabled.current) return;
      const sliderNode = this.opts.ref.current;
      const closestThumb = __privateGet(this, _getClosestThumb).call(this, e);
      if (!closestThumb || !sliderNode) return;
      const target = e.composedPath()[0] ?? e.target;
      if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
      e.preventDefault();
      this.activeThumb = closestThumb;
      closestThumb.node.focus();
      this.isActive = true;
      this.handlePointerMove(e);
    });
    __publicField(this, "handlePointerUp", () => {
      if (this.opts.disabled.current) return;
      if (this.isActive) {
        this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
      }
      this.isActive = false;
    });
    __publicField(this, "getAllThumbs", () => {
      const node = this.opts.ref.current;
      if (!node) return [];
      const thumbs = Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
      return thumbs;
    });
    __publicField(this, "updateValue", (thumbValue, idx) => {
      const currValue = this.opts.value.current;
      if (!currValue.length) {
        this.opts.value.current.push(thumbValue);
        return;
      }
      const valueAtIndex = currValue[idx];
      if (strict_equals(valueAtIndex, thumbValue)) return;
      const newValue = [...currValue];
      if (!isValidIndex(idx, newValue)) return;
      const direction = newValue[idx] > thumbValue ? -1 : 1;
      const swap = () => {
        var _a;
        const diffIndex = idx + direction;
        newValue[idx] = newValue[diffIndex];
        newValue[diffIndex] = thumbValue;
        const thumbs = this.getAllThumbs();
        if (!thumbs.length) return;
        (_a = thumbs[diffIndex]) == null ? void 0 : _a.focus();
        this.activeThumb = { node: thumbs[diffIndex], idx: diffIndex };
      };
      if (this.opts.autoSort.current && (strict_equals(direction, -1) && thumbValue < newValue[idx - 1] || strict_equals(direction, 1) && thumbValue > newValue[idx + 1])) {
        swap();
        this.opts.value.current = newValue;
        return;
      }
      const steps = this.normalizedSteps;
      newValue[idx] = snapValueToCustomSteps(thumbValue, steps);
      this.opts.value.current = newValue;
    });
    __privateAdd(this, _thumbsPropsArr2, tag(
      user_derived(() => {
        const currValue = this.opts.value.current;
        return Array.from({ length: currValue.length || 1 }, (_, i) => {
          const currThumb = untrack(() => this.currentThumbIdx);
          if (currThumb < currValue.length) {
            untrack(() => {
              this.currentThumbIdx = currThumb + 1;
            });
          }
          const thumbValue = currValue[i];
          const thumbPosition = this.getPositionFromValue(thumbValue ?? 0);
          const style = getThumbStyles(this.direction, thumbPosition);
          return {
            role: "slider",
            "aria-valuemin": this.opts.min.current,
            "aria-valuemax": this.opts.max.current,
            "aria-valuenow": thumbValue,
            "aria-disabled": getAriaDisabled(this.opts.disabled.current),
            "aria-orientation": getAriaOrientation(this.opts.orientation.current),
            "data-value": thumbValue,
            "data-orientation": getDataOrientation(this.opts.orientation.current),
            style,
            [sliderAttrs.thumb]: ""
          };
        });
      }),
      "SliderMultiRootState.thumbsPropsArr"
    ));
    __privateAdd(this, _thumbsRenderArr2, tag(
      user_derived(() => {
        return this.thumbsPropsArr.map((_, i) => i);
      }),
      "SliderMultiRootState.thumbsRenderArr"
    ));
    __privateAdd(this, _ticksPropsArr2, tag(
      user_derived(() => {
        const steps = this.normalizedSteps;
        const currValue = this.opts.value.current;
        return steps.map((tickValue, i) => {
          const tickPosition = this.getPositionFromValue(tickValue);
          const isFirst = strict_equals(i, 0);
          const isLast = strict_equals(i, steps.length - 1);
          const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
          const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
          const bounded = strict_equals(currValue.length, 1) ? tickValue <= currValue[0] : currValue[0] <= tickValue && tickValue <= currValue[currValue.length - 1];
          return {
            "data-disabled": getDataDisabled(this.opts.disabled.current),
            "data-orientation": getDataOrientation(this.opts.orientation.current),
            "data-bounded": bounded ? "" : void 0,
            "data-value": tickValue,
            style,
            [sliderAttrs.tick]: ""
          };
        });
      }),
      "SliderMultiRootState.ticksPropsArr"
    ));
    __privateAdd(this, _ticksRenderArr2, tag(
      user_derived(() => {
        return this.ticksPropsArr.map((_, i) => i);
      }),
      "SliderMultiRootState.ticksRenderArr"
    ));
    __privateAdd(this, _tickItemsArr2, tag(
      user_derived(() => {
        return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
      }),
      "SliderMultiRootState.tickItemsArr"
    ));
    __privateAdd(this, _thumbItemsArr2, tag(
      user_derived(() => {
        const currValue = this.opts.value.current;
        return currValue.map((value, index) => ({ value, index }));
      }),
      "SliderMultiRootState.thumbItemsArr"
    ));
    __privateAdd(this, _snippetProps26, tag(
      user_derived(() => ({
        ticks: this.ticksRenderArr,
        thumbs: this.thumbsRenderArr,
        tickItems: this.tickItemsArr,
        thumbItems: this.thumbItemsArr
      })),
      "SliderMultiRootState.snippetProps"
    ));
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (value.some((v) => !isValidValue(v))) {
          this.opts.value.current = value.map(gcv);
        }
      }
    );
  }
  get activeThumb() {
    return get(__privateGet(this, _activeThumb));
  }
  set activeThumb(value) {
    set(__privateGet(this, _activeThumb), value, true);
  }
  get currentThumbIdx() {
    return get(__privateGet(this, _currentThumbIdx));
  }
  set currentThumbIdx(value) {
    set(__privateGet(this, _currentThumbIdx), value, true);
  }
  isThumbActive(index) {
    var _a;
    return this.isActive && strict_equals((_a = this.activeThumb) == null ? void 0 : _a.idx, index);
  }
  applyPosition({ clientXY, activeThumbIdx, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min, activeThumbIdx);
    } else if (val > max) {
      this.updateValue(max, activeThumbIdx);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue, activeThumbIdx);
    }
  }
  get thumbsPropsArr() {
    return get(__privateGet(this, _thumbsPropsArr2));
  }
  set thumbsPropsArr(value) {
    set(__privateGet(this, _thumbsPropsArr2), value);
  }
  get thumbsRenderArr() {
    return get(__privateGet(this, _thumbsRenderArr2));
  }
  set thumbsRenderArr(value) {
    set(__privateGet(this, _thumbsRenderArr2), value);
  }
  get ticksPropsArr() {
    return get(__privateGet(this, _ticksPropsArr2));
  }
  set ticksPropsArr(value) {
    set(__privateGet(this, _ticksPropsArr2), value);
  }
  get ticksRenderArr() {
    return get(__privateGet(this, _ticksRenderArr2));
  }
  set ticksRenderArr(value) {
    set(__privateGet(this, _ticksRenderArr2), value);
  }
  get tickItemsArr() {
    return get(__privateGet(this, _tickItemsArr2));
  }
  set tickItemsArr(value) {
    set(__privateGet(this, _tickItemsArr2), value);
  }
  get thumbItemsArr() {
    return get(__privateGet(this, _thumbItemsArr2));
  }
  set thumbItemsArr(value) {
    set(__privateGet(this, _thumbItemsArr2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps26));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps26), value);
  }
};
_activeThumb = new WeakMap();
_currentThumbIdx = new WeakMap();
_getClosestThumb = new WeakMap();
_thumbsPropsArr2 = new WeakMap();
_thumbsRenderArr2 = new WeakMap();
_ticksPropsArr2 = new WeakMap();
_ticksRenderArr2 = new WeakMap();
_tickItemsArr2 = new WeakMap();
_thumbItemsArr2 = new WeakMap();
_snippetProps26 = new WeakMap();
var SliderRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = strict_equals(type, "single") ? new SliderSingleRootState(rest) : new SliderMultiRootState(rest);
    return SliderRootContext.set(rootState);
  }
};
var VALID_SLIDER_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.HOME,
  kbd_constants_exports.END
];
var _rangeStyles, _props134;
var _SliderRangeState = class _SliderRangeState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _rangeStyles, tag(
      user_derived(() => {
        var _a;
        if (Array.isArray(this.root.opts.value.current)) {
          const min = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0;
          const max = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
          return {
            position: "absolute",
            ...getRangeStyles(this.root.direction, min, max)
          };
        } else {
          const trackPadding = (_a = this.root.opts.trackPadding) == null ? void 0 : _a.current;
          const currentValue = this.root.opts.value.current;
          const maxValue = this.root.opts.max.current;
          const min = 0;
          const max = strict_equals(trackPadding, void 0, false) && trackPadding > 0 && strict_equals(currentValue, maxValue) ? 0 : 100 - this.root.getPositionFromValue(currentValue);
          return {
            position: "absolute",
            ...getRangeStyles(this.root.direction, min, max)
          };
        }
      }),
      "SliderRangeState.rangeStyles"
    ));
    __privateAdd(this, _props134, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        style: this.rangeStyles,
        [sliderAttrs.range]: "",
        ...this.attachment
      })),
      "SliderRangeState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderRangeState(opts, SliderRootContext.get());
  }
  get rangeStyles() {
    return get(__privateGet(this, _rangeStyles));
  }
  set rangeStyles(value) {
    set(__privateGet(this, _rangeStyles), value);
  }
  get props() {
    return get(__privateGet(this, _props134));
  }
  set props(value) {
    set(__privateGet(this, _props134), value);
  }
};
_rangeStyles = new WeakMap();
_props134 = new WeakMap();
var SliderRangeState = _SliderRangeState;
var _isDisabled13, _SliderThumbState_instances, updateValue_fn3, _props135;
var _SliderThumbState = class _SliderThumbState {
  constructor(opts, root18) {
    __privateAdd(this, _SliderThumbState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled13, tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "SliderThumbState.#isDisabled"));
    __privateAdd(this, _props135, tag(
      user_derived(() => ({
        ...this.root.thumbsPropsArr[this.opts.index.current],
        id: this.opts.id.current,
        onkeydown: this.onkeydown,
        "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
        "data-disabled": getDataDisabled(this.opts.disabled.current || this.root.opts.disabled.current),
        tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
        ...this.attachment
      })),
      "SliderThumbState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _SliderThumbState(opts, SliderRootContext.get());
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled13))) return;
    const currNode = this.opts.ref.current;
    if (!currNode) return;
    const thumbs = this.root.getAllThumbs();
    if (!thumbs.length) return;
    const idx = thumbs.indexOf(currNode);
    if (this.root.isMulti) {
      this.root.currentThumbIdx = idx;
    }
    if (!VALID_SLIDER_KEYS.includes(e.key)) return;
    e.preventDefault();
    const min = this.root.opts.min.current;
    const max = this.root.opts.max.current;
    const value = this.root.opts.value.current;
    const thumbValue = Array.isArray(value) ? value[idx] : value;
    const orientation = this.root.opts.orientation.current;
    const direction = this.root.direction;
    const steps = this.root.normalizedSteps;
    switch (e.key) {
      case kbd_constants_exports.HOME:
        __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, min);
        break;
      case kbd_constants_exports.END:
        __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, max);
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (strict_equals(orientation, "horizontal", false)) break;
        if (e.metaKey) {
          const newValue = strict_equals(direction, "rl") ? max : min;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = strict_equals(direction, "rl") ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (strict_equals(orientation, "horizontal", false)) break;
        if (e.metaKey) {
          const newValue = strict_equals(direction, "rl") ? min : max;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = strict_equals(direction, "rl") ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_UP:
        if (e.metaKey) {
          const newValue = strict_equals(direction, "tb") ? min : max;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = strict_equals(direction, "tb") ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
      case kbd_constants_exports.ARROW_DOWN:
        if (e.metaKey) {
          const newValue = strict_equals(direction, "tb") ? max : min;
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        } else {
          const stepDirection = strict_equals(direction, "tb") ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          __privateMethod(this, _SliderThumbState_instances, updateValue_fn3).call(this, newValue);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  get props() {
    return get(__privateGet(this, _props135));
  }
  set props(value) {
    set(__privateGet(this, _props135), value);
  }
};
_isDisabled13 = new WeakMap();
_SliderThumbState_instances = new WeakSet();
updateValue_fn3 = function(newValue) {
  if (this.root.isMulti) {
    this.root.updateValue(newValue, this.opts.index.current);
  } else {
    this.root.updateValue(newValue);
  }
};
_props135 = new WeakMap();
var SliderThumbState = _SliderThumbState;
var _props136;
var _SliderTickState = class _SliderTickState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props136, tag(
      user_derived(() => ({
        ...this.root.ticksPropsArr[this.opts.index.current],
        id: this.opts.id.current,
        ...this.attachment
      })),
      "SliderTickState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderTickState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props136));
  }
  set props(value) {
    set(__privateGet(this, _props136), value);
  }
};
_props136 = new WeakMap();
var SliderTickState = _SliderTickState;
var _props137;
var _SliderTickLabelState = class _SliderTickLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props137, tag(
      user_derived(() => {
        var _a;
        const tickProps = this.root.ticksPropsArr[this.opts.index.current];
        const steps = this.root.normalizedSteps;
        const tickValue = steps[this.opts.index.current];
        const tickPosition = this.root.getPositionFromValue(tickValue);
        const labelPosition = ((_a = this.opts.position) == null ? void 0 : _a.current) ?? "top";
        const style = getTickLabelStyles(this.root.direction, tickPosition, labelPosition);
        return {
          id: this.opts.id.current,
          "data-orientation": getDataOrientation(this.root.opts.orientation.current),
          "data-disabled": getDataDisabled(this.root.opts.disabled.current),
          "data-bounded": tickProps["data-bounded"],
          "data-value": tickValue,
          "data-selected": this.root.isTickValueSelected(tickValue) ? "" : void 0,
          "data-position": labelPosition,
          style,
          [sliderAttrs["tick-label"]]: "",
          ...this.attachment
        };
      }),
      "SliderTickLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderTickLabelState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props137));
  }
  set props(value) {
    set(__privateGet(this, _props137), value);
  }
};
_props137 = new WeakMap();
var SliderTickLabelState = _SliderTickLabelState;
var _props138;
var _SliderThumbLabelState = class _SliderThumbLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props138, tag(
      user_derived(() => {
        var _a;
        const value = this.root.opts.value.current;
        const thumbValue = Array.isArray(value) ? value[this.opts.index.current] : value;
        const thumbPosition = this.root.getPositionFromValue(thumbValue);
        const labelPosition = ((_a = this.opts.position) == null ? void 0 : _a.current) ?? "top";
        const style = getThumbLabelStyles(this.root.direction, thumbPosition, labelPosition);
        return {
          id: this.opts.id.current,
          "data-orientation": getDataOrientation(this.root.opts.orientation.current),
          "data-disabled": getDataDisabled(this.root.opts.disabled.current),
          "data-value": thumbValue,
          "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
          "data-position": labelPosition,
          style,
          [sliderAttrs["thumb-label"]]: "",
          ...this.attachment
        };
      }),
      "SliderThumbLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SliderThumbLabelState(opts, SliderRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props138));
  }
  set props(value) {
    set(__privateGet(this, _props138), value);
  }
};
_props138 = new WeakMap();
var SliderThumbLabelState = _SliderThumbLabelState;

// node_modules/bits-ui/dist/bits/slider/components/slider.svelte
Slider[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider.svelte";
var root_294 = add_locations(from_html(`<span><!></span>`), Slider[FILENAME], [[96, 1]]);
function Slider($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), onValueCommit = prop($$props, "onValueCommit", 3, noop3), disabled = prop($$props, "disabled", 3, false), step = prop($$props, "step", 3, 1), dir = prop($$props, "dir", 3, "ltr"), autoSort = prop($$props, "autoSort", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), thumbPositioning = prop($$props, "thumbPositioning", 3, "contain"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "type",
      "onValueChange",
      "onValueCommit",
      "disabled",
      "min",
      "max",
      "step",
      "dir",
      "autoSort",
      "orientation",
      "thumbPositioning",
      "trackPadding"
    ],
    "restProps"
  );
  const min = tag(
    user_derived(() => {
      if (strict_equals($$props.min, void 0, false)) return $$props.min;
      if (Array.isArray(step())) return Math.min(...step());
      return 0;
    }),
    "min"
  );
  const max = tag(
    user_derived(() => {
      if (strict_equals($$props.max, void 0, false)) return $$props.max;
      if (Array.isArray(step())) return Math.max(...step());
      return 100;
    }),
    "max"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    if (strict_equals($$props.type, "single")) {
      return get(min);
    }
    return [];
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = SliderRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    // @ts-expect-error - we know
    onValueCommit: box.with(() => onValueCommit()),
    disabled: box.with(() => disabled()),
    min: box.with(() => get(min)),
    max: box.with(() => get(max)),
    step: box.with(() => step()),
    dir: box.with(() => dir()),
    autoSort: box.with(() => autoSort()),
    orientation: box.with(() => orientation()),
    thumbPositioning: box.with(() => thumbPositioning()),
    type: $$props.type,
    trackPadding: box.with(() => $$props.trackPadding)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_294();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider = hmr(Slider, () => Slider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider[HMR].source;
    set(Slider[HMR].source, module.default[HMR].original);
  });
}
var slider_default = Slider;

// node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte
Slider_range[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte";
var root_295 = add_locations(from_html(`<span><!></span>`), Slider_range[FILENAME], [[30, 1]]);
function Slider_range($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_range);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const rangeState = SliderRangeState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rangeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_295();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_range = hmr(Slider_range, () => Slider_range[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_range[HMR].source;
    set(Slider_range[HMR].source, module.default[HMR].original);
  });
}
var slider_range_default = Slider_range;

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte
Slider_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte";
var root_296 = add_locations(from_html(`<span><!></span>`), Slider_thumb[FILENAME], [[38, 1]]);
function Slider_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "disabled"
    ],
    "restProps"
  );
  const thumbState = SliderThumbState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    disabled: box.with(() => disabled())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        active: thumbState.root.isThumbActive(thumbState.opts.index.current),
        props: get(mergedProps)
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_296();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      var render_arg_1 = derived_safe_equal(() => ({
        active: thumbState.root.isThumbActive(thumbState.opts.index.current)
      }));
      snippet(node_2, () => $$props.children ?? noop, () => get(render_arg_1));
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_thumb = hmr(Slider_thumb, () => Slider_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_thumb[HMR].source;
    set(Slider_thumb[HMR].source, module.default[HMR].original);
  });
}
var slider_thumb_default = Slider_thumb;

// node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte
Slider_tick[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte";
var root_297 = add_locations(from_html(`<span><!></span>`), Slider_tick[FILENAME], [[33, 1]]);
function Slider_tick($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_tick);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index"
    ],
    "restProps"
  );
  const tickState = SliderTickState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_297();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_tick = hmr(Slider_tick, () => Slider_tick[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_tick[HMR].source;
    set(Slider_tick[HMR].source, module.default[HMR].original);
  });
}
var slider_tick_default = Slider_tick;

// node_modules/bits-ui/dist/bits/slider/components/slider-tick-label.svelte
Slider_tick_label[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick-label.svelte";
var root_321 = add_locations(from_html(`<span><!></span>`), Slider_tick_label[FILENAME], [[49, 1]]);
function Slider_tick_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_tick_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "position"
    ],
    "restProps"
  );
  const root18 = SliderRootContext.get();
  const position = tag(
    user_derived(() => {
      if (strict_equals($$props.position, void 0, false)) return $$props.position;
      switch (root18.direction) {
        case "lr":
        case "rl":
          return "top";
        case "tb":
        case "bt":
          return "left";
      }
    }),
    "position"
  );
  const tickLabelState = SliderTickLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    position: box.with(() => get(position))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickLabelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_321();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_tick_label = hmr(Slider_tick_label, () => Slider_tick_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_tick_label[HMR].source;
    set(Slider_tick_label[HMR].source, module.default[HMR].original);
  });
}
var slider_tick_label_default = Slider_tick_label;

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb-label.svelte
Slider_thumb_label[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb-label.svelte";
var root_322 = add_locations(from_html(`<span><!></span>`), Slider_thumb_label[FILENAME], [[49, 1]]);
function Slider_thumb_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_thumb_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "position"
    ],
    "restProps"
  );
  const root18 = SliderRootContext.get();
  const position = tag(
    user_derived(() => {
      if (strict_equals($$props.position, void 0, false)) return $$props.position;
      switch (root18.direction) {
        case "lr":
        case "rl":
          return "top";
        case "tb":
        case "bt":
          return "left";
      }
    }),
    "position"
  );
  const tickLabelState = SliderThumbLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    position: box.with(() => get(position))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickLabelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_322();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_thumb_label = hmr(Slider_thumb_label, () => Slider_thumb_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_thumb_label[HMR].source;
    set(Slider_thumb_label[HMR].source, module.default[HMR].original);
  });
}
var slider_thumb_label_default = Slider_thumb_label;

// node_modules/bits-ui/dist/bits/switch/exports.js
var exports_exports34 = {};
__export(exports_exports34, {
  Root: () => switch_default,
  Thumb: () => switch_thumb_default
});

// node_modules/bits-ui/dist/bits/switch/switch.svelte.js
var switchAttrs = createBitsAttrs({
  component: "switch",
  parts: ["root", "thumb"]
});
var SwitchRootContext = new Context("Switch.Root");
var _SwitchRootState_instances, toggle_fn2, _sharedProps2, _snippetProps27, _props139;
var _SwitchRootState = class _SwitchRootState {
  constructor(opts) {
    __privateAdd(this, _SwitchRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _sharedProps2, tag(
      user_derived(() => ({
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-state": getDataChecked(this.opts.checked.current),
        "data-required": getDataRequired(this.opts.required.current)
      })),
      "SwitchRootState.sharedProps"
    ));
    __privateAdd(this, _snippetProps27, tag(user_derived(() => ({ checked: this.opts.checked.current })), "SwitchRootState.snippetProps"));
    __privateAdd(this, _props139, tag(
      user_derived(() => ({
        ...this.sharedProps,
        id: this.opts.id.current,
        role: "switch",
        disabled: getDisabled(this.opts.disabled.current),
        "aria-checked": getAriaChecked(this.opts.checked.current, false),
        "aria-required": getAriaRequired(this.opts.required.current),
        [switchAttrs.root]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "SwitchRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return SwitchRootContext.set(new _SwitchRootState(opts));
  }
  onkeydown(e) {
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) || this.opts.disabled.current) return;
    e.preventDefault();
    __privateMethod(this, _SwitchRootState_instances, toggle_fn2).call(this);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _SwitchRootState_instances, toggle_fn2).call(this);
  }
  get sharedProps() {
    return get(__privateGet(this, _sharedProps2));
  }
  set sharedProps(value) {
    set(__privateGet(this, _sharedProps2), value);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps27));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps27), value);
  }
  get props() {
    return get(__privateGet(this, _props139));
  }
  set props(value) {
    set(__privateGet(this, _props139), value);
  }
};
_SwitchRootState_instances = new WeakSet();
toggle_fn2 = function() {
  this.opts.checked.current = !this.opts.checked.current;
};
_sharedProps2 = new WeakMap();
_snippetProps27 = new WeakMap();
_props139 = new WeakMap();
var SwitchRootState = _SwitchRootState;
var _shouldRender11, _props140;
var _SwitchInputState = class _SwitchInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender11, tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "SwitchInputState.shouldRender"));
    __privateAdd(this, _props140, tag(
      user_derived(() => ({
        type: "checkbox",
        name: this.root.opts.name.current,
        value: this.root.opts.value.current,
        checked: this.root.opts.checked.current,
        disabled: this.root.opts.disabled.current,
        required: this.root.opts.required.current
      })),
      "SwitchInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _SwitchInputState(SwitchRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender11));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender11), value);
  }
  get props() {
    return get(__privateGet(this, _props140));
  }
  set props(value) {
    set(__privateGet(this, _props140), value);
  }
};
_shouldRender11 = new WeakMap();
_props140 = new WeakMap();
var SwitchInputState = _SwitchInputState;
var _snippetProps28, _props141;
var _SwitchThumbState = class _SwitchThumbState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps28, tag(user_derived(() => ({ checked: this.root.opts.checked.current })), "SwitchThumbState.snippetProps"));
    __privateAdd(this, _props141, tag(
      user_derived(() => ({
        ...this.root.sharedProps,
        id: this.opts.id.current,
        [switchAttrs.thumb]: "",
        ...this.attachment
      })),
      "SwitchThumbState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _SwitchThumbState(opts, SwitchRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps28));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps28), value);
  }
  get props() {
    return get(__privateGet(this, _props141));
  }
  set props(value) {
    set(__privateGet(this, _props141), value);
  }
};
_snippetProps28 = new WeakMap();
_props141 = new WeakMap();
var SwitchThumbState = _SwitchThumbState;

// node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte
Switch_input[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte";
function Switch_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Switch_input);
  const inputState = SwitchInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => inputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => inputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_input = hmr(Switch_input, () => Switch_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_input[HMR].source;
    set(Switch_input[HMR].source, module.default[HMR].original);
  });
}
var switch_input_default = Switch_input;

// node_modules/bits-ui/dist/bits/switch/components/switch.svelte
Switch[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch.svelte";
var root_298 = add_locations(from_html(`<button><!></button>`), Switch[FILENAME], [[51, 1]]);
var root15 = add_locations(from_html(`<!> <!>`, 1), Switch[FILENAME], []);
function Switch($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Switch);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), checked = prop($$props, "checked", 15, false), value = prop($$props, "value", 3, "on"), name = prop($$props, "name", 3, void 0), type = prop($$props, "type", 3, "button"), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "required",
      "checked",
      "value",
      "name",
      "type",
      "onCheckedChange"
    ],
    "restProps"
  );
  const rootState = SwitchRootState.create({
    checked: box.with(() => checked(), (v) => {
      var _a;
      checked(v);
      (_a = onCheckedChange()) == null ? void 0 : _a(v);
    }),
    disabled: box.with(() => disabled() ?? false),
    required: box.with(() => required()),
    value: box.with(() => value()),
    name: box.with(() => name()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { type: type() })), "mergedProps");
  var fragment = root15();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...rootState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_298();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  switch_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch = hmr(Switch, () => Switch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch[HMR].source;
    set(Switch[HMR].source, module.default[HMR].original);
  });
}
var switch_default = Switch;

// node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte
Switch_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte";
var root_299 = add_locations(from_html(`<span><!></span>`), Switch_thumb[FILENAME], [[31, 1]]);
function Switch_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Switch_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id"
    ],
    "restProps"
  );
  const thumbState = SwitchThumbState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...thumbState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_299();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop, () => thumbState.snippetProps);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_thumb = hmr(Switch_thumb, () => Switch_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_thumb[HMR].source;
    set(Switch_thumb[HMR].source, module.default[HMR].original);
  });
}
var switch_thumb_default = Switch_thumb;

// node_modules/bits-ui/dist/bits/tabs/exports.js
var exports_exports35 = {};
__export(exports_exports35, {
  Content: () => tabs_content_default,
  List: () => tabs_list_default,
  Root: () => tabs_default,
  Trigger: () => tabs_trigger_default
});

// node_modules/bits-ui/dist/bits/tabs/tabs.svelte.js
var tabsAttrs = createBitsAttrs({
  component: "tabs",
  parts: ["root", "list", "trigger", "content"]
});
var TabsRootContext = new Context("Tabs.Root");
var _triggerIds2, _props142;
var _TabsRootState = class _TabsRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "rovingFocusGroup");
    __privateAdd(this, _triggerIds2, tag(state(proxy([])), "TabsRootState.triggerIds"));
    // holds the trigger ID for each value to associate it with the content
    __publicField(this, "valueToTriggerId", new SvelteMap());
    // holds the content ID for each value to associate it with the trigger
    __publicField(this, "valueToContentId", new SvelteMap());
    __privateAdd(this, _props142, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        [tabsAttrs.root]: "",
        ...this.attachment
      })),
      "TabsRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: tabsAttrs.trigger,
      rootNode: this.opts.ref,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  static create(opts) {
    return TabsRootContext.set(new _TabsRootState(opts));
  }
  get triggerIds() {
    return get(__privateGet(this, _triggerIds2));
  }
  set triggerIds(value) {
    set(__privateGet(this, _triggerIds2), value, true);
  }
  registerTrigger(id, value) {
    this.triggerIds.push(id);
    this.valueToTriggerId.set(value, id);
    return () => {
      this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
      this.valueToTriggerId.delete(value);
    };
  }
  registerContent(id, value) {
    this.valueToContentId.set(value, id);
    return () => {
      this.valueToContentId.delete(value);
    };
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  get props() {
    return get(__privateGet(this, _props142));
  }
  set props(value) {
    set(__privateGet(this, _props142), value);
  }
};
_triggerIds2 = new WeakMap();
_props142 = new WeakMap();
var TabsRootState = _TabsRootState;
var _isDisabled14, _props143;
var _TabsListState = class _TabsListState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled14, tag(user_derived(() => this.root.opts.disabled.current), "TabsListState.#isDisabled"));
    __privateAdd(this, _props143, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "tablist",
        "aria-orientation": getAriaOrientation(this.root.opts.orientation.current),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        [tabsAttrs.list]: "",
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled14))),
        ...this.attachment
      })),
      "TabsListState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  static create(opts) {
    return new _TabsListState(opts, TabsRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props143));
  }
  set props(value) {
    set(__privateGet(this, _props143), value);
  }
};
_isDisabled14 = new WeakMap();
_props143 = new WeakMap();
var TabsListState = _TabsListState;
var _tabIndex3, _isActive4, _isDisabled15, _ariaControls2, _TabsTriggerState_instances, activate_fn, _props144;
var _TabsTriggerState = class _TabsTriggerState {
  constructor(opts, root18) {
    __privateAdd(this, _TabsTriggerState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _tabIndex3, tag(state(0), "TabsTriggerState.#tabIndex"));
    __privateAdd(this, _isActive4, tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "TabsTriggerState.#isActive"));
    __privateAdd(this, _isDisabled15, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "TabsTriggerState.#isDisabled"));
    __privateAdd(this, _ariaControls2, tag(user_derived(() => this.root.valueToContentId.get(this.opts.value.current)), "TabsTriggerState.#ariaControls"));
    __privateAdd(this, _props144, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "tab",
        "data-state": getTabDataState(get(__privateGet(this, _isActive4))),
        "data-value": this.opts.value.current,
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled15))),
        "aria-selected": getAriaSelected(get(__privateGet(this, _isActive4))),
        "aria-controls": get(__privateGet(this, _ariaControls2)),
        [tabsAttrs.trigger]: "",
        disabled: getDisabled(get(__privateGet(this, _isDisabled15))),
        tabindex: get(__privateGet(this, _tabIndex3)),
        //
        onclick: this.onclick,
        onfocus: this.onfocus,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "TabsTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.opts.id.current,
        () => this.opts.value.current
      ],
      ([id, value]) => {
        return this.root.registerTrigger(id, value);
      }
    );
    user_effect(() => {
      this.root.triggerIds.length;
      if (get(__privateGet(this, _isActive4)) || !this.root.opts.value.current) {
        set(__privateGet(this, _tabIndex3), 0);
      } else {
        set(__privateGet(this, _tabIndex3), -1);
      }
    });
    this.onfocus = this.onfocus.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _TabsTriggerState(opts, TabsRootContext.get());
  }
  onfocus(_) {
    if (strict_equals(this.root.opts.activationMode.current, "automatic", false) || get(__privateGet(this, _isDisabled15))) return;
    __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled15))) return;
    __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled15))) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      __privateMethod(this, _TabsTriggerState_instances, activate_fn).call(this);
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props144));
  }
  set props(value) {
    set(__privateGet(this, _props144), value);
  }
};
_tabIndex3 = new WeakMap();
_isActive4 = new WeakMap();
_isDisabled15 = new WeakMap();
_ariaControls2 = new WeakMap();
_TabsTriggerState_instances = new WeakSet();
activate_fn = function() {
  if (strict_equals(this.root.opts.value.current, this.opts.value.current)) return;
  this.root.setValue(this.opts.value.current);
};
_props144 = new WeakMap();
var TabsTriggerState = _TabsTriggerState;
var _isActive5, _ariaLabelledBy, _props145;
var _TabsContentState = class _TabsContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isActive5, tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "TabsContentState.#isActive"));
    __privateAdd(this, _ariaLabelledBy, tag(user_derived(() => this.root.valueToTriggerId.get(this.opts.value.current)), "TabsContentState.#ariaLabelledBy"));
    __privateAdd(this, _props145, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "tabpanel",
        hidden: getHidden(!get(__privateGet(this, _isActive5))),
        tabindex: 0,
        "data-value": this.opts.value.current,
        "data-state": getTabDataState(get(__privateGet(this, _isActive5))),
        "aria-labelledby": get(__privateGet(this, _ariaLabelledBy)),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        [tabsAttrs.content]: "",
        ...this.attachment
      })),
      "TabsContentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch(
      [
        () => this.opts.id.current,
        () => this.opts.value.current
      ],
      ([id, value]) => {
        return this.root.registerContent(id, value);
      }
    );
  }
  static create(opts) {
    return new _TabsContentState(opts, TabsRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props145));
  }
  set props(value) {
    set(__privateGet(this, _props145), value);
  }
};
_isActive5 = new WeakMap();
_ariaLabelledBy = new WeakMap();
_props145 = new WeakMap();
var TabsContentState = _TabsContentState;
function getTabDataState(condition) {
  return condition ? "active" : "inactive";
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte
Tabs[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte";
var root_2100 = add_locations(from_html(`<div><!></div>`), Tabs[FILENAME], [[49, 1]]);
function Tabs($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), activationMode = prop($$props, "activationMode", 3, "automatic"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "orientation",
      "loop",
      "activationMode",
      "disabled",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = TabsRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    activationMode: box.with(() => activationMode()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2100();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs = hmr(Tabs, () => Tabs[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs[HMR].source;
    set(Tabs[HMR].source, module.default[HMR].original);
  });
}
var tabs_default = Tabs;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte
Tabs_content[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte";
var root_2101 = add_locations(from_html(`<div><!></div>`), Tabs_content[FILENAME], [[33, 1]]);
function Tabs_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value"
    ],
    "restProps"
  );
  const contentState = TabsContentState.create({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2101();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_content = hmr(Tabs_content, () => Tabs_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_content[HMR].source;
    set(Tabs_content[HMR].source, module.default[HMR].original);
  });
}
var tabs_content_default = Tabs_content;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte
Tabs_list[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte";
var root_2102 = add_locations(from_html(`<div><!></div>`), Tabs_list[FILENAME], [[31, 1]]);
function Tabs_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const listState = TabsListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2102();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_list = hmr(Tabs_list, () => Tabs_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_list[HMR].source;
    set(Tabs_list[HMR].source, module.default[HMR].original);
  });
}
var tabs_list_default = Tabs_list;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte
Tabs_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte";
var root_2103 = add_locations(from_html(`<button><!></button>`), Tabs_trigger[FILENAME], [[36, 1]]);
function Tabs_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_trigger);
  let disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "id",
      "type",
      "value",
      "ref"
    ],
    "restProps"
  );
  const triggerState = TabsTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    value: box.with(() => $$props.value),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2103();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_trigger = hmr(Tabs_trigger, () => Tabs_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_trigger[HMR].source;
    set(Tabs_trigger[HMR].source, module.default[HMR].original);
  });
}
var tabs_trigger_default = Tabs_trigger;

// node_modules/bits-ui/dist/bits/time-field/exports.js
var exports_exports36 = {};
__export(exports_exports36, {
  Input: () => time_field_input_default,
  Label: () => time_field_label_default,
  Root: () => time_field_default,
  Segment: () => time_field_segment_default
});

// node_modules/bits-ui/dist/bits/time-field/time-field.svelte.js
var timeFieldAttrs = createBitsAttrs({
  component: "time-field",
  parts: ["input", "label"]
});
var TimeFieldRootContext = new Context("TimeField.Root");
var SEGMENT_CONFIGS2 = {
  hour: {
    min: (root18) => strict_equals(root18.hourCycle, 12) ? 1 : 0,
    max: (root18) => {
      if (strict_equals(root18.hourCycle, 24)) return 23;
      if ("dayPeriod" in root18.segmentValues && strict_equals(root18.segmentValues.dayPeriod, null, false)) return 12;
      return 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  second: {
    min: 0,
    max: 59,
    cycle: 1,
    canBeZero: true,
    padZero: true
  }
};
var _segmentValues2, _readonlySegmentsSet2, _fieldNode3, _labelNode5, _descriptionNode4, _validationNode2, _dayPeriodNode2, _name3, _maxValueTime, _minValueTime, _valueTime, _hourCycle, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn, toDateValue_fn, clearUpdating_fn2, _validationStatus3, _isInvalid5, _inferredGranularity2, _timeRef, _allSegmentContent2, _segmentContents2, getLabelledBy_fn2;
var _TimeFieldRootState = class _TimeFieldRootState {
  constructor(props, rangeRoot) {
    __privateAdd(this, _TimeFieldRootState_instances);
    __publicField(this, "value");
    __publicField(this, "placeholder");
    __publicField(this, "validate");
    __publicField(this, "minValue");
    __publicField(this, "maxValue");
    __publicField(this, "disabled");
    __publicField(this, "readonly");
    __publicField(this, "granularity");
    __publicField(this, "readonlySegments");
    __publicField(this, "hourCycleProp");
    __publicField(this, "locale");
    __publicField(this, "hideTimeZone");
    __publicField(this, "required");
    __publicField(this, "onInvalid");
    __publicField(this, "errorMessageId");
    __publicField(this, "isInvalidProp");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __publicField(this, "initialSegments");
    __privateAdd(this, _segmentValues2, tag(state(), "TimeFieldRootState.segmentValues"));
    __publicField(this, "announcer");
    __privateAdd(this, _readonlySegmentsSet2, tag(user_derived(() => new Set(this.readonlySegments.current)), "TimeFieldRootState.readonlySegmentsSet"));
    __publicField(this, "segmentStates", initTimeSegmentStates());
    __privateAdd(this, _fieldNode3, tag(state(null), "TimeFieldRootState.#fieldNode"));
    __privateAdd(this, _labelNode5, tag(state(null), "TimeFieldRootState.#labelNode"));
    __privateAdd(this, _descriptionNode4, tag(state(null), "TimeFieldRootState.descriptionNode"));
    __privateAdd(this, _validationNode2, tag(state(null), "TimeFieldRootState.validationNode"));
    __publicField(this, "states", initTimeSegmentStates());
    __privateAdd(this, _dayPeriodNode2, tag(state(null), "TimeFieldRootState.dayPeriodNode"));
    __privateAdd(this, _name3, tag(state(""), "TimeFieldRootState.name"));
    __privateAdd(this, _maxValueTime, tag(
      user_derived(() => {
        if (!this.maxValue.current) return void 0;
        return convertTimeValueToTime(this.maxValue.current);
      }),
      "TimeFieldRootState.maxValueTime"
    ));
    __privateAdd(this, _minValueTime, tag(
      user_derived(() => {
        if (!this.minValue.current) return void 0;
        return convertTimeValueToTime(this.minValue.current);
      }),
      "TimeFieldRootState.minValueTime"
    ));
    __privateAdd(this, _valueTime, tag(
      user_derived(() => {
        if (!this.value.current) return void 0;
        return convertTimeValueToTime(this.value.current);
      }),
      "TimeFieldRootState.valueTime"
    ));
    __privateAdd(this, _hourCycle, tag(
      user_derived(() => {
        if (this.hourCycleProp.current) return this.hourCycleProp.current;
        return getDefaultHourCycle(this.locale.current);
      }),
      "TimeFieldRootState.hourCycle"
    ));
    __publicField(this, "rangeRoot");
    __publicField(this, "domContext", new DOMContext(() => null));
    __privateAdd(this, _validationStatus3, tag(
      user_derived(() => {
        var _a, _b;
        const value = this.value.current;
        if (!value) return false;
        const msg = (_b = (_a = this.validate).current) == null ? void 0 : _b.call(_a, value);
        if (msg) {
          return { reason: "custom", message: msg };
        }
        if (!this.valueTime) return false;
        if (this.minValueTime && isTimeBefore(this.valueTime, this.minValueTime)) {
          return { reason: "min" };
        }
        if (this.maxValueTime && isTimeBefore(this.maxValueTime, this.valueTime)) {
          return { reason: "max" };
        }
        return false;
      }),
      "TimeFieldRootState.validationStatus"
    ));
    __privateAdd(this, _isInvalid5, tag(
      user_derived(() => {
        if (strict_equals(this.validationStatus, false)) return false;
        if (this.isInvalidProp.current) return true;
        return true;
      }),
      "TimeFieldRootState.isInvalid"
    ));
    __privateAdd(this, _inferredGranularity2, tag(
      user_derived(() => {
        return this.granularity.current ?? "minute";
      }),
      "TimeFieldRootState.inferredGranularity"
    ));
    __privateAdd(this, _timeRef, tag(user_derived(() => this.value.current ?? this.placeholder.current), "TimeFieldRootState.timeRef"));
    __privateAdd(this, _allSegmentContent2, tag(
      user_derived(() => createTimeContent({
        segmentValues: this.segmentValues,
        formatter: this.formatter,
        locale: this.locale.current,
        granularity: this.inferredGranularity,
        timeRef: this.timeRef,
        hideTimeZone: this.hideTimeZone.current,
        hourCycle: this.hourCycle
      })),
      "TimeFieldRootState.allSegmentContent"
    ));
    __privateAdd(this, _segmentContents2, tag(user_derived(() => this.allSegmentContent.arr), "TimeFieldRootState.segmentContents"));
    __publicField(this, "sharedSegmentAttrs", {
      role: "spinbutton",
      contenteditable: "true",
      tabindex: 0,
      spellcheck: false,
      inputmode: "numeric",
      autocorrect: "off",
      enterkeyhint: "next",
      style: { caretColor: "transparent" }
    });
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? box(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycleProp = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createTimeFormatter(this.locale.current);
    this.initialSegments = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      removeTimeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setTimeDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: __privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, this.value.current),
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && strict_equals(placeholder, this.value.current, false)) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      __privateMethod(this, _TimeFieldRootState_instances, clearUpdating_fn2).call(this);
    });
    user_effect(() => {
      if (strict_equals(this.value.current, void 0)) {
        this.segmentValues = __privateMethod(this, _TimeFieldRootState_instances, initializeTimeSegmentValues_fn).call(this);
      }
    });
    watch(() => this.validationStatus, () => {
      var _a, _b;
      if (strict_equals(this.validationStatus, false, false)) {
        (_b = (_a = this.onInvalid).current) == null ? void 0 : _b.call(_a, this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  static create(opts, rangeRoot) {
    return TimeFieldRootContext.set(new _TimeFieldRootState(opts, rangeRoot));
  }
  get segmentValues() {
    return get(__privateGet(this, _segmentValues2));
  }
  set segmentValues(value) {
    set(__privateGet(this, _segmentValues2), value, true);
  }
  get readonlySegmentsSet() {
    return get(__privateGet(this, _readonlySegmentsSet2));
  }
  set readonlySegmentsSet(value) {
    set(__privateGet(this, _readonlySegmentsSet2), value);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode4));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode4), value, true);
  }
  get validationNode() {
    return get(__privateGet(this, _validationNode2));
  }
  set validationNode(value) {
    set(__privateGet(this, _validationNode2), value, true);
  }
  get dayPeriodNode() {
    return get(__privateGet(this, _dayPeriodNode2));
  }
  set dayPeriodNode(value) {
    set(__privateGet(this, _dayPeriodNode2), value, true);
  }
  get name() {
    return get(__privateGet(this, _name3));
  }
  set name(value) {
    set(__privateGet(this, _name3), value, true);
  }
  get maxValueTime() {
    return get(__privateGet(this, _maxValueTime));
  }
  set maxValueTime(value) {
    set(__privateGet(this, _maxValueTime), value);
  }
  get minValueTime() {
    return get(__privateGet(this, _minValueTime));
  }
  set minValueTime(value) {
    set(__privateGet(this, _minValueTime), value);
  }
  get valueTime() {
    return get(__privateGet(this, _valueTime));
  }
  set valueTime(value) {
    set(__privateGet(this, _valueTime), value);
  }
  get hourCycle() {
    return get(__privateGet(this, _hourCycle));
  }
  set hourCycle(value) {
    set(__privateGet(this, _hourCycle), value);
  }
  setName(name) {
    this.name = name;
  }
  setFieldNode(node) {
    set(__privateGet(this, _fieldNode3), node, true);
  }
  /**
   * Gets the correct field node for the time field regardless of whether it's being
   * used in a standalone context or within a `TimeRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(__privateGet(this, _fieldNode3));
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  setLabelNode(node) {
    set(__privateGet(this, _labelNode5), node, true);
  }
  getLabelNode() {
    return get(__privateGet(this, _labelNode5));
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
      if (strict_equals(part, "dayPeriod")) {
        if (this.states.dayPeriod.updating) {
          return [part, this.states.dayPeriod.updating];
        } else {
          return [
            part,
            this.formatter.dayPeriod(toDate(__privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, value)))
          ];
        }
      } else if (strict_equals(part, "hour")) {
        if (this.states.hour.updating) {
          return [part, this.states.hour.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
        if (strict_equals(value[part], 0) && this.dayPeriodNode) {
          return [part, "12"];
        }
      } else if (strict_equals(part, "minute")) {
        if (this.states.minute.updating) {
          return [part, this.states.minute.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      } else if (strict_equals(part, "second")) {
        if (this.states.second.updating) {
          return [part, this.states.second.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      }
      return [part, `${value[part]}`];
    });
    this.segmentValues = Object.fromEntries(timeValues);
    __privateMethod(this, _TimeFieldRootState_instances, clearUpdating_fn2).call(this);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus3));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus3), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid5));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid5), value);
  }
  get inferredGranularity() {
    return get(__privateGet(this, _inferredGranularity2));
  }
  set inferredGranularity(value) {
    set(__privateGet(this, _inferredGranularity2), value);
  }
  get timeRef() {
    return get(__privateGet(this, _timeRef));
  }
  set timeRef(value) {
    set(__privateGet(this, _timeRef), value);
  }
  get allSegmentContent() {
    return get(__privateGet(this, _allSegmentContent2));
  }
  set allSegmentContent(value) {
    set(__privateGet(this, _allSegmentContent2), value);
  }
  get segmentContents() {
    return get(__privateGet(this, _segmentContents2));
  }
  set segmentContents(value) {
    set(__privateGet(this, _segmentContents2), value);
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    if (strict_equals(part, "dayPeriod")) {
      const next3 = cb(prev2[part]);
      this.states.dayPeriod.updating = next3;
      const value = this.value.current;
      if (value && "hour" in value) {
        const trueHour = value.hour;
        if (strict_equals(next3, "AM")) {
          if (trueHour >= 12) {
            prev2.hour = `${trueHour - 12}`;
          }
        } else if (strict_equals(next3, "PM")) {
          if (trueHour < 12) {
            prev2.hour = `${trueHour + 12}`;
          }
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "hour")) {
      const next3 = cb(prev2[part]);
      this.states.hour.updating = next3;
      if (strict_equals(next3, null, false) && strict_equals(prev2.dayPeriod, null, false)) {
        const dayPeriod = this.formatter.dayPeriod(toDate(__privateMethod(this, _TimeFieldRootState_instances, toDateValue_fn).call(this, this.timeRef.set({ hour: Number.parseInt(next3) }))), this.hourCycle);
        if (strict_equals(dayPeriod, "AM") || strict_equals(dayPeriod, "PM")) {
          prev2.dayPeriod = dayPeriod;
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "minute")) {
      const next3 = cb(prev2[part]);
      this.states.minute.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "second")) {
      const next3 = cb(prev2[part]);
      this.states.second.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    }
    this.segmentValues = newSegmentValues;
    if (areAllTimeSegmentsFilled(newSegmentValues, get(__privateGet(this, _fieldNode3)))) {
      this.setValue(getTimeValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(__privateGet(this, _fieldNode3)),
        timeRef: this.timeRef
      }));
    } else {
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    var _a, _b;
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": getAriaInvalid(this.isInvalid),
      "aria-disabled": getAriaDisabled(this.disabled.current),
      "aria-readonly": getAriaReadonly(this.readonly.current || inReadonlySegments),
      "data-invalid": getDataInvalid(this.isInvalid),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-readonly": getDataReadonly(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`
    };
    if (strict_equals(part, "literal")) return defaultAttrs;
    const descriptionId = (_a = this.descriptionNode) == null ? void 0 : _a.id;
    const hasDescription = isFirstTimeSegment(segmentId, get(__privateGet(this, _fieldNode3))) && descriptionId;
    const errorMsgId = (_b = this.errorMessageId) == null ? void 0 : _b.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": __privateMethod(this, _TimeFieldRootState_instances, getLabelledBy_fn2).call(this, segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
_segmentValues2 = new WeakMap();
_readonlySegmentsSet2 = new WeakMap();
_fieldNode3 = new WeakMap();
_labelNode5 = new WeakMap();
_descriptionNode4 = new WeakMap();
_validationNode2 = new WeakMap();
_dayPeriodNode2 = new WeakMap();
_name3 = new WeakMap();
_maxValueTime = new WeakMap();
_minValueTime = new WeakMap();
_valueTime = new WeakMap();
_hourCycle = new WeakMap();
_TimeFieldRootState_instances = new WeakSet();
initializeTimeSegmentValues_fn = function() {
  const granularity = this.inferredGranularity;
  const segments = {
    hour: null,
    minute: null,
    second: null,
    dayPeriod: "AM"
  };
  if (strict_equals(granularity, "second")) {
    segments.second = null;
  }
  if (strict_equals(this.hourCycle, 24)) {
    segments.dayPeriod = null;
  }
  return segments;
};
toDateValue_fn = function(timeValue) {
  if ("calendar" in timeValue) {
    return timeValue;
  } else {
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2e3, 1, 1, timeValue.hour, timeValue.minute, timeValue.second, timeValue.millisecond);
  }
};
clearUpdating_fn2 = function() {
  this.states.hour.updating = null;
  this.states.minute.updating = null;
  this.states.second.updating = null;
  this.states.dayPeriod.updating = null;
};
_validationStatus3 = new WeakMap();
_isInvalid5 = new WeakMap();
_inferredGranularity2 = new WeakMap();
_timeRef = new WeakMap();
_allSegmentContent2 = new WeakMap();
_segmentContents2 = new WeakMap();
getLabelledBy_fn2 = function(segmentId) {
  var _a;
  return `${segmentId} ${((_a = this.getLabelNode()) == null ? void 0 : _a.id) ?? ""}`;
};
var TimeFieldRootState = _TimeFieldRootState;
var _ariaDescribedBy2, _props146;
var _TimeFieldInputState = class _TimeFieldInputState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "domContext");
    __privateAdd(this, _ariaDescribedBy2, tag(
      user_derived(() => {
        if (!isBrowser) return void 0;
        const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
        if (!doesDescriptionExist) return void 0;
        return this.root.descriptionId;
      }),
      "TimeFieldInputState.#ariaDescribedBy"
    ));
    __privateAdd(this, _props146, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          role: "group",
          "aria-labelledby": ((_a = this.root.getLabelNode()) == null ? void 0 : _a.id) ?? void 0,
          "aria-describedby": get(__privateGet(this, _ariaDescribedBy2)),
          "aria-disabled": getAriaDisabled(this.root.disabled.current),
          "data-invalid": this.root.isInvalid ? "" : void 0,
          "data-disabled": getDataDisabled(this.root.disabled.current),
          [timeFieldAttrs.input]: "",
          ...this.attachment
        };
      }),
      "TimeFieldInputState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    this.domContext = new DOMContext(opts.ref);
    this.root.setName(this.opts.name.current);
    user_effect(() => {
      this.root.setName(this.opts.name.current);
    });
  }
  static create(opts) {
    return new _TimeFieldInputState(opts, TimeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props146));
  }
  set props(value) {
    set(__privateGet(this, _props146), value);
  }
};
_ariaDescribedBy2 = new WeakMap();
_props146 = new WeakMap();
var TimeFieldInputState = _TimeFieldInputState;
var _shouldRender12, _isoValue2, _props147;
var _TimeFieldHiddenInputState = class _TimeFieldHiddenInputState {
  constructor(root18) {
    __publicField(this, "root");
    __privateAdd(this, _shouldRender12, tag(user_derived(() => strict_equals(this.root.name, "", false)), "TimeFieldHiddenInputState.shouldRender"));
    __privateAdd(this, _isoValue2, tag(user_derived(() => this.root.value.current ? getISOTimeValue(this.root.value.current) : void 0), "TimeFieldHiddenInputState.isoValue"));
    __privateAdd(this, _props147, tag(
      user_derived(() => ({
        name: this.root.name,
        value: this.isoValue,
        required: this.root.required.current
      })),
      "TimeFieldHiddenInputState.props"
    ));
    this.root = root18;
  }
  static create() {
    return new _TimeFieldHiddenInputState(TimeFieldRootContext.get());
  }
  get shouldRender() {
    return get(__privateGet(this, _shouldRender12));
  }
  set shouldRender(value) {
    set(__privateGet(this, _shouldRender12), value);
  }
  get isoValue() {
    return get(__privateGet(this, _isoValue2));
  }
  set isoValue(value) {
    set(__privateGet(this, _isoValue2), value);
  }
  get props() {
    return get(__privateGet(this, _props147));
  }
  set props(value) {
    set(__privateGet(this, _props147), value);
  }
};
_shouldRender12 = new WeakMap();
_isoValue2 = new WeakMap();
_props147 = new WeakMap();
var TimeFieldHiddenInputState = _TimeFieldHiddenInputState;
var _props148;
var _TimeFieldLabelState = class _TimeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props148, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-invalid": getDataInvalid(this.root.isInvalid),
        "data-disabled": getDataDisabled(this.root.disabled.current),
        [timeFieldAttrs.label]: "",
        onclick: this.onclick,
        ...this.attachment
      })),
      "TimeFieldLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _TimeFieldLabelState(opts, TimeFieldRootContext.get());
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstTimeSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  get props() {
    return get(__privateGet(this, _props148));
  }
  set props(value) {
    set(__privateGet(this, _props148), value);
  }
};
_props148 = new WeakMap();
var TimeFieldLabelState = _TimeFieldLabelState;
var _BaseTimeSegmentState_instances, getMax_fn2, getMin_fn2, formatValue_fn2, handleArrowUp_fn2, handleArrowDown_fn2, handleNumberKey_fn2, handleBackspace_fn2, _props149;
var BaseTimeSegmentState = class {
  constructor(opts, root18, part, config) {
    __privateAdd(this, _BaseTimeSegmentState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "announcer");
    __publicField(this, "part");
    __publicField(this, "config");
    __publicField(this, "attachment");
    __privateAdd(this, _props149, tag(
      user_derived(() => {
        return {
          ...this.root.sharedSegmentAttrs,
          id: this.opts.id.current,
          ...this.getSegmentProps(),
          onkeydown: this.onkeydown,
          onfocusout: this.onfocusout,
          onclick: this.root.handleSegmentClick,
          ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
          ...this.attachment
        };
      }),
      "BaseTimeSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleArrowUp_fn2).call(this, placeholder);
      return;
    }
    if (isArrowDown2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleArrowDown_fn2).call(this, placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleNumberKey_fn2).call(this, e);
      return;
    }
    if (isBackspace2(e.key)) {
      __privateMethod(this, _BaseTimeSegmentState_instances, handleBackspace_fn2).call(this, e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = strict_equals(segmentValues[this.part], null);
    let value = placeholder;
    if (segmentValues[this.part]) {
      value = placeholder.set({
        [this.part]: Number.parseInt(segmentValues[this.part])
      });
    }
    const valueNow = value[this.part];
    const valueMin = __privateMethod(this, _BaseTimeSegmentState_instances, getMin_fn2).call(this);
    const valueMax = __privateMethod(this, _BaseTimeSegmentState_instances, getMax_fn2).call(this);
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (strict_equals(this.part, "hour") && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  get props() {
    return get(__privateGet(this, _props149));
  }
  set props(value) {
    set(__privateGet(this, _props149), value);
  }
};
_BaseTimeSegmentState_instances = new WeakSet();
getMax_fn2 = function() {
  return strict_equals(typeof this.config.max, "function") ? this.config.max(this.root) : this.config.max;
};
getMin_fn2 = function() {
  return strict_equals(typeof this.config.min, "function") ? this.config.min(this.root) : this.config.min;
};
formatValue_fn2 = function(value, forDisplay = true) {
  const str = String(value);
  if (forDisplay && this.config.padZero && strict_equals(str.length, 1)) {
    return `0${value}`;
  }
  return str;
};
handleArrowUp_fn2 = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      const next4 = placeholder[this.part];
      this.announcer.announce(String(next4));
      return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, this.config.cycle)[this.part];
    this.announcer.announce(String(next3));
    return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next3);
  });
};
handleArrowDown_fn2 = function(placeholder) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      const next4 = placeholder[this.part];
      this.announcer.announce(String(next4));
      return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next4);
    }
    const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
    const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
    this.announcer.announce(String(next3));
    return __privateMethod(this, _BaseTimeSegmentState_instances, formatValue_fn2).call(this, next3);
  });
};
handleNumberKey_fn2 = function(e) {
  const num = Number.parseInt(e.key);
  let moveToNext = false;
  const max = __privateMethod(this, _BaseTimeSegmentState_instances, getMax_fn2).call(this);
  const maxStart = Math.floor(max / 10);
  const numIsZero = strict_equals(num, 0);
  const stateKey = this.part;
  this.root.updateSegment(this.part, (prev2) => {
    if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
      prev2 = null;
      this.root.states[stateKey].hasLeftFocus = false;
    }
    if (strict_equals(prev2, null)) {
      if (numIsZero) {
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = true;
        }
        this.announcer.announce("0");
        return "0";
      }
      if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
        moveToNext = true;
      }
      if (stateKey in this.root.states) {
        this.root.states[stateKey].lastKeyZero = false;
      }
      if (moveToNext && strict_equals(String(num).length, 1)) {
        this.announcer.announce(num);
        return `0${num}`;
      }
      return `${num}`;
    }
    if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
      if (strict_equals(num, 0, false)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `0${num}`;
      }
      if (strict_equals(this.part, "hour") && strict_equals(num, 0) && strict_equals(this.root.hourCycle, 24)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return `00`;
      }
      if ((strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && strict_equals(num, 0)) {
        moveToNext = true;
        this.root.states[stateKey].lastKeyZero = false;
        return "00";
      }
      return prev2;
    }
    const total = Number.parseInt(prev2 + num.toString());
    if (total > max) {
      moveToNext = true;
      return `0${num}`;
    }
    moveToNext = true;
    return `${total}`;
  });
  if (moveToNext) {
    moveToNextTimeSegment(e, this.root.getFieldNode());
  }
};
handleBackspace_fn2 = function(e) {
  const stateKey = this.part;
  if (stateKey in this.root.states) {
    this.root.states[stateKey].hasLeftFocus = false;
  }
  let moveToPrev = false;
  this.root.updateSegment(this.part, (prev2) => {
    if (strict_equals(prev2, null)) {
      moveToPrev = true;
      this.announcer.announce(null);
      return null;
    }
    if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
      this.announcer.announce(null);
      return null;
    }
    const str = prev2.toString();
    if (strict_equals(str.length, 1)) {
      this.announcer.announce(null);
      return null;
    }
    const next3 = Number.parseInt(str.slice(0, -1));
    this.announcer.announce(String(next3));
    return `${next3}`;
  });
  if (moveToPrev) {
    moveToPrevTimeSegment(e, this.root.getFieldNode());
  }
};
_props149 = new WeakMap();
var TimeFieldHourSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS2.hour);
  }
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (strict_equals(part, "hour") && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (strict_equals(hourValue, "0") && this.root.dayPeriodNode && strict_equals(this.root.hourCycle, 24, false)) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var TimeFieldMinuteSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS2.minute);
  }
};
var TimeFieldSecondSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS2.second);
  }
};
var _announcer2, _props150;
var TimeFieldDayPeriodSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _announcer2);
    __privateAdd(this, _props150, tag(
      user_derived(() => {
        const segmentValues = this.root.segmentValues;
        if (!("dayPeriod" in segmentValues)) return;
        const valueMin = 0;
        const valueMax = 12;
        const valueNow = strict_equals(segmentValues.dayPeriod, "AM") ? 0 : 12;
        const valueText = strict_equals(segmentValues.dayPeriod, "AM") ? "AM" : "PM";
        return {
          ...this.root.sharedSegmentAttrs,
          id: this.opts.id.current,
          inputmode: "text",
          "aria-label": "AM/PM",
          "aria-valuemin": valueMin,
          "aria-valuemax": valueMax,
          "aria-valuenow": valueNow,
          "aria-valuetext": valueText,
          onkeydown: this.onkeydown,
          onclick: this.root.handleSegmentClick,
          ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
          ...this.attachment
        };
      }),
      "TimeFieldDayPeriodSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    __privateSet(this, _announcer2, this.root.announcer);
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableDayPeriodKey2(e.key)) return;
    if (isArrowUp2(e.key) || isArrowDown2(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (strict_equals(prev2, "AM")) {
          const next4 = "PM";
          __privateGet(this, _announcer2).announce(next4);
          return next4;
        }
        const next3 = "AM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace2(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
    }
    if (strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.P) || strict_equals(e.key, kbd_constants_exports.a) || strict_equals(e.key, kbd_constants_exports.p)) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.a) ? "AM" : "PM";
        __privateGet(this, _announcer2).announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props150));
  }
  set props(value) {
    set(__privateGet(this, _props150), value);
  }
};
_announcer2 = new WeakMap();
_props150 = new WeakMap();
var _props151;
var TimeFieldLiteralSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props151, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "aria-hidden": getAriaHidden(true),
        ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
        ...this.attachment
      })),
      "TimeFieldLiteralSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props151));
  }
  set props(value) {
    set(__privateGet(this, _props151), value);
  }
};
_props151 = new WeakMap();
var _props152;
var TimeFieldTimeZoneSegmentState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props152, tag(
      user_derived(() => ({
        role: "textbox",
        id: this.opts.id.current,
        "aria-label": "timezone, ",
        style: { caretColor: "transparent" },
        onkeydown: this.onkeydown,
        tabindex: 0,
        ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
        "data-readonly": getDataReadonly(true),
        ...this.attachment
      })),
      "TimeFieldTimeZoneSegmentState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  get props() {
    return get(__privateGet(this, _props152));
  }
  set props(value) {
    set(__privateGet(this, _props152), value);
  }
};
_props152 = new WeakMap();
var DateFieldSegmentState2 = class {
  static create(part, opts) {
    const root18 = TimeFieldRootContext.get();
    switch (part) {
      case "hour":
        return new TimeFieldHourSegmentState(opts, root18);
      case "minute":
        return new TimeFieldMinuteSegmentState(opts, root18);
      case "second":
        return new TimeFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new TimeFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new TimeFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new TimeFieldTimeZoneSegmentState(opts, root18);
      default:
        throw new Error(`Invalid part: ${part}`);
    }
  }
};
function isAcceptableDayPeriodKey2(key) {
  return isAcceptableSegmentKey(key) || strict_equals(key, kbd_constants_exports.A) || strict_equals(key, kbd_constants_exports.P) || strict_equals(key, kbd_constants_exports.a) || strict_equals(key, kbd_constants_exports.p);
}
function isArrowUp2(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_UP);
}
function isArrowDown2(key) {
  return strict_equals(key, kbd_constants_exports.ARROW_DOWN);
}
function isBackspace2(key) {
  return strict_equals(key, kbd_constants_exports.BACKSPACE);
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field.svelte
Time_field[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field.svelte";
function Time_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Time_field);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultTime({
      granularity: $$props.granularity,
      defaultValue: value()
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  TimeFieldRootState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    granularity: box.with(() => $$props.granularity),
    hideTimeZone: box.with(() => hideTimeZone()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    validate: box.with(() => validate()),
    readonly: box.with(() => readonly()),
    readonlySegments: box.with(() => readonlySegments()),
    required: box.with(() => required()),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field = hmr(Time_field, () => Time_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field[HMR].source;
    set(Time_field[HMR].source, module.default[HMR].original);
  });
}
var time_field_default = Time_field;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-hidden-input.svelte
Time_field_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-hidden-input.svelte";
function Time_field_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Time_field_hidden_input);
  const hiddenInputState = TimeFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      hidden_input_default(node_1, spread_props(() => hiddenInputState.props));
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (untrack(() => hiddenInputState.shouldRender)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_hidden_input = hmr(Time_field_hidden_input, () => Time_field_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_hidden_input[HMR].source;
    set(Time_field_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var time_field_hidden_input_default = Time_field_hidden_input;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-input.svelte
Time_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-input.svelte";
var root_2104 = add_locations(from_html(`<div><!></div>`), Time_field_input[FILENAME], [[34, 1]]);
var root16 = add_locations(from_html(`<!> <!>`, 1), Time_field_input[FILENAME], []);
function Time_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "children",
      "child"
    ],
    "restProps"
  );
  const inputState = TimeFieldInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    name: box.with(() => name())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = root16();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2104();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  time_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_input = hmr(Time_field_input, () => Time_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_input[HMR].source;
    set(Time_field_input[HMR].source, module.default[HMR].original);
  });
}
var time_field_input_default = Time_field_input;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-label.svelte
Time_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-label.svelte";
var root_2105 = add_locations(from_html(`<div><!></div>`), Time_field_label[FILENAME], [[31, 1]]);
function Time_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = TimeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2105();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_label = hmr(Time_field_label, () => Time_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_label[HMR].source;
    set(Time_field_label[HMR].source, module.default[HMR].original);
  });
}
var time_field_label_default = Time_field_label;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-segment.svelte
Time_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-segment.svelte";
var root_2106 = add_locations(from_html(`<span><!></span>`), Time_field_segment[FILENAME], [[34, 1]]);
function Time_field_segment($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_segment);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "part"
    ],
    "restProps"
  );
  const segmentState = DateFieldSegmentState2.create($$props.part, {
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, segmentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2106();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_segment = hmr(Time_field_segment, () => Time_field_segment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_segment[HMR].source;
    set(Time_field_segment[HMR].source, module.default[HMR].original);
  });
}
var time_field_segment_default = Time_field_segment;

// node_modules/bits-ui/dist/bits/time-range-field/exports.js
var exports_exports37 = {};
__export(exports_exports37, {
  Input: () => time_range_field_input_default,
  Label: () => time_range_field_label_default,
  Root: () => time_range_field_default,
  Segment: () => time_field_segment_default
});

// node_modules/bits-ui/dist/bits/time-range-field/time-range-field.svelte.js
var timeRangeFieldAttrs = createBitsAttrs({
  component: "time-range-field",
  parts: ["root", "label"]
});
var TimeRangeFieldRootContext = new Context("TimeRangeField.Root");
var _fieldNode4, _labelNode6, _descriptionNode5, _startValueComplete2, _endValueComplete2, _rangeComplete2, _startValueTime, _endValueTime, _minValueTime2, _maxValueTime2, _validationStatus4, _isInvalid6, _TimeRangeFieldRootState_instances, updateValue_fn4, _props153;
var _TimeRangeFieldRootState = class _TimeRangeFieldRootState {
  constructor(opts) {
    __privateAdd(this, _TimeRangeFieldRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __publicField(this, "startFieldState");
    __publicField(this, "endFieldState");
    __publicField(this, "descriptionId", useId());
    __publicField(this, "formatter");
    __privateAdd(this, _fieldNode4, tag(state(null), "TimeRangeFieldRootState.fieldNode"));
    __privateAdd(this, _labelNode6, tag(state(null), "TimeRangeFieldRootState.labelNode"));
    __privateAdd(this, _descriptionNode5, tag(state(null), "TimeRangeFieldRootState.descriptionNode"));
    __privateAdd(this, _startValueComplete2, tag(user_derived(() => strict_equals(this.opts.startValue.current, void 0, false)), "TimeRangeFieldRootState.startValueComplete"));
    __privateAdd(this, _endValueComplete2, tag(user_derived(() => strict_equals(this.opts.endValue.current, void 0, false)), "TimeRangeFieldRootState.endValueComplete"));
    __privateAdd(this, _rangeComplete2, tag(user_derived(() => this.startValueComplete && this.endValueComplete), "TimeRangeFieldRootState.rangeComplete"));
    __privateAdd(this, _startValueTime, tag(
      user_derived(() => {
        if (!this.opts.startValue.current) return void 0;
        return convertTimeValueToTime(this.opts.startValue.current);
      }),
      "TimeRangeFieldRootState.startValueTime"
    ));
    __privateAdd(this, _endValueTime, tag(
      user_derived(() => {
        if (!this.opts.endValue.current) return void 0;
        return convertTimeValueToTime(this.opts.endValue.current);
      }),
      "TimeRangeFieldRootState.endValueTime"
    ));
    __privateAdd(this, _minValueTime2, tag(
      user_derived(() => {
        if (!this.opts.minValue.current) return void 0;
        return convertTimeValueToTime(this.opts.minValue.current);
      }),
      "TimeRangeFieldRootState.minValueTime"
    ));
    __privateAdd(this, _maxValueTime2, tag(
      user_derived(() => {
        if (!this.opts.maxValue.current) return void 0;
        return convertTimeValueToTime(this.opts.maxValue.current);
      }),
      "TimeRangeFieldRootState.maxValueTime"
    ));
    __publicField(this, "domContext");
    __privateAdd(this, _validationStatus4, tag(
      user_derived(() => {
        var _a, _b;
        const value = this.opts.value.current;
        if (strict_equals(value, void 0)) return false;
        if (strict_equals(value.start, void 0) || strict_equals(value.end, void 0)) return false;
        const msg = (_b = (_a = this.opts.validate).current) == null ? void 0 : _b.call(_a, { start: value.start, end: value.end });
        if (msg) {
          return { reason: "custom", message: msg };
        }
        if (this.minValueTime && this.startValueTime && isTimeBefore(this.startValueTime, this.minValueTime)) {
          return { reason: "min" };
        }
        if (this.maxValueTime && this.endValueTime && isTimeBefore(this.maxValueTime, this.endValueTime)) {
          return { reason: "max" };
        }
        return false;
      }),
      "TimeRangeFieldRootState.validationStatus"
    ));
    __privateAdd(this, _isInvalid6, tag(
      user_derived(() => {
        if (strict_equals(this.validationStatus, false)) return false;
        return true;
      }),
      "TimeRangeFieldRootState.isInvalid"
    ));
    __privateAdd(this, _props153, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "group",
        [timeRangeFieldAttrs.root]: "",
        "data-invalid": getDataInvalid(this.isInvalid),
        ...this.attachment
      })),
      "TimeRangeFieldRootState.props"
    ));
    this.opts = opts;
    this.formatter = createTimeFormatter(this.opts.locale.current);
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          __privateMethod(this, _TimeRangeFieldRootState_instances, updateValue_fn4).call(this, (prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  static create(opts) {
    return TimeRangeFieldRootContext.set(new _TimeRangeFieldRootState(opts));
  }
  get fieldNode() {
    return get(__privateGet(this, _fieldNode4));
  }
  set fieldNode(value) {
    set(__privateGet(this, _fieldNode4), value, true);
  }
  get labelNode() {
    return get(__privateGet(this, _labelNode6));
  }
  set labelNode(value) {
    set(__privateGet(this, _labelNode6), value, true);
  }
  get descriptionNode() {
    return get(__privateGet(this, _descriptionNode5));
  }
  set descriptionNode(value) {
    set(__privateGet(this, _descriptionNode5), value, true);
  }
  get startValueComplete() {
    return get(__privateGet(this, _startValueComplete2));
  }
  set startValueComplete(value) {
    set(__privateGet(this, _startValueComplete2), value);
  }
  get endValueComplete() {
    return get(__privateGet(this, _endValueComplete2));
  }
  set endValueComplete(value) {
    set(__privateGet(this, _endValueComplete2), value);
  }
  get rangeComplete() {
    return get(__privateGet(this, _rangeComplete2));
  }
  set rangeComplete(value) {
    set(__privateGet(this, _rangeComplete2), value);
  }
  get startValueTime() {
    return get(__privateGet(this, _startValueTime));
  }
  set startValueTime(value) {
    set(__privateGet(this, _startValueTime), value);
  }
  get endValueTime() {
    return get(__privateGet(this, _endValueTime));
  }
  set endValueTime(value) {
    set(__privateGet(this, _endValueTime), value);
  }
  get minValueTime() {
    return get(__privateGet(this, _minValueTime2));
  }
  set minValueTime(value) {
    set(__privateGet(this, _minValueTime2), value);
  }
  get maxValueTime() {
    return get(__privateGet(this, _maxValueTime2));
  }
  set maxValueTime(value) {
    set(__privateGet(this, _maxValueTime2), value);
  }
  get validationStatus() {
    return get(__privateGet(this, _validationStatus4));
  }
  set validationStatus(value) {
    set(__privateGet(this, _validationStatus4), value);
  }
  get isInvalid() {
    return get(__privateGet(this, _isInvalid6));
  }
  set isInvalid(value) {
    set(__privateGet(this, _isInvalid6), value);
  }
  get props() {
    return get(__privateGet(this, _props153));
  }
  set props(value) {
    set(__privateGet(this, _props153), value);
  }
};
_fieldNode4 = new WeakMap();
_labelNode6 = new WeakMap();
_descriptionNode5 = new WeakMap();
_startValueComplete2 = new WeakMap();
_endValueComplete2 = new WeakMap();
_rangeComplete2 = new WeakMap();
_startValueTime = new WeakMap();
_endValueTime = new WeakMap();
_minValueTime2 = new WeakMap();
_maxValueTime2 = new WeakMap();
_validationStatus4 = new WeakMap();
_isInvalid6 = new WeakMap();
_TimeRangeFieldRootState_instances = new WeakSet();
updateValue_fn4 = function(cb) {
  const value = this.opts.value.current;
  const newValue = cb(value);
  this.opts.value.current = newValue;
};
_props153 = new WeakMap();
var TimeRangeFieldRootState = _TimeRangeFieldRootState;
var _onclick2, _props154;
var _TimeRangeFieldLabelState = class _TimeRangeFieldLabelState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _onclick2, () => {
      if (this.root.opts.disabled.current) return;
      const firstSegment = getFirstSegment(this.root.fieldNode);
      if (!firstSegment) return;
      firstSegment.focus();
    });
    __privateAdd(this, _props154, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-invalid": getDataInvalid(this.root.isInvalid),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        [timeRangeFieldAttrs.label]: "",
        onclick: __privateGet(this, _onclick2),
        ...this.attachment
      })),
      "TimeRangeFieldLabelState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  static create(opts) {
    return new _TimeRangeFieldLabelState(opts, TimeRangeFieldRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props154));
  }
  set props(value) {
    set(__privateGet(this, _props154), value);
  }
};
_onclick2 = new WeakMap();
_props154 = new WeakMap();
var TimeRangeFieldLabelState = _TimeRangeFieldLabelState;
var TimeRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = TimeRangeFieldRootContext.get();
    const fieldState = TimeFieldRootState.create(
      {
        value: strict_equals(type, "start") ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: box.with(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: box.with(() => root18.isInvalid)
      },
      root18
    );
    return new TimeFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field.svelte
Time_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field.svelte";
var root_2107 = add_locations(from_html(`<div><!></div>`), Time_range_field[FILENAME], [[142, 1]]);
function Time_range_field($$anchor, $$props) {
  var _a, _b;
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "disabled",
      "readonly",
      "required",
      "hourCycle",
      "granularity",
      "locale",
      "hideTimeZone",
      "validate",
      "onInvalid",
      "maxValue",
      "minValue",
      "readonlySegments",
      "children",
      "child",
      "onStartValueChange",
      "onEndValueChange",
      "errorMessageId"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy((_a = value()) == null ? void 0 : _a.start)), "startValue");
  let endValue = tag(state(proxy((_b = value()) == null ? void 0 : _b.end)), "endValue");
  function handleDefaultPlaceholder() {
    var _a2;
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultTime({
      granularity: $$props.granularity,
      defaultValue: (_a2 = value()) == null ? void 0 : _a2.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = TimeRangeFieldRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    required: box.with(() => required()),
    hourCycle: box.with(() => $$props.hourCycle),
    granularity: box.with(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    validate: box.with(() => validate()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: box.with(() => readonlySegments()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2107();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field = hmr(Time_range_field, () => Time_range_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field[HMR].source;
    set(Time_range_field[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_default = Time_range_field;

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-input.svelte
Time_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-input.svelte";
var root_2108 = add_locations(from_html(`<div><!></div>`), Time_range_field_input[FILENAME], [[38, 1]]);
var root17 = add_locations(from_html(`<!> <!>`, 1), Time_range_field_input[FILENAME], []);
function Time_range_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const inputState = TimeRangeFieldInputState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      name: box.with(() => name())
    },
    $$props.type
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" })), "mergedProps");
  var fragment = root17();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        segments: inputState.root.segmentContents
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2108();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents }));
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  var node_3 = sibling(node, 2);
  time_field_hidden_input_default(node_3, {});
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field_input = hmr(Time_range_field_input, () => Time_range_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field_input[HMR].source;
    set(Time_range_field_input[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_input_default = Time_range_field_input;

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-label.svelte
Time_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-label.svelte";
var root_2109 = add_locations(from_html(`<span><!></span>`), Time_range_field_label[FILENAME], [[31, 1]]);
function Time_range_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = TimeRangeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2109();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      snippet(node_2, () => $$props.children ?? noop);
      reset(span);
      append($$anchor2, span);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field_label = hmr(Time_range_field_label, () => Time_range_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field_label[HMR].source;
    set(Time_range_field_label[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_label_default = Time_range_field_label;

// node_modules/bits-ui/dist/bits/toggle/exports.js
var exports_exports38 = {};
__export(exports_exports38, {
  Root: () => toggle_default
});

// node_modules/bits-ui/dist/bits/toggle/toggle.svelte.js
var toggleAttrs = createBitsAttrs({ component: "toggle", parts: ["root"] });
var _ToggleRootState_instances, togglePressed_fn, _snippetProps29, _props155;
var _ToggleRootState = class _ToggleRootState {
  constructor(opts) {
    __privateAdd(this, _ToggleRootState_instances);
    __publicField(this, "opts");
    __publicField(this, "attachment");
    __privateAdd(this, _snippetProps29, tag(user_derived(() => ({ pressed: this.opts.pressed.current })), "ToggleRootState.snippetProps"));
    __privateAdd(this, _props155, tag(
      user_derived(() => ({
        [toggleAttrs.root]: "",
        id: this.opts.id.current,
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "aria-pressed": getAriaPressed(this.opts.pressed.current),
        "data-state": getToggleDataState(this.opts.pressed.current),
        disabled: getDisabled(this.opts.disabled.current),
        onclick: this.onclick,
        ...this.attachment
      })),
      "ToggleRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
  }
  static create(opts) {
    return new _ToggleRootState(opts);
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    __privateMethod(this, _ToggleRootState_instances, togglePressed_fn).call(this);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps29));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps29), value);
  }
  get props() {
    return get(__privateGet(this, _props155));
  }
  set props(value) {
    set(__privateGet(this, _props155), value);
  }
};
_ToggleRootState_instances = new WeakSet();
togglePressed_fn = function() {
  if (!this.opts.disabled.current) {
    this.opts.pressed.current = !this.opts.pressed.current;
  }
};
_snippetProps29 = new WeakMap();
_props155 = new WeakMap();
var ToggleRootState = _ToggleRootState;
function getToggleDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte
Toggle[FILENAME] = "node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte";
var root_2110 = add_locations(from_html(`<button><!></button>`), Toggle[FILENAME], [[44, 1]]);
function Toggle($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), pressed = prop($$props, "pressed", 15, false), onPressedChange = prop($$props, "onPressedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "pressed",
      "onPressedChange",
      "disabled",
      "type",
      "children",
      "child"
    ],
    "restProps"
  );
  const toggleState = ToggleRootState.create({
    pressed: box.with(() => pressed(), (v) => {
      pressed(v);
      onPressedChange()(v);
    }),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, toggleState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...toggleState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2110();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => toggleState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle = hmr(Toggle, () => Toggle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle[HMR].source;
    set(Toggle[HMR].source, module.default[HMR].original);
  });
}
var toggle_default = Toggle;

// node_modules/bits-ui/dist/bits/toggle-group/exports.js
var exports_exports39 = {};
__export(exports_exports39, {
  Item: () => toggle_group_item_default,
  Root: () => toggle_group_default
});

// node_modules/bits-ui/dist/bits/toggle-group/toggle-group.svelte.js
var toggleGroupAttrs = createBitsAttrs({
  component: "toggle-group",
  parts: ["root", "item"]
});
var ToggleGroupRootContext = new Context("ToggleGroup.Root");
var _props156;
var ToggleGroupBaseState = class {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props156, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [toggleGroupAttrs.root]: "",
        role: "group",
        "data-orientation": getDataOrientation(this.opts.orientation.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        ...this.attachment
      })),
      "ToggleGroupBaseState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: toggleGroupAttrs.item,
      rootNode: opts.ref,
      loop: opts.loop,
      orientation: opts.orientation
    });
  }
  get props() {
    return get(__privateGet(this, _props156));
  }
  set props(value) {
    set(__privateGet(this, _props156), value);
  }
};
_props156 = new WeakMap();
var _anyPressed;
var ToggleGroupSingleState = class extends ToggleGroupBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed, tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "ToggleGroupSingleState.anyPressed"));
    this.opts = opts;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed), value);
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
_anyPressed = new WeakMap();
var _anyPressed2;
var ToggleGroupMultipleState = class extends ToggleGroupBaseState {
  constructor(opts) {
    super(opts);
    __publicField(this, "opts");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed2, tag(user_derived(() => this.opts.value.current.length > 0), "ToggleGroupMultipleState.anyPressed"));
    this.opts = opts;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed2));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed2), value);
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, item, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
_anyPressed2 = new WeakMap();
var ToggleGroupRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = strict_equals(type, "single") ? new ToggleGroupSingleState(rest) : new ToggleGroupMultipleState(rest);
    return ToggleGroupRootContext.set(rootState);
  }
};
var _isDisabled16, _isPressed, _ariaChecked, _ariaPressed, _ToggleGroupItemState_instances, toggleItem_fn, _tabIndex4, _snippetProps30, _props157;
var _ToggleGroupItemState = class _ToggleGroupItemState {
  constructor(opts, root18) {
    __privateAdd(this, _ToggleGroupItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled16, tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "ToggleGroupItemState.#isDisabled"));
    __privateAdd(this, _isPressed, tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "ToggleGroupItemState.isPressed"));
    __privateAdd(this, _ariaChecked, tag(
      user_derived(() => {
        return this.root.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
      }),
      "ToggleGroupItemState.#ariaChecked"
    ));
    __privateAdd(this, _ariaPressed, tag(
      user_derived(() => {
        return this.root.isMulti ? getAriaPressed(this.isPressed) : void 0;
      }),
      "ToggleGroupItemState.#ariaPressed"
    ));
    __privateAdd(this, _tabIndex4, tag(state(0), "ToggleGroupItemState.#tabIndex"));
    __privateAdd(this, _snippetProps30, tag(user_derived(() => ({ pressed: this.isPressed })), "ToggleGroupItemState.snippetProps"));
    __privateAdd(this, _props157, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: this.root.isMulti ? void 0 : "radio",
        tabindex: get(__privateGet(this, _tabIndex4)),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled16))),
        "data-state": getToggleItemDataState(this.isPressed),
        "data-value": this.opts.value.current,
        "aria-pressed": get(__privateGet(this, _ariaPressed)),
        "aria-checked": get(__privateGet(this, _ariaChecked)),
        disabled: getDisabled(get(__privateGet(this, _isDisabled16))),
        [toggleGroupAttrs.item]: "",
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "ToggleGroupItemState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      if (!this.root.opts.rovingFocus.current) {
        set(__privateGet(this, _tabIndex4), 0);
      } else {
        set(__privateGet(this, _tabIndex4), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
      }
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToggleGroupItemState(opts, ToggleGroupRootContext.get());
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed));
  }
  set isPressed(value) {
    set(__privateGet(this, _isPressed), value);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled16))) return;
    this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled16))) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      __privateMethod(this, _ToggleGroupItemState_instances, toggleItem_fn).call(this);
      return;
    }
    if (!this.root.opts.rovingFocus.current) return;
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps30));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps30), value);
  }
  get props() {
    return get(__privateGet(this, _props157));
  }
  set props(value) {
    set(__privateGet(this, _props157), value);
  }
};
_isDisabled16 = new WeakMap();
_isPressed = new WeakMap();
_ariaChecked = new WeakMap();
_ariaPressed = new WeakMap();
_ToggleGroupItemState_instances = new WeakSet();
toggleItem_fn = function() {
  if (get(__privateGet(this, _isDisabled16))) return;
  this.root.toggleItem(this.opts.value.current, this.opts.id.current);
};
_tabIndex4 = new WeakMap();
_snippetProps30 = new WeakMap();
_props157 = new WeakMap();
var ToggleGroupItemState = _ToggleGroupItemState;
function getToggleItemDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte
Toggle_group[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte";
var root_2111 = add_locations(from_html(`<div><!></div>`), Toggle_group[FILENAME], [[69, 1]]);
function Toggle_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), rovingFocus = prop($$props, "rovingFocus", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "loop",
      "orientation",
      "rovingFocus",
      "child",
      "children"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = ToggleGroupRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    rovingFocus: box.with(() => rovingFocus()),
    type: $$props.type,
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2111();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group = hmr(Toggle_group, () => Toggle_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group[HMR].source;
    set(Toggle_group[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_default = Toggle_group;

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte
Toggle_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte";
var root_2112 = add_locations(from_html(`<button><!></button>`), Toggle_group_item[FILENAME], [[36, 1]]);
function Toggle_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle_group_item);
  let ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "disabled",
      "id",
      "type"
    ],
    "restProps"
  );
  const itemState = ToggleGroupItemState.create({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      var render_arg = derived_safe_equal(() => ({
        props: get(mergedProps),
        ...itemState.snippetProps
      }));
      snippet(node_1, () => $$props.child, () => get(render_arg));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2112();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group_item = hmr(Toggle_group_item, () => Toggle_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group_item[HMR].source;
    set(Toggle_group_item[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_item_default = Toggle_group_item;

// node_modules/bits-ui/dist/bits/toolbar/exports.js
var exports_exports40 = {};
__export(exports_exports40, {
  Button: () => toolbar_button_default,
  Group: () => toolbar_group_default,
  GroupItem: () => toolbar_group_item_default,
  Link: () => toolbar_link_default,
  Root: () => toolbar_default
});

// node_modules/bits-ui/dist/bits/toolbar/toolbar.svelte.js
var toolbarAttrs = createBitsAttrs({
  component: "toolbar",
  parts: [
    "root",
    "item",
    "group",
    "group-item",
    "link",
    "button"
  ]
});
var ToolbarRootContext = new Context("Toolbar.Root");
var ToolbarGroupContext = new Context("Toolbar.Group");
var _props158;
var _ToolbarRootState = class _ToolbarRootState {
  constructor(opts) {
    __publicField(this, "opts");
    __publicField(this, "rovingFocusGroup");
    __publicField(this, "attachment");
    __privateAdd(this, _props158, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: "toolbar",
        "data-orientation": this.opts.orientation.current,
        [toolbarAttrs.root]: "",
        ...this.attachment
      })),
      "ToolbarRootState.props"
    ));
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      orientation: this.opts.orientation,
      loop: this.opts.loop,
      rootNode: this.opts.ref,
      candidateAttr: toolbarAttrs.item
    });
  }
  static create(opts) {
    return ToolbarRootContext.set(new _ToolbarRootState(opts));
  }
  get props() {
    return get(__privateGet(this, _props158));
  }
  set props(value) {
    set(__privateGet(this, _props158), value);
  }
};
_props158 = new WeakMap();
var ToolbarRootState = _ToolbarRootState;
var _props159;
var ToolbarGroupBaseState = class {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _props159, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [toolbarAttrs.group]: "",
        role: "group",
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        ...this.attachment
      })),
      "ToolbarGroupBaseState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  get props() {
    return get(__privateGet(this, _props159));
  }
  set props(value) {
    set(__privateGet(this, _props159), value);
  }
};
_props159 = new WeakMap();
var _anyPressed3;
var ToolbarGroupSingleState = class extends ToolbarGroupBaseState {
  constructor(opts, root18) {
    super(opts, root18);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "isMulti", false);
    __privateAdd(this, _anyPressed3, tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "ToolbarGroupSingleState.anyPressed"));
    this.opts = opts;
    this.root = root18;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed3));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed3), value);
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
    }
  }
};
_anyPressed3 = new WeakMap();
var _anyPressed4;
var ToolbarGroupMultipleState = class extends ToolbarGroupBaseState {
  constructor(opts, root18) {
    super(opts, root18);
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "isMulti", true);
    __privateAdd(this, _anyPressed4, tag(user_derived(() => this.opts.value.current.length > 0), "ToolbarGroupMultipleState.anyPressed"));
    this.opts = opts;
    this.root = root18;
  }
  get anyPressed() {
    return get(__privateGet(this, _anyPressed4));
  }
  set anyPressed(value) {
    set(__privateGet(this, _anyPressed4), value);
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, item, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
    }
  }
};
_anyPressed4 = new WeakMap();
var ToolbarGroupState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = ToolbarRootContext.get();
    const groupState = strict_equals(type, "single") ? new ToolbarGroupSingleState(rest, rootState) : new ToolbarGroupMultipleState(rest, rootState);
    return ToolbarGroupContext.set(groupState);
  }
};
var _isDisabled17, _ToolbarGroupItemState_instances, toggleItem_fn2, _isPressed2, _ariaChecked2, _ariaPressed2, _tabIndex5, _props160;
var _ToolbarGroupItemState = class _ToolbarGroupItemState {
  constructor(opts, group, root18) {
    __privateAdd(this, _ToolbarGroupItemState_instances);
    __publicField(this, "opts");
    __publicField(this, "group");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isDisabled17, tag(user_derived(() => this.opts.disabled.current || this.group.opts.disabled.current), "ToolbarGroupItemState.#isDisabled"));
    __privateAdd(this, _isPressed2, tag(user_derived(() => this.group.includesItem(this.opts.value.current)), "ToolbarGroupItemState.isPressed"));
    __privateAdd(this, _ariaChecked2, tag(
      user_derived(() => {
        return this.group.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
      }),
      "ToolbarGroupItemState.#ariaChecked"
    ));
    __privateAdd(this, _ariaPressed2, tag(
      user_derived(() => {
        return this.group.isMulti ? getAriaPressed(this.isPressed) : void 0;
      }),
      "ToolbarGroupItemState.#ariaPressed"
    ));
    __privateAdd(this, _tabIndex5, tag(state(0), "ToolbarGroupItemState.#tabIndex"));
    __privateAdd(this, _props160, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        role: this.group.isMulti ? void 0 : "radio",
        tabindex: get(__privateGet(this, _tabIndex5)),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled17))),
        "data-state": getToggleItemDataState2(this.isPressed),
        "data-value": this.opts.value.current,
        "aria-pressed": get(__privateGet(this, _ariaPressed2)),
        "aria-checked": get(__privateGet(this, _ariaChecked2)),
        [toolbarAttrs.item]: "",
        [toolbarAttrs["group-item"]]: "",
        disabled: getDisabled(get(__privateGet(this, _isDisabled17))),
        //
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "ToolbarGroupItemState.props"
    ));
    this.opts = opts;
    this.group = group;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex5), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    const group = ToolbarGroupContext.get();
    return new _ToolbarGroupItemState(opts, group, group.root);
  }
  onclick(_) {
    if (get(__privateGet(this, _isDisabled17))) return;
    __privateMethod(this, _ToolbarGroupItemState_instances, toggleItem_fn2).call(this);
  }
  onkeydown(e) {
    if (get(__privateGet(this, _isDisabled17))) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      __privateMethod(this, _ToolbarGroupItemState_instances, toggleItem_fn2).call(this);
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get isPressed() {
    return get(__privateGet(this, _isPressed2));
  }
  set isPressed(value) {
    set(__privateGet(this, _isPressed2), value);
  }
  get props() {
    return get(__privateGet(this, _props160));
  }
  set props(value) {
    set(__privateGet(this, _props160), value);
  }
};
_isDisabled17 = new WeakMap();
_ToolbarGroupItemState_instances = new WeakSet();
toggleItem_fn2 = function() {
  if (get(__privateGet(this, _isDisabled17))) return;
  this.group.toggleItem(this.opts.value.current);
};
_isPressed2 = new WeakMap();
_ariaChecked2 = new WeakMap();
_ariaPressed2 = new WeakMap();
_tabIndex5 = new WeakMap();
_props160 = new WeakMap();
var ToolbarGroupItemState = _ToolbarGroupItemState;
var _role, _tabIndex6, _props161;
var _ToolbarLinkState = class _ToolbarLinkState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _role, tag(
      user_derived(() => {
        if (!this.opts.ref.current) return void 0;
        const tagName = this.opts.ref.current.tagName;
        if (strict_equals(tagName, "A", false)) return "link";
        return void 0;
      }),
      "ToolbarLinkState.#role"
    ));
    __privateAdd(this, _tabIndex6, tag(state(0), "ToolbarLinkState.#tabIndex"));
    __privateAdd(this, _props161, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [toolbarAttrs.link]: "",
        [toolbarAttrs.item]: "",
        role: get(__privateGet(this, _role)),
        tabindex: get(__privateGet(this, _tabIndex6)),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        //
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "ToolbarLinkState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex6), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToolbarLinkState(opts, ToolbarRootContext.get());
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props161));
  }
  set props(value) {
    set(__privateGet(this, _props161), value);
  }
};
_role = new WeakMap();
_tabIndex6 = new WeakMap();
_props161 = new WeakMap();
var ToolbarLinkState = _ToolbarLinkState;
var _tabIndex7, _role2, _props162;
var _ToolbarButtonState = class _ToolbarButtonState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _tabIndex7, tag(state(0), "ToolbarButtonState.#tabIndex"));
    __privateAdd(this, _role2, tag(
      user_derived(() => {
        if (!this.opts.ref.current) return void 0;
        const tagName = this.opts.ref.current.tagName;
        if (strict_equals(tagName, "BUTTON", false)) return "button";
        return void 0;
      }),
      "ToolbarButtonState.#role"
    ));
    __privateAdd(this, _props162, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        [toolbarAttrs.item]: "",
        [toolbarAttrs.button]: "",
        role: get(__privateGet(this, _role2)),
        tabindex: get(__privateGet(this, _tabIndex7)),
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        disabled: getDisabled(this.opts.disabled.current),
        //
        onkeydown: this.onkeydown,
        ...this.attachment
      })),
      "ToolbarButtonState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(__privateGet(this, _tabIndex7), this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  static create(opts) {
    return new _ToolbarButtonState(opts, ToolbarRootContext.get());
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  get props() {
    return get(__privateGet(this, _props162));
  }
  set props(value) {
    set(__privateGet(this, _props162), value);
  }
};
_tabIndex7 = new WeakMap();
_role2 = new WeakMap();
_props162 = new WeakMap();
var ToolbarButtonState = _ToolbarButtonState;
function getToggleItemDataState2(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte
Toolbar[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte";
var root_2113 = add_locations(from_html(`<div><!></div>`), Toolbar[FILENAME], [[35, 1]]);
function Toolbar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation",
      "loop",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = ToolbarRootState.create({
    id: box.with(() => id()),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2113();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar = hmr(Toolbar, () => Toolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar[HMR].source;
    set(Toolbar[HMR].source, module.default[HMR].original);
  });
}
var toolbar_default = Toolbar;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte
Toolbar_button[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte";
var root_2114 = add_locations(from_html(`<button><!></button>`), Toolbar_button[FILENAME], [[34, 1]]);
function Toolbar_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_button);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const buttonState = ToolbarButtonState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, buttonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2114();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop);
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_button = hmr(Toolbar_button, () => Toolbar_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_button[HMR].source;
    set(Toolbar_button[HMR].source, module.default[HMR].original);
  });
}
var toolbar_button_default = Toolbar_button;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte
Toolbar_link[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte";
var root_2115 = add_locations(from_html(`<a><!></a>`), Toolbar_link[FILENAME], [[32, 1]]);
function Toolbar_link($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_link);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "href",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const linkState = ToolbarLinkState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, linkState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_2115();
      attribute_effect(a2, () => ({ href: $$props.href, ...get(mergedProps) }));
      var node_2 = child(a2);
      snippet(node_2, () => $$props.children ?? noop);
      reset(a2);
      append($$anchor2, a2);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_link = hmr(Toolbar_link, () => Toolbar_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_link[HMR].source;
    set(Toolbar_link[HMR].source, module.default[HMR].original);
  });
}
var toolbar_link_default = Toolbar_link;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte
Toolbar_group[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte";
var root_2116 = add_locations(from_html(`<div><!></div>`), Toolbar_group[FILENAME], [[63, 1]]);
function Toolbar_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "child",
      "children"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const groupState = ToolbarGroupState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2116();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group = hmr(Toolbar_group, () => Toolbar_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group[HMR].source;
    set(Toolbar_group[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_default = Toolbar_group;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte
Toolbar_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte";
var root_2117 = add_locations(from_html(`<button><!></button>`), Toolbar_group_item[FILENAME], [[36, 1]]);
function Toolbar_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_group_item);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const groupItemState = ToolbarGroupItemState.create({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupItemState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.child, () => ({
        props: get(mergedProps),
        pressed: groupItemState.isPressed
      }));
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2117();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: groupItemState.isPressed }));
      reset(button);
      append($$anchor2, button);
    };
    if_block(node, ($$render) => {
      if ($$props.child) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group_item = hmr(Toolbar_group_item, () => Toolbar_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group_item[HMR].source;
    set(Toolbar_group_item[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_item_default = Toolbar_group_item;

// node_modules/bits-ui/dist/bits/tooltip/exports.js
var exports_exports41 = {};
__export(exports_exports41, {
  Arrow: () => tooltip_arrow_default,
  Content: () => tooltip_content_default,
  ContentStatic: () => tooltip_content_static_default,
  Portal: () => portal_default,
  Provider: () => tooltip_provider_default,
  Root: () => tooltip_default,
  Trigger: () => tooltip_trigger_default
});

// node_modules/bits-ui/dist/internal/timeout-fn.js
var defaultOpts = {
  immediate: true
};
var _opts8, _interval, _cb, _timer2, _TimeoutFn_instances, clear_fn;
var TimeoutFn = class {
  constructor(cb, interval, opts = {}) {
    __privateAdd(this, _TimeoutFn_instances);
    __privateAdd(this, _opts8);
    __privateAdd(this, _interval);
    __privateAdd(this, _cb);
    __privateAdd(this, _timer2, null);
    __privateSet(this, _cb, cb);
    __privateSet(this, _interval, interval);
    __privateSet(this, _opts8, { ...defaultOpts, ...opts });
    this.stop = this.stop.bind(this);
    this.start = this.start.bind(this);
    if (__privateGet(this, _opts8).immediate && true_default) {
      this.start();
    }
    onDestroyEffect(this.stop);
  }
  stop() {
    __privateMethod(this, _TimeoutFn_instances, clear_fn).call(this);
  }
  start(...args) {
    __privateMethod(this, _TimeoutFn_instances, clear_fn).call(this);
    __privateSet(this, _timer2, window.setTimeout(() => {
      __privateSet(this, _timer2, null);
      __privateGet(this, _cb).call(this, ...args);
    }, __privateGet(this, _interval)));
  }
};
_opts8 = new WeakMap();
_interval = new WeakMap();
_cb = new WeakMap();
_timer2 = new WeakMap();
_TimeoutFn_instances = new WeakSet();
clear_fn = function() {
  if (__privateGet(this, _timer2) !== null) {
    window.clearTimeout(__privateGet(this, _timer2));
    __privateSet(this, _timer2, null);
  }
};

// node_modules/bits-ui/dist/bits/tooltip/tooltip.svelte.js
var tooltipAttrs = createBitsAttrs({
  component: "tooltip",
  parts: ["content", "trigger"]
});
var TooltipProviderContext = new Context("Tooltip.Provider");
var TooltipRootContext = new Context("Tooltip.Root");
var _isOpenDelayed, _timerFn, _openTooltip, _startTimer, _clearTimer;
var _TooltipProviderState = class _TooltipProviderState {
  constructor(opts) {
    __publicField(this, "opts");
    __privateAdd(this, _isOpenDelayed, tag(state(true), "TooltipProviderState.isOpenDelayed"));
    __publicField(this, "isPointerInTransit", box(false));
    __privateAdd(this, _timerFn);
    __privateAdd(this, _openTooltip, tag(state(null), "TooltipProviderState.#openTooltip"));
    __privateAdd(this, _startTimer, () => {
      const skipDuration = this.opts.skipDelayDuration.current;
      if (strict_equals(skipDuration, 0)) {
        return;
      } else {
        __privateGet(this, _timerFn).start();
      }
    });
    __privateAdd(this, _clearTimer, () => {
      __privateGet(this, _timerFn).stop();
    });
    __publicField(this, "onOpen", (tooltip) => {
      if (get(__privateGet(this, _openTooltip)) && strict_equals(get(__privateGet(this, _openTooltip)), tooltip, false)) {
        get(__privateGet(this, _openTooltip)).handleClose();
      }
      __privateGet(this, _clearTimer).call(this);
      this.isOpenDelayed = false;
      set(__privateGet(this, _openTooltip), tooltip, true);
    });
    __publicField(this, "onClose", (tooltip) => {
      if (strict_equals(get(__privateGet(this, _openTooltip)), tooltip)) {
        set(__privateGet(this, _openTooltip), null);
      }
      __privateGet(this, _startTimer).call(this);
    });
    __publicField(this, "isTooltipOpen", (tooltip) => {
      return strict_equals(get(__privateGet(this, _openTooltip)), tooltip);
    });
    this.opts = opts;
    __privateSet(this, _timerFn, new TimeoutFn(
      () => {
        this.isOpenDelayed = true;
      },
      this.opts.skipDelayDuration.current,
      { immediate: false }
    ));
  }
  static create(opts) {
    return TooltipProviderContext.set(new _TooltipProviderState(opts));
  }
  get isOpenDelayed() {
    return get(__privateGet(this, _isOpenDelayed));
  }
  set isOpenDelayed(value) {
    set(__privateGet(this, _isOpenDelayed), value, true);
  }
};
_isOpenDelayed = new WeakMap();
_timerFn = new WeakMap();
_openTooltip = new WeakMap();
_startTimer = new WeakMap();
_clearTimer = new WeakMap();
var TooltipProviderState = _TooltipProviderState;
var _delayDuration, _disableHoverableContent, _disableCloseOnTriggerClick, _disabled, _ignoreNonKeyboardFocus, _contentNode11, _triggerNode8, _wasOpenDelayed, _timerFn2, _stateAttr, _handleDelayedOpen;
var _TooltipRootState = class _TooltipRootState {
  constructor(opts, provider) {
    __publicField(this, "opts");
    __publicField(this, "provider");
    __privateAdd(this, _delayDuration, tag(user_derived(() => this.opts.delayDuration.current ?? this.provider.opts.delayDuration.current), "TooltipRootState.delayDuration"));
    __privateAdd(this, _disableHoverableContent, tag(user_derived(() => this.opts.disableHoverableContent.current ?? this.provider.opts.disableHoverableContent.current), "TooltipRootState.disableHoverableContent"));
    __privateAdd(this, _disableCloseOnTriggerClick, tag(user_derived(() => this.opts.disableCloseOnTriggerClick.current ?? this.provider.opts.disableCloseOnTriggerClick.current), "TooltipRootState.disableCloseOnTriggerClick"));
    __privateAdd(this, _disabled, tag(user_derived(() => this.opts.disabled.current ?? this.provider.opts.disabled.current), "TooltipRootState.disabled"));
    __privateAdd(this, _ignoreNonKeyboardFocus, tag(user_derived(() => this.opts.ignoreNonKeyboardFocus.current ?? this.provider.opts.ignoreNonKeyboardFocus.current), "TooltipRootState.ignoreNonKeyboardFocus"));
    __privateAdd(this, _contentNode11, tag(state(null), "TooltipRootState.contentNode"));
    __privateAdd(this, _triggerNode8, tag(state(null), "TooltipRootState.triggerNode"));
    __privateAdd(this, _wasOpenDelayed, tag(state(false), "TooltipRootState.#wasOpenDelayed"));
    __privateAdd(this, _timerFn2);
    __privateAdd(this, _stateAttr, tag(
      user_derived(() => {
        if (!this.opts.open.current) return "closed";
        return get(__privateGet(this, _wasOpenDelayed)) ? "delayed-open" : "instant-open";
      }),
      "TooltipRootState.stateAttr"
    ));
    __publicField(this, "handleOpen", () => {
      __privateGet(this, _timerFn2).stop();
      set(__privateGet(this, _wasOpenDelayed), false);
      this.opts.open.current = true;
    });
    __publicField(this, "handleClose", () => {
      __privateGet(this, _timerFn2).stop();
      this.opts.open.current = false;
    });
    __privateAdd(this, _handleDelayedOpen, () => {
      __privateGet(this, _timerFn2).stop();
      const shouldSkipDelay = !this.provider.isOpenDelayed;
      const delayDuration = this.delayDuration ?? 0;
      if (shouldSkipDelay || strict_equals(delayDuration, 0)) {
        set(__privateGet(this, _wasOpenDelayed), delayDuration > 0 && shouldSkipDelay, true);
        this.opts.open.current = true;
      } else {
        __privateGet(this, _timerFn2).start();
      }
    });
    __publicField(this, "onTriggerEnter", () => {
      __privateGet(this, _handleDelayedOpen).call(this);
    });
    __publicField(this, "onTriggerLeave", () => {
      if (this.disableHoverableContent) {
        this.handleClose();
      } else {
        __privateGet(this, _timerFn2).stop();
      }
    });
    this.opts = opts;
    this.provider = provider;
    __privateSet(this, _timerFn2, new TimeoutFn(
      () => {
        set(__privateGet(this, _wasOpenDelayed), true);
        this.opts.open.current = true;
      },
      this.delayDuration ?? 0,
      { immediate: false }
    ));
    new OpenChangeComplete({
      open: this.opts.open,
      ref: box.with(() => this.contentNode),
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.delayDuration, () => {
      if (strict_equals(this.delayDuration, void 0)) return;
      __privateSet(this, _timerFn2, new TimeoutFn(
        () => {
          set(__privateGet(this, _wasOpenDelayed), true);
          this.opts.open.current = true;
        },
        this.delayDuration,
        { immediate: false }
      ));
    });
    watch(() => this.opts.open.current, (isOpen) => {
      if (isOpen) {
        this.provider.onOpen(this);
      } else {
        this.provider.onClose(this);
      }
    });
  }
  static create(opts) {
    return TooltipRootContext.set(new _TooltipRootState(opts, TooltipProviderContext.get()));
  }
  get delayDuration() {
    return get(__privateGet(this, _delayDuration));
  }
  set delayDuration(value) {
    set(__privateGet(this, _delayDuration), value);
  }
  get disableHoverableContent() {
    return get(__privateGet(this, _disableHoverableContent));
  }
  set disableHoverableContent(value) {
    set(__privateGet(this, _disableHoverableContent), value);
  }
  get disableCloseOnTriggerClick() {
    return get(__privateGet(this, _disableCloseOnTriggerClick));
  }
  set disableCloseOnTriggerClick(value) {
    set(__privateGet(this, _disableCloseOnTriggerClick), value);
  }
  get disabled() {
    return get(__privateGet(this, _disabled));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled), value);
  }
  get ignoreNonKeyboardFocus() {
    return get(__privateGet(this, _ignoreNonKeyboardFocus));
  }
  set ignoreNonKeyboardFocus(value) {
    set(__privateGet(this, _ignoreNonKeyboardFocus), value);
  }
  get contentNode() {
    return get(__privateGet(this, _contentNode11));
  }
  set contentNode(value) {
    set(__privateGet(this, _contentNode11), value, true);
  }
  get triggerNode() {
    return get(__privateGet(this, _triggerNode8));
  }
  set triggerNode(value) {
    set(__privateGet(this, _triggerNode8), value, true);
  }
  get stateAttr() {
    return get(__privateGet(this, _stateAttr));
  }
  set stateAttr(value) {
    set(__privateGet(this, _stateAttr), value);
  }
};
_delayDuration = new WeakMap();
_disableHoverableContent = new WeakMap();
_disableCloseOnTriggerClick = new WeakMap();
_disabled = new WeakMap();
_ignoreNonKeyboardFocus = new WeakMap();
_contentNode11 = new WeakMap();
_triggerNode8 = new WeakMap();
_wasOpenDelayed = new WeakMap();
_timerFn2 = new WeakMap();
_stateAttr = new WeakMap();
_handleDelayedOpen = new WeakMap();
var TooltipRootState = _TooltipRootState;
var _isPointerDown2, _hasPointerMoveOpened, _isDisabled18, _onpointerup, _onpointerdown, _onpointermove, _onpointerleave, _onfocus, _onblur, _onclick3, _props163;
var _TooltipTriggerState = class _TooltipTriggerState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __privateAdd(this, _isPointerDown2, box(false));
    __privateAdd(this, _hasPointerMoveOpened, tag(state(false), "TooltipTriggerState.#hasPointerMoveOpened"));
    __privateAdd(this, _isDisabled18, tag(user_derived(() => this.opts.disabled.current || this.root.disabled), "TooltipTriggerState.#isDisabled"));
    __publicField(this, "domContext");
    __publicField(this, "handlePointerUp", () => {
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerup, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      __privateGet(this, _isPointerDown2).current = false;
    });
    __privateAdd(this, _onpointerdown, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      __privateGet(this, _isPointerDown2).current = true;
      this.domContext.getDocument().addEventListener(
        "pointerup",
        () => {
          this.handlePointerUp();
        },
        { once: true }
      );
    });
    __privateAdd(this, _onpointermove, (e) => {
      if (get(__privateGet(this, _isDisabled18))) return;
      if (strict_equals(e.pointerType, "touch")) return;
      if (get(__privateGet(this, _hasPointerMoveOpened))) return;
      if (this.root.provider.isPointerInTransit.current) return;
      this.root.onTriggerEnter();
      set(__privateGet(this, _hasPointerMoveOpened), true);
    });
    __privateAdd(this, _onpointerleave, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      this.root.onTriggerLeave();
      set(__privateGet(this, _hasPointerMoveOpened), false);
    });
    __privateAdd(this, _onfocus, (e) => {
      if (__privateGet(this, _isPointerDown2).current || get(__privateGet(this, _isDisabled18))) return;
      if (this.root.ignoreNonKeyboardFocus && !isFocusVisible(e.currentTarget)) return;
      this.root.handleOpen();
    });
    __privateAdd(this, _onblur, () => {
      if (get(__privateGet(this, _isDisabled18))) return;
      this.root.handleClose();
    });
    __privateAdd(this, _onclick3, () => {
      if (this.root.disableCloseOnTriggerClick || get(__privateGet(this, _isDisabled18))) return;
      this.root.handleClose();
    });
    __privateAdd(this, _props163, tag(
      user_derived(() => {
        var _a;
        return {
          id: this.opts.id.current,
          "aria-describedby": this.root.opts.open.current ? (_a = this.root.contentNode) == null ? void 0 : _a.id : void 0,
          "data-state": this.root.stateAttr,
          "data-disabled": getDataDisabled(get(__privateGet(this, _isDisabled18))),
          "data-delay-duration": `${this.root.delayDuration}`,
          [tooltipAttrs.trigger]: "",
          tabindex: get(__privateGet(this, _isDisabled18)) ? void 0 : 0,
          disabled: this.opts.disabled.current,
          onpointerup: __privateGet(this, _onpointerup),
          onpointerdown: __privateGet(this, _onpointerdown),
          onpointermove: __privateGet(this, _onpointermove),
          onpointerleave: __privateGet(this, _onpointerleave),
          onfocus: __privateGet(this, _onfocus),
          onblur: __privateGet(this, _onblur),
          onclick: __privateGet(this, _onclick3),
          ...this.attachment
        };
      }),
      "TooltipTriggerState.props"
    ));
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
  }
  static create(opts) {
    return new _TooltipTriggerState(opts, TooltipRootContext.get());
  }
  get props() {
    return get(__privateGet(this, _props163));
  }
  set props(value) {
    set(__privateGet(this, _props163), value);
  }
};
_isPointerDown2 = new WeakMap();
_hasPointerMoveOpened = new WeakMap();
_isDisabled18 = new WeakMap();
_onpointerup = new WeakMap();
_onpointerdown = new WeakMap();
_onpointermove = new WeakMap();
_onpointerleave = new WeakMap();
_onfocus = new WeakMap();
_onblur = new WeakMap();
_onclick3 = new WeakMap();
_props163 = new WeakMap();
var TooltipTriggerState = _TooltipTriggerState;
var _snippetProps31, _props164;
var _TooltipContentState = class _TooltipContentState {
  constructor(opts, root18) {
    __publicField(this, "opts");
    __publicField(this, "root");
    __publicField(this, "attachment");
    __publicField(this, "onInteractOutside", (e) => {
      var _a;
      if (isElement2(e.target) && ((_a = this.root.triggerNode) == null ? void 0 : _a.contains(e.target)) && this.root.disableCloseOnTriggerClick) {
        e.preventDefault();
        return;
      }
      this.opts.onInteractOutside.current(e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onEscapeKeydown", (e) => {
      var _a, _b;
      (_b = (_a = this.opts.onEscapeKeydown).current) == null ? void 0 : _b.call(_a, e);
      if (e.defaultPrevented) return;
      this.root.handleClose();
    });
    __publicField(this, "onOpenAutoFocus", (e) => {
      e.preventDefault();
    });
    __publicField(this, "onCloseAutoFocus", (e) => {
      e.preventDefault();
    });
    __privateAdd(this, _snippetProps31, tag(user_derived(() => ({ open: this.root.opts.open.current })), "TooltipContentState.snippetProps"));
    __privateAdd(this, _props164, tag(
      user_derived(() => ({
        id: this.opts.id.current,
        "data-state": this.root.stateAttr,
        "data-disabled": getDataDisabled(this.root.disabled),
        style: { pointerEvents: "auto", outline: "none" },
        [tooltipAttrs.content]: "",
        ...this.attachment
      })),
      "TooltipContentState.props"
    ));
    __publicField(this, "popperProps", {
      onInteractOutside: this.onInteractOutside,
      onEscapeKeydown: this.onEscapeKeydown,
      onOpenAutoFocus: this.onOpenAutoFocus,
      onCloseAutoFocus: this.onCloseAutoFocus
    });
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && !this.root.disableHoverableContent,
      onPointerExit: () => {
        if (this.root.provider.isTooltipOpen(this.root)) {
          this.root.handleClose();
        }
      },
      setIsPointerInTransit: (value) => {
        this.root.provider.isPointerInTransit.current = value;
      },
      transitTimeout: this.root.provider.opts.skipDelayDuration.current
    });
    onMountEffect(() => on(window, "scroll", (e) => {
      const target = e.target;
      if (!target) return;
      if (target.contains(this.root.triggerNode)) {
        this.root.handleClose();
      }
    }));
  }
  static create(opts) {
    return new _TooltipContentState(opts, TooltipRootContext.get());
  }
  get snippetProps() {
    return get(__privateGet(this, _snippetProps31));
  }
  set snippetProps(value) {
    set(__privateGet(this, _snippetProps31), value);
  }
  get props() {
    return get(__privateGet(this, _props164));
  }
  set props(value) {
    set(__privateGet(this, _props164), value);
  }
};
_snippetProps31 = new WeakMap();
_props164 = new WeakMap();
var TooltipContentState = _TooltipContentState;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte
Tooltip[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte";
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  TooltipRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    delayDuration: box.with(() => $$props.delayDuration),
    disableCloseOnTriggerClick: box.with(() => $$props.disableCloseOnTriggerClick),
    disableHoverableContent: box.with(() => $$props.disableHoverableContent),
    ignoreNonKeyboardFocus: box.with(() => $$props.ignoreNonKeyboardFocus),
    disabled: box.with(() => $$props.disabled),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_default(node, {
    tooltip: true,
    children: wrap_snippet(Tooltip, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      snippet(node_1, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module.default[HMR].original);
  });
}
var tooltip_default = Tooltip;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte
Tooltip_content[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte";
var root_421 = add_locations(from_html(`<div><div><!></div></div>`), Tooltip_content[FILENAME], [[76, 4, [[77, 5]]]]);
var root_915 = add_locations(from_html(`<div><div><!></div></div>`), Tooltip_content[FILENAME], [[104, 4, [[105, 5]]]]);
function Tooltip_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = TooltipContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const floatingProps = tag(
    user_derived(() => ({
      side: side(),
      sideOffset: sideOffset(),
      align: align(),
      avoidCollisions: avoidCollisions(),
      arrowPadding: arrowPadding(),
      sticky: sticky(),
      hideWhenDetached: hideWhenDetached(),
      collisionPadding: collisionPadding()
    })),
    "floatingProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                wrapperProps: wrapperProps(),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_421();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div_1);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get ref() {
            return contentState.opts.ref;
          },
          tooltip: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Tooltip_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              let wrapperProps = () => $$arg0 == null ? void 0 : $$arg0().wrapperProps;
              wrapperProps();
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              get(mergedProps2);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    wrapperProps: wrapperProps(),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_2 = root_915();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_8 = child(div_3);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get ref() {
                return contentState.opts.ref;
              },
              tooltip: true,
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content = hmr(Tooltip_content, () => Tooltip_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content[HMR].source;
    set(Tooltip_content[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_default = Tooltip_content;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte
Tooltip_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte";
var root_422 = add_locations(from_html(`<div><!></div>`), Tooltip_content_static[FILENAME], [[58, 4]]);
var root_916 = add_locations(from_html(`<div><!></div>`), Tooltip_content_static[FILENAME], [[85, 4]]);
function Tooltip_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = TooltipContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0 == null ? void 0 : $$arg0().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = user_derived(() => mergeProps(props(), {
            style: getFloatingContentCSSVars("tooltip")
          }));
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              var render_arg = derived_safe_equal(() => ({
                props: get(mergedProps2),
                ...contentState.snippetProps
              }));
              snippet(node_3, () => $$props.child, () => get(render_arg));
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_422();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div);
              snippet(node_4, () => $$props.children ?? noop);
              reset(div);
              append($$anchor4, div);
            };
            if_block(node_2, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            });
          }
          append($$anchor3, fragment_2);
        });
        popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
          isStatic: true,
          get enabled() {
            return contentState.root.opts.open.current;
          },
          get id() {
            return id();
          },
          trapFocus: false,
          loop: false,
          preventScroll: false,
          forceMount: true,
          get ref() {
            return contentState.opts.ref;
          },
          tooltip: true,
          popper,
          $$slots: { popper: true }
        }));
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2, $$elseif) => {
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_5 = first_child(fragment_4);
          {
            const popper = wrap_snippet(Tooltip_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0 == null ? void 0 : $$arg0().props;
              props();
              var fragment_5 = comment();
              const mergedProps2 = user_derived(() => mergeProps(props(), {
                style: getFloatingContentCSSVars("tooltip")
              }));
              get(mergedProps2);
              var node_6 = first_child(fragment_5);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  var render_arg_1 = derived_safe_equal(() => ({
                    props: get(mergedProps2),
                    ...contentState.snippetProps
                  }));
                  snippet(node_7, () => $$props.child, () => get(render_arg_1));
                  append($$anchor5, fragment_6);
                };
                var alternate_2 = ($$anchor5) => {
                  var div_1 = root_916();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_8 = child(div_1);
                  snippet(node_8, () => $$props.children ?? noop);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                if_block(node_6, ($$render) => {
                  if ($$props.child) $$render(consequent_2);
                  else $$render(alternate_2, false);
                });
              }
              append($$anchor4, fragment_5);
            });
            popper_layer_default(node_5, spread_props(() => get(mergedProps), () => contentState.popperProps, {
              tooltip: true,
              isStatic: true,
              get open() {
                return contentState.root.opts.open.current;
              },
              get id() {
                return id();
              },
              trapFocus: false,
              loop: false,
              preventScroll: false,
              forceMount: false,
              get ref() {
                return contentState.opts.ref;
              },
              popper,
              $$slots: { popper: true }
            }));
          }
          append($$anchor3, fragment_4);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (!forceMount()) $$render(consequent_3);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (forceMount()) $$render(consequent_1);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content_static = hmr(Tooltip_content_static, () => Tooltip_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content_static[HMR].source;
    set(Tooltip_content_static[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_static_default = Tooltip_content_static;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte
Tooltip_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte";
var root_323 = add_locations(from_html(`<button><!></button>`), Tooltip_trigger[FILENAME], [[36, 2]]);
function Tooltip_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "disabled",
      "type",
      "ref"
    ],
    "restProps"
  );
  const triggerState = TooltipTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  floating_layer_anchor_default(node, {
    get id() {
      return id();
    },
    get ref() {
      return triggerState.opts.ref;
    },
    tooltip: true,
    children: wrap_snippet(Tooltip_trigger, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) }));
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var button = root_323();
          attribute_effect(button, () => ({ ...get(mergedProps) }));
          var node_3 = child(button);
          snippet(node_3, () => $$props.children ?? noop);
          reset(button);
          append($$anchor3, button);
        };
        if_block(node_1, ($$render) => {
          if ($$props.child) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_trigger = hmr(Tooltip_trigger, () => Tooltip_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_trigger[HMR].source;
    set(Tooltip_trigger[HMR].source, module.default[HMR].original);
  });
}
var tooltip_trigger_default = Tooltip_trigger;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte
Tooltip_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte";
function Tooltip_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    floating_layer_arrow_default(node, spread_props(() => restProps, {
      get ref() {
        return ref();
      },
      set ref($$value) {
        ref($$value);
      }
    }));
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_arrow = hmr(Tooltip_arrow, () => Tooltip_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_arrow[HMR].source;
    set(Tooltip_arrow[HMR].source, module.default[HMR].original);
  });
}
var tooltip_arrow_default = Tooltip_arrow;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte
Tooltip_provider[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte";
function Tooltip_provider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_provider);
  let delayDuration = prop($$props, "delayDuration", 3, 700), disableCloseOnTriggerClick = prop($$props, "disableCloseOnTriggerClick", 3, false), disableHoverableContent = prop($$props, "disableHoverableContent", 3, false), disabled = prop($$props, "disabled", 3, false), ignoreNonKeyboardFocus = prop($$props, "ignoreNonKeyboardFocus", 3, false), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300);
  TooltipProviderState.create({
    delayDuration: box.with(() => delayDuration()),
    disableCloseOnTriggerClick: box.with(() => disableCloseOnTriggerClick()),
    disableHoverableContent: box.with(() => disableHoverableContent()),
    disabled: box.with(() => disabled()),
    ignoreNonKeyboardFocus: box.with(() => ignoreNonKeyboardFocus()),
    skipDelayDuration: box.with(() => skipDelayDuration())
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_provider = hmr(Tooltip_provider, () => Tooltip_provider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_provider[HMR].source;
    set(Tooltip_provider[HMR].source, module.default[HMR].original);
  });
}
var tooltip_provider_default = Tooltip_provider;

// node_modules/bits-ui/dist/bits/utilities/is-using-keyboard/is-using-keyboard.svelte.js
var isUsingKeyboard = tag(state(false), "isUsingKeyboard");
var _IsUsingKeyboard = class _IsUsingKeyboard {
  constructor() {
    user_effect(() => {
      if (strict_equals(_IsUsingKeyboard._refs, 0)) {
        _IsUsingKeyboard._cleanup = effect_root(() => {
          const callbacksToDispose = [];
          const handlePointer = (_) => {
            set(isUsingKeyboard, false);
          };
          const handleKeydown = (_) => {
            set(isUsingKeyboard, true);
          };
          callbacksToDispose.push(on(document, "pointerdown", handlePointer, { capture: true }), on(document, "pointermove", handlePointer, { capture: true }), on(document, "keydown", handleKeydown, { capture: true }));
          return executeCallbacks(...callbacksToDispose);
        });
      }
      _IsUsingKeyboard._refs++;
      return () => {
        var _a;
        _IsUsingKeyboard._refs--;
        if (strict_equals(_IsUsingKeyboard._refs, 0)) {
          set(isUsingKeyboard, false);
          (_a = _IsUsingKeyboard._cleanup) == null ? void 0 : _a.call(_IsUsingKeyboard);
        }
      };
    });
  }
  get current() {
    return get(isUsingKeyboard);
  }
  set current(value) {
    set(isUsingKeyboard, value, true);
  }
};
__publicField(_IsUsingKeyboard, "_refs", 0);
// Reference counting to avoid multiple listeners.
__publicField(_IsUsingKeyboard, "_cleanup");
var IsUsingKeyboard = _IsUsingKeyboard;
export {
  exports_exports as Accordion,
  exports_exports2 as AlertDialog,
  exports_exports3 as AspectRatio,
  exports_exports4 as Avatar,
  bits_config_default as BitsConfig,
  exports_exports5 as Button,
  exports_exports6 as Calendar,
  exports_exports7 as Checkbox,
  exports_exports8 as Collapsible,
  exports_exports9 as Combobox,
  exports_exports10 as Command,
  exports_exports11 as ContextMenu,
  exports_exports12 as DateField,
  exports_exports13 as DatePicker,
  exports_exports14 as DateRangeField,
  exports_exports15 as DateRangePicker,
  exports_exports16 as Dialog,
  exports_exports17 as DropdownMenu,
  IsUsingKeyboard,
  exports_exports18 as Label,
  exports_exports19 as LinkPreview,
  exports_exports20 as Menubar,
  exports_exports21 as Meter,
  exports_exports22 as NavigationMenu,
  exports_exports23 as Pagination,
  exports_exports24 as PinInput,
  exports_exports25 as Popover,
  portal_default as Portal,
  exports_exports26 as Progress,
  REGEXP_ONLY_CHARS,
  REGEXP_ONLY_DIGITS,
  REGEXP_ONLY_DIGITS_AND_CHARS,
  exports_exports27 as RadioGroup,
  exports_exports28 as RangeCalendar,
  exports_exports30 as ScrollArea,
  exports_exports31 as Select,
  exports_exports32 as Separator,
  exports_exports33 as Slider,
  exports_exports34 as Switch,
  exports_exports35 as Tabs,
  exports_exports36 as TimeField,
  exports_exports37 as TimeRangeField,
  exports_exports38 as Toggle,
  exports_exports39 as ToggleGroup,
  exports_exports40 as Toolbar,
  exports_exports41 as Tooltip,
  computeCommandScore,
  getBitsConfig,
  mergeProps,
  exports_exports29 as unstable_RatingGroup,
  useId
};
//# sourceMappingURL=bits-ui.js.map
